// Definition of IoP Location Based Network protocol.
// We strictly use only features that are binary compatible in ProtoBuf v2 and v3.
// We use no v2 or v3 specific features.
 
syntax = "proto3";

package iop.locnet;



// TODO remove commented values if confirmed to be unused
enum Status {
  // General codes that can be returned to any message.
  STATUS_OK = 0;                                   // The operation completed successfully.

  ERROR_PROTOCOL_VIOLATION = 1;                    // The incoming request does not follow the protocol.
  ERROR_UNSUPPORTED = 2;                           // The peer does not support the request. This is returned when a peer sends a message with an unsupported protocol version.
//  ERROR_BANNED = 3;                                // The peer will not process the request bacause the requestor is on the blacklist. Information about the blacklist entry expiration is provided in 'Response.timestamp'.
//  ERROR_BUSY = 4;                                  // The peer will not process the request because it is too busy. The requestor can try later.

  ERROR_UNAUTHORIZED = 5;                          // Within conversation, some server roles require authorization of the peer before certain requests are allowed.
                                                   // For example, the clCustomer role requires clients to authorize themselves before certain requests can be sent.
                                                   // This means that such requests require authorization and this error code is returned if a peer sends a request without prior authorization.

  ERROR_BAD_ROLE = 6;                              // If a request is sent to a port that does not handle the specific role, this error is returned.
//  ERROR_BAD_CONVERSATION_STATUS = 7;               // The conversation status is different from what the message requires.
  ERROR_INTERNAL = 8;                              // Internal error occurred while processing the message.


  // Return codes specific to a request.
//  ERROR_QUOTA_EXCEEDED = 51;                       // The peer reached or exceeded prescribed limits.
  ERROR_INVALID_SIGNATURE = 52;                    // The signature provided be the peer does not correspond to the peer's key or the message being signed.
//  ERROR_NOT_FOUND = 53;                            // A referenced object was not found.
  ERROR_INVALID_VALUE = 54;                        // One of the values provided is invalid.
//  ERROR_ALREADY_EXISTS = 55;                       // An object with the same identifier already exists.
//  ERROR_NOT_AVAILABLE = 56;                        // A request object is not available.
//  ERROR_REJECTED = 57;                             // A third party rejected the requested action.
//  ERROR_UNINITIALIZED = 58;                        // The requested object can not be obtained, queried or used as it is not initialized.
}



// This is complete message as it goes over the wire. It includes the 32-bit header with message length.
//
// There is a 1 byte prefix because of Google Protobuf protocol, so the actual binary data for a message
// with body size 4660 bytes would be:
//
//
//   0D 34 12 00 00
//
// where 0x0D means type 'fixed32' (which value is 5) + index of 'header', which is 1 << 3,
// this is followed be the 4 byte sequence 34 12 00 00, which is little endian of 0x00001234, which is 4660 decimal.
// Thus the total number of bytes sent over the wire for this message would be 4665 bytes.
//
message MessageWithHeader {
  fixed32 header = 1;                              // Message length (without the size of the header) as a little-endian 32-bit unsigned integer.
  Message body = 2;                                // Message itself.
}



// Format of a single message.
message Message {
  uint32 id = 1;                                   // Requestor defined message ID that the requestee has to return in the response. 
                                                   // Requestor is responsible for using different ID for every unprocessed message.
                                                   // If at any point there exist two open requests (i.e. without a response) with the same ID, it is a violation of the protocol and the behavior is undefined.

  oneof MessageType {                              // Message can be either:
    Request request = 2;
    Response response = 3;
  }
}


message Request {
  bytes version = 1;                               // VersionType. Protocol version specification.
  oneof RequestType {
    // TODO is this construct OK with separate interfaces divided into different messages?
    LocalServiceRequest localService = 2;
    RemoteNodeRequest remoteNode = 3;
    ClientRequest client = 4;
  }
}


// To every request there is a response.
message Response {
  Status status = 1;                               // Return code.
  sint64 timestamp = 2;                            // TimestampType. If status is ERROR_BANNED, this field specifies when the blacklist entry expires.
  string details = 3;                              // In case of an error, this field may contain additional details.

  oneof ResponseType {                         // See 'Request.ConversationType'.
    LocalServiceResponse localService = 4;
    RemoteNodeResponse remoteNode = 5;
    ClientResponse client = 6;
  }
}



message LocalServiceRequest {
  oneof LocalServiceRequestType {
    RegisterServiceRequest registerService = 1;
    DeregisterServiceRequest deregisterService = 2;
    GetNeighbourNodesByDistanceRequest getNeighbours = 3;
  }
}

message LocalServiceResponse {
  oneof LocalServiceResponseType {
    RegisterServiceResponse registerService = 1;
    DeregisterServiceResponse deregisterService = 2;
    GetNeighbourNodesByDistanceResponse getNeighbours = 3;
  }
}

enum ServiceType
{
  // TODO are low level "networks" directly reachable by clients?
  //      If so, should be included here
  Token       = 0;
  Profile     = 1;
  Proximity   = 2;
  Relay       = 3;
  Reputation  = 4;
  Minting     = 5;
};


message NodeProfile
{
  // TODO do we also need a public key here or will it anyway be checked via the DHT?
  bytes  nodeId = 1;
  repeated Contact contacts = 2;
};


message Contact {
  oneof ContactType {
    Ipv4Address ipv4 = 1;
    Ipv6Address ipv6 = 2;
  }
}

message Ipv4Address {
  string host = 1;
  uint32 port = 2;
}

message Ipv6Address {
  string host = 1;
  uint32 port = 2;
}



message RegisterServiceRequest {
  ServiceType serviceType = 1;
  NodeProfile nodeProfile = 2;
}

message RegisterServiceResponse {
}

message DeregisterServiceRequest {
  // TODO do we enable multiple services of the same type on a single host?
  ServiceType serviceType = 1;
}

message DeregisterServiceResponse {
}

message GetNeighbourNodesByDistanceRequest {
}

message GpsLocation {
  uint32 latitude = 1;
  uint32 longitude = 2;
}

message NodeInfo {
  NodeProfile profile = 1;
  GpsLocation location = 2;
}

message GetNeighbourNodesByDistanceResponse {
  repeated NodeInfo nodeInfo = 1;
}

message RemoteNodeRequest {
  oneof RemoteNodeRequestType {
    // TODO is this construct with same signatures OK or should we merge the 4 messages into 1?
    BuildNetworkRequest acceptColleague = 1;
    BuildNetworkRequest renewColleague = 2;
    BuildNetworkRequest acceptNeighbour = 3;
    BuildNetworkRequest renewNeighbour = 4;
    GetColleagueNodeCountRequest getColleagueNodeCount = 5;
    GetRandomNodesRequest getRandomNodes = 6;
    GetClosestNodesByDistanceRequest getClosestNodes = 7;
  }
}

message RemoteNodeResponse {
  oneof RemoteNodeResponseType {
    BuildNetworkResponse acceptColleague = 1;
    BuildNetworkResponse renewColleague = 2;
    BuildNetworkResponse acceptNeighbour = 3;
    BuildNetworkResponse renewNeighbour = 4;
    GetColleagueNodeCountResponse getColleagueNodeCount = 5;
    GetRandomNodesResponse getRandomNodes = 6;
    GetClosestNodesByDistanceResponse getClosestNodes = 7;
  }
}


message BuildNetworkRequest {
  NodeInfo nodeInfo = 1;
}

message BuildNetworkResponse {
  bool accepted = 1;
}

message GetColleagueNodeCountRequest {
}

message GetColleagueNodeCountResponse {
  uint32 nodeCount = 1;
}

message GetRandomNodesRequest {
  uint32 maxNodeCount = 1;
  bool includeNeighbours = 2;
}

message GetRandomNodesResponse {
  repeated NodeInfo nodes = 1;
}

message GetClosestNodesByDistanceRequest {
  GpsLocation location = 1;
  float maxRadiusKm = 2;
  uint32 maxNodeCount = 3;
  bool includeNeighbours = 4;
}

message GetClosestNodesByDistanceResponse {
  repeated NodeInfo nodes = 1;
}



message ClientRequest {
  oneof ClientRequestType {
    GetServicesRequest getServices = 1;
    GetNeighbourNodesByDistanceRequest getNeighbourNodes = 2;
    GetClosestNodesByDistanceRequest getClosestNodes = 3;
  }
}

message ClientResponse {
  oneof ClientResponseType {
    GetServicesResponse getServices = 1;
    GetNeighbourNodesByDistanceResponse getNeighbourNodes = 2;
    GetClosestNodesByDistanceResponse getClosestNodes = 3;
  }
}

message GetServicesRequest {
}

message GetServicesResponse {
  repeated NodeProfile services = 1;
}

