// Definition of IoP Location Based Network protocol.
// We strictly use only features that are binary compatible in ProtoBuf v2 and v3.
// We use no v2 or v3 specific features.

syntax = "proto3";

package iop.locnet;



// TODO probably status codes should be shared between network protocols
//      if not then remove commented values when they are confirmed to be unused
enum Status {
  // General codes that can be returned to any message.
  STATUS_OK = 0;                                   // The operation completed successfully.

  ERROR_PROTOCOL_VIOLATION = 1;                    // The incoming request does not follow the protocol.
  ERROR_UNSUPPORTED = 2;                           // The peer does not support the request. This is returned when a peer sends a message with an unsupported protocol version.
  ERROR_INTERNAL = 8;                              // Internal error occurred while processing the message.

  ERROR_INVALID_VALUE = 54;                        // One of the values provided is invalid.
}



// This is complete message as it goes over the wire. It includes the 32-bit header with message length.
//
// There is a 1 byte prefix because of Google Protobuf protocol, so the actual binary data for a message
// with body size 4660 bytes would be:
//
//
//   0D 34 12 00 00
//
// where 0x0D means type 'fixed32' (which value is 5) + index of 'header', which is 1 << 3,
// this is followed be the 4 byte sequence 34 12 00 00, which is little endian of 0x00001234, which is 4660 decimal.
// Thus the total number of bytes sent over the wire for this message would be 4665 bytes.
//
message MessageWithHeader {
  fixed32 header = 1;                              // Message length (without the size of the header) as a little-endian 32-bit unsigned integer.
  Message body = 2;                                // Message itself.
}



// Format of a single message.
message Message {
  uint32 id = 1;                                   // Requestor defined message ID that the requestee has to return in the response. 
                                                   // Requestor is responsible for using different ID for every unprocessed message.
                                                   // If at any point there exist two open requests (i.e. without a response) with the same ID, it is a violation of the protocol and the behavior is undefined.

  oneof MessageType {                              // Message can be either:
    Request request = 2;
    Response response = 3;
  }
}


message Request {
  bytes version = 1;                               // VersionType. Protocol version specification.
  oneof RequestType {
    LocalServiceRequest localService = 2;
    RemoteNodeRequest remoteNode = 3;
    ClientRequest client = 4;
  }
}


// To every request there is a response.
message Response {
  Status status = 1;                               // Return code.
  sint64 timestamp = 2;                            // TimestampType. If status is ERROR_BANNED, this field specifies when the blacklist entry expires.
  string details = 3;                              // In case of an error, this field may contain additional details.

  oneof ResponseType {                         // See 'Request.ConversationType'.
    LocalServiceResponse localService = 4;
    RemoteNodeResponse remoteNode = 5;
    ClientResponse client = 6;
  }
}



message LocalServiceRequest {
  oneof LocalServiceRequestType {
    RegisterServiceRequest registerService = 1;
    DeregisterServiceRequest deregisterService = 2;
    GetNeighbourNodesByDistanceLocalRequest getNeighbourNodes = 3;

    NeighbourhoodChangedNotificationRequest neighbourhoodChanged = 4;
  }
}

message LocalServiceResponse {
  oneof LocalServiceResponseType {
    RegisterServiceResponse registerService = 1;
    DeregisterServiceResponse deregisterService = 2;
    GetNeighbourNodesByDistanceResponse getNeighbourNodes = 3;

    NeighbourhoodChangedNotificationResponse neighbourhoodUpdated = 4;
  }
}

enum ServiceType
{
// Low level networks
  Unstructured = 0;
  Content      = 1;
  Latency      = 2;
  Location     = 3;

// High level servers
  Token       = 10;
  Profile     = 11;
  Proximity   = 12;
  Relay       = 13;
  Reputation  = 14;
  Minting     = 15;
};


message NodeProfile
{
  // TODO do we also need a public key here or will it anyway be checked via the DHT?
  bytes nodeId = 1;
  Contact contact = 2;
};


message Contact {
  oneof ContactType {
    IpAddress ipv4 = 1;
    IpAddress ipv6 = 2;
  }
}

message IpAddress {
  bytes  host = 1;
  uint32 port = 2;
}


message RegisterServiceRequest {
  ServiceType serviceType = 1;
  NodeProfile nodeProfile = 2;
}

message RegisterServiceResponse {
}

message DeregisterServiceRequest {
  ServiceType serviceType = 1;
}

message DeregisterServiceResponse {
}

message GetNeighbourNodesByDistanceLocalRequest {
  bool keepAliveAndSendUpdates = 1;
}

message GpsLocation {
  sfixed32 latitude = 1;
  sfixed32 longitude = 2;
}

message NodeInfo {
  NodeProfile profile = 1;
  GpsLocation location = 2;
}

message GetNeighbourNodesByDistanceResponse {
  repeated NodeInfo nodes = 1;
}

message NeighbourhoodChange {
  oneof ChangeType {
    NodeInfo addedNodeInfo = 1;
    NodeInfo updatedNodeInfo = 2;
    bytes removedNodeId = 3;
  }; 
}

message NeighbourhoodChangedNotificationRequest {
  repeated NeighbourhoodChange changes = 1;
}

message NeighbourhoodChangedNotificationResponse {
}


message RemoteNodeRequest {
  oneof RemoteNodeRequestType {
    BuildNetworkRequest acceptColleague = 1;
    BuildNetworkRequest renewColleague = 2;
    BuildNetworkRequest acceptNeighbour = 3;
    BuildNetworkRequest renewNeighbour = 4;
    GetNodeCountRequest getNodeCount = 5;
    GetRandomNodesRequest getRandomNodes = 6;
    GetClosestNodesByDistanceRequest getClosestNodes = 7;
  }
}

message RemoteNodeResponse {
  oneof RemoteNodeResponseType {
    BuildNetworkResponse acceptColleague = 1;
    BuildNetworkResponse renewColleague = 2;
    BuildNetworkResponse acceptNeighbour = 3;
    BuildNetworkResponse renewNeighbour = 4;
    GetNodeCountResponse getNodeCount = 5;
    GetRandomNodesResponse getRandomNodes = 6;
    GetClosestNodesByDistanceResponse getClosestNodes = 7;
  }
}


message BuildNetworkRequest {
  NodeInfo requestorNodeInfo = 1;
}

message BuildNetworkResponse {
  bool accepted = 1;
  NodeInfo acceptorNodeInfo = 2;
}

message GetNodeCountRequest {
}

message GetNodeCountResponse {
  uint32 nodeCount = 1;
}

message GetRandomNodesRequest {
  uint32 maxNodeCount = 1;
  bool includeNeighbours = 2;
}

message GetRandomNodesResponse {
  repeated NodeInfo nodes = 1;
}

message GetClosestNodesByDistanceRequest {
  GpsLocation location = 1;
  float maxRadiusKm = 2;
  uint32 maxNodeCount = 3;
  bool includeNeighbours = 4;
}

message GetClosestNodesByDistanceResponse {
  repeated NodeInfo nodes = 1;
}



message ClientRequest {
  oneof ClientRequestType {
    GetServicesRequest getServices = 1;
    GetNeighbourNodesByDistanceClientRequest getNeighbourNodes = 2;
    GetClosestNodesByDistanceRequest getClosestNodes = 3;
  }
}

message ClientResponse {
  oneof ClientResponseType {
    GetServicesResponse getServices = 1;
    GetNeighbourNodesByDistanceResponse getNeighbourNodes = 2;
    GetClosestNodesByDistanceResponse getClosestNodes = 3;
  }
}

message GetServicesRequest {
}

message ServiceProfile {
  ServiceType serviceType = 1;
  NodeProfile profile = 2;
}

message GetServicesResponse {
  repeated ServiceProfile services = 1;
}

message GetNeighbourNodesByDistanceClientRequest {
}

