//
// Definition of IoP Profile Server protocol.
// We strictly use only features that are binary compatible in ProtoBuf v2 and v3.
// We use no v2 or v3 specific features.
//
// An integral part of the protocol are the protocol tests:
// https://github.com/Internet-of-People/message-protocol/blob/master/TESTS.md
// The tests must comply with this protocol file, but may add some additional requirements
// or constraints on the behavior of a compatible software.
//
//
//
// * Roles *
// ~~~~~~~~~
//
// Each profile server has several roles. Each message belongs to one or more roles.
// If a request is sent to a port that does not handle the specific role, 
// ERROR_BAD_ROLE is returned.
//
// Existing roles and their short names are:
//
//   * Primary Interface = "primary"
//   * Neighbors Interface = "srNeighbor"
//   * Customer Clients Interface = "clCustomer"
//   * Non Customer Clients Interface = "clNonCustomer"
//   * Application Service Interface = "clAppService"
//
//
// We mark each request with a list of roles that can serve that request.
// If all roles can serve the request, we use "any" marker.
//
//
//
//
// * Reused Types *
// ~~~~~~~~~~~~~~~~
//
// Protobuf does not allow us to specify some types completely, this is why we 
// define some of the types we reuse a lot here.
//
//  * VersionType - Protocol or structure version specification encoded in 3 bytes - see http://semver.org/. 
//                  First byte is MAJOR, second byte is MINOR, third byte is PATCH. Note that version 0.0.0 
//                  is always considered invalid and should produce protocol violation error.
//
//  * TimestampType - 64-bit signed timestamp that is similar to Unix timestamp, except that it counts 
//                    milliseconds since the epoch start instead of seconds and is 64-bit instead of 32-bit.
//
//  * TokenAmountType - IoP token amounts are represented by 64-bit unsigned integers similarly how bitcoins
//                      are represented in the Bitcoin protocol. Each IoP token is divisible to 100,000,000 
//                      smallest units and all amounts in the protocol are in these smallest units. Thus 
//                      a numberical value of 100,000,000 within a TokenAmountType field represents 1 full 
//                      IoP token.
//
//  * WildcardType - UTF-8 string with optional '*' wildcard character prefix or suffix, which represents any substring.
//                   Matching is case insensitive. The format of this string is thus one of the following formats:
//
//                    * "data*" - starts with "data"
//                    * "*data" - ends with "data"
//                    * "*data*" - contains "data"
//                    * "data" - is exactly "data"
//
//                   Any additional '*' characters are interpreted as parts of the value.
//
//  * RegexType - Case-sensitive UTF-8 regular expression string supporting following rules:
//
//                 * "\xnn" - Matches a single byte character by using hexadecimal representation (nn consists 
//                            of exactly two digits).
//                 * "\unnnn" - Matches a Unicode character by using hexadecimal representation (exactly four digits, 
//                              as represented by nnnn).
//                 * "\.", "\*", "\-", "\+", "\[", "\]", "\\", "\?", "\^", "\|", "\(", "\)", "\{", "\}" - Escapes special character.
//                 * "[characterGroup]" - Matches any single character in characterGroup.
//                 * "[^characterGroup]" - Matches any single character that is not in characterGroup.
//                 * "[first-last]" - Matches any single character in the range from first to last. 
//                 * "." - Matches any single character.
//                 * "\w" - Matches any word character.
//                 * "\W" - Matches any non-word character.
//                 * "\s" - Matches any white-space character.
//                 * "\S" - Matches any non-white-space character.
//                 * "\d" - Matches any decimal digit.
//                 * "\D" - Matches any character other than a decimal digit.
//                 * "^" - The match must start at the beginning of the string. 
//                 * "$" - The match must occur at the end of the string.
//                 * "*" - Matches the previous element zero or more times.
//                 * "+" - Matches the previous element one or more times.
//                 * "?" - Matches the previous element zero or one time.
//                 * "{n}" - Matches the previous element exactly n times.
//                 * "{n,}" - Matches the previous element at least n times.
//                 * "{n,m}" - Matches the previous element at least n times, but no more than m times. 
//                 * "|" - Matches any one element separated by the vertical bar '|' character.
//                 * "(subexpression)" - Captures the matched subexpression.
//
//               No other rules or special characters are allowed to appear in the regular expression of this type.
//
// * LocationType - Represents GPS location latitude or longitude. It is a signed integer that stores decimal(9,6)
//                  type, which means that a floating point value of the latitude or longitude is multiplied
//                  by 1,000,000 and converted to the integer (cutting of any digits right of the decimal point without 
//                  rounding). To get the floating point value back, simply divide the integer value by 1,000,000.
//                  For latitudes, valid values are in range [-90,000,000;90,000,000], for longitudes the range is 
//                  [-179,999,999;180,000,000]. A special constant NO_LOCATION = 0x7FFFFFFF is reserved for no location.
//
//
//
// * Conversations *
// ~~~~~~~~~~~~~~~~~
//
// Each message in the protocol can either be a separated message called "Single Message" or it can be a part 
// of a longer conversation. Response to a Single Message is a "Single Response". These request and response 
// exist without any context. All the information needed to process the request has to be included in the message.
//
// Conversations are different. They establish a context and conversation messages can thus rely on the 
// information provided earlier in the conversation. These are the possible conversation statuses:
//
//   * NoConversation - No conversation has been started.
//
//   * ConversationStarted - There is an established conversation with the client, but no authentication 
//                           has been done.
//
//   * Verified - There is an established conversation with the non-customer client and the verification process 
//                has already been completed. Note that, unlike Authenticated status, there can be multiple 
//                parallel connections in this status for a single identity.
//
//   * Authenticated - There is an established conversation with the customer client and the authentication process 
//                     has already been completed. Note that only one connection per identity can be in this
//                     status. If the identity establishes a second connection and performs a check-in process 
//                     the first connection has to be disconnected.
//
//
// For each conversation messages we define in which state must the conversation be. If the conversation 
// message is sent in a different state, it is an error. Note that if the required status is Verified
// and the current status is Authenticated, the requirement is satisfied.
//
//   * ERROR_BAD_CONVERSATION_STATUS - If the required status is NoConversation or ConversationStarted, 
//                                     but the current status is different.
//
//   * ERROR_UNAUTHORIZED - If the required status is Authenticated, but the current status is different; 
//                          OR the required status is Verified and the current status is neither Verified 
//                          nor Authenticated.
// 
//


syntax = "proto3";


package iop.profileserver;

// Return codes to requests that inform requestor about whether the operation completed successfully or which error occurred.
enum Status {
  // General codes that can be returned to any message.
  STATUS_OK = 0;                                   // The operation completed successfully.

  ERROR_PROTOCOL_VIOLATION = 1;                    // The incoming request does not follow the protocol.
  ERROR_UNSUPPORTED = 2;                           // The peer does not support the request. This is returned when a peer sends a message with an unsupported protocol version.
  ERROR_BANNED = 3;                                // The peer will not process the request bacause the requestor is on the blacklist. Information about the blacklist entry expiration is provided in 'Response.timestamp'.
  ERROR_BUSY = 4;                                  // The peer will not process the request because it is too busy. The requestor can try later.

  ERROR_UNAUTHORIZED = 5;                          // Within conversation, some server roles require authorization of the peer before certain requests are allowed.
                                                   // For example, the clCustomer role requires clients to authorize themselves before certain requests can be sent.
                                                   // This means that such requests require authorization and this error code is returned if a peer sends a request without prior authorization.

  ERROR_BAD_ROLE = 6;                              // If a request is sent to a port that does not handle the specific role, this error is returned.
  ERROR_BAD_CONVERSATION_STATUS = 7;               // The conversation status is different from what the message requires.
  ERROR_INTERNAL = 8;                              // Internal error occurred while processing the message.


  // Return codes specific to a request.
  ERROR_QUOTA_EXCEEDED = 51;                       // The peer reached or exceeded prescribed limits.
  ERROR_INVALID_SIGNATURE = 52;                    // The signature provided be the peer does not correspond to the peer's key or the message being signed.
  ERROR_NOT_FOUND = 53;                            // A referenced object was not found.
  ERROR_INVALID_VALUE = 54;                        // One of the values provided is invalid.
  ERROR_ALREADY_EXISTS = 55;                       // An object with the same identifier already exists.
  ERROR_NOT_AVAILABLE = 56;                        // A request object is not available.
  ERROR_REJECTED = 57;                             // A third party rejected the requested action.
  ERROR_UNINITIALIZED = 58;                        // The requested object can not be obtained, queried or used as it is not initialized.
}


// This is complete message as it goes over the wire. It includes the 32-bit header with message length.
//
// There is a 1 byte prefix because of Google Protobuf protocol, so the actual binary data for a message
// with body size 4660 bytes would be:
//
//
//   0D 34 12 00 00
//
// where 0x0D means type 'fixed32' (which value is 5) + index of 'header', which is 1 << 3,
// this is followed be the 4 byte sequence 34 12 00 00, which is little endian of 0x00001234, which is 4,660 decimal.
// Thus the total number of bytes sent over the wire for this message would be 4,665 bytes.
//
message MessageWithHeader {
  fixed32 header = 1;                              // Message length (without the size of the header) as a little-endian 32-bit unsigned integer.
  Message body = 2;                                // Message itself.
}



// Format of a single message.
message Message {
  uint32 id = 1;                                   // Requestor defined message ID that the requestee has to return in the response. 
                                                   // Requestor is responsible for using different ID for every unprocessed message.
                                                   // If at any point there exist two open requests (i.e. without a response) with the same ID, it is a violation of the protocol and the behavior is undefined.

  oneof MessageType {                              // Message can be either:
    Request request = 2;                           //  * a new request,
    Response response = 3;                         //  * or response to a previous request.
  }
}


// Every conversation starts with a request of a requestor.
// This can be either a single request, for which it is expected to receive a single response,
// or this can be part of a longer conversation between the peers.
message Request {
  oneof ConversationType {                         // Either a request lives on its own without any session or context, or it is a part of a conversation.
    SingleRequest singleRequest = 1;               // Single requests are requests that are supposed to be sent without further context.
    ConversationRequest conversationRequest = 2;   // Conversation requests form a session with a context that has to be maintained by peers in order to correctly interpret the messages.
  }  
}


// To every request there is a response.
message Response {
  Status status = 1;                               // Return code.
  sint64 timestamp = 2;                            // TimestampType. If status is ERROR_BANNED, this field specifies when the blacklist entry expires.
  string details = 3;                              // In case of an error, this field may contain additional details.

  oneof ConversationType {                         // See 'Request.ConversationType'.
    SingleResponse singleResponse = 8;             // Responses to single requests are sent as single responses,
    ConversationResponse conversationResponse = 9; // responses to conversation requests are sent as conversation responses.
  }
}


// Single requests live on their own without any session or context. 
// It is always possible to process a single request without any additional informaiton.
message SingleRequest {
  bytes version = 1;                               // VersionType. Protocol version specification.
  oneof RequestType {                              // There are many different standalone requests that can be sent by the requestor.
    PingRequest ping = 2;
    ListRolesRequest listRoles = 3;
    ListHostingPlansRequest listHostingPlans = 4;
    GetIdentityInformationRequest getIdentityInformation = 5;
    ApplicationServiceSendMessageRequest applicationServiceSendMessage = 6;
    ApplicationServiceReceiveMessageNotificationRequest applicationServiceReceiveMessageNotification = 7;
    ProfileStatsRequest profileStats = 8;
    GetIdentityRelationshipsInformationRequest getIdentityRelationshipsInformation = 9;
  }
}



// Single response is a reaction to single request. 
message SingleResponse {
  bytes version = 1;                               // VersionType. See 'SingleRequest.version'. The version of response can be different than the version in request, 
                                                   // if the requestee does not support the version by the requestor.
                                                   // If the requestor is able to process the message using the version of protocol, the version value is the same as in the request.

  oneof ResponseType {                             // See 'SingleRequest.RequestType'. Each request has its corresponding response.
    PingResponse ping = 2;
    ListRolesResponse listRoles = 3;
    ListHostingPlansResponse listHostingPlans = 4;
    GetIdentityInformationResponse getIdentityInformation = 5;
    ApplicationServiceSendMessageResponse applicationServiceSendMessage = 6;
    ApplicationServiceReceiveMessageNotificationResponse applicationServiceReceiveMessageNotification = 7;
    ProfileStatsResponse profileStats = 8;
    GetIdentityRelationshipsInformationResponse getIdentityRelationshipsInformation = 9;
  }
}



// Conversation requests live in a session with a context that is important for the interpretation of the requests.
// Unlike single requests, the order of messages is very important as each message may change the session context.
message ConversationRequest {
  bytes signature = 1;                             // Optional (request specific) signature that signs the Protobuf binary form of the included request body or its part.

  oneof RequestType {                              // There are many different requests that can be sent in the conversation.
    // Request body.
    StartConversationRequest start = 2;
    RegisterHostingRequest registerHosting = 3;
    CheckInRequest checkIn = 4;
    VerifyIdentityRequest verifyIdentity = 5;
    UpdateProfileRequest updateProfile = 6;
    CancelHostingAgreementRequest cancelHostingAgreement = 7;
    ApplicationServiceAddRequest applicationServiceAdd = 8;
    ApplicationServiceRemoveRequest applicationServiceRemove = 9;
    CallIdentityApplicationServiceRequest callIdentityApplicationService = 10;
    IncomingCallNotificationRequest incomingCallNotification = 11;
    ProfileSearchRequest profileSearch = 12;
    ProfileSearchPartRequest profileSearchPart = 13;
    AddRelatedIdentityRequest addRelatedIdentity = 14;
    RemoveRelatedIdentityRequest removeRelatedIdentity = 15;
    StartNeighborhoodInitializationRequest startNeighborhoodInitialization = 16;
    FinishNeighborhoodInitializationRequest finishNeighborhoodInitialization = 17;
    NeighborhoodSharedProfileUpdateRequest neighborhoodSharedProfileUpdate = 18;
    StopNeighborhoodUpdatesRequest stopNeighborhoodUpdates = 19;
    CanStoreDataRequest canStoreData = 20;
    CanPublishIpnsRecordRequest canPublishIpnsRecord = 21;
  }
}


// Conversation response is a reaction to a conversation request.
message ConversationResponse {
  bytes signature = 1;                             // Optional (response specific) signature that signs the Protobuf binary form of the included response body or its part.

  oneof ResponseType {                             // There are many different requests that can be sent in the conversation.
    // Response body.
    StartConversationResponse start = 2;
    RegisterHostingResponse registerHosting = 3;
    CheckInResponse checkIn = 4;
    VerifyIdentityResponse verifyIdentity = 5;
    UpdateProfileResponse updateProfile = 6;
    CancelHostingAgreementResponse cancelHostingAgreement = 7;
    ApplicationServiceAddResponse applicationServiceAdd = 8;
    ApplicationServiceRemoveResponse applicationServiceRemove = 9;
    CallIdentityApplicationServiceResponse callIdentityApplicationService = 10;
    IncomingCallNotificationResponse incomingCallNotification = 11;
    ProfileSearchResponse profileSearch = 12;
    ProfileSearchPartResponse profileSearchPart = 13;
    AddRelatedIdentityResponse addRelatedIdentity = 14;
    RemoveRelatedIdentityResponse removeRelatedIdentity = 15;
    StartNeighborhoodInitializationResponse startNeighborhoodInitialization = 16;
    FinishNeighborhoodInitializationResponse finishNeighborhoodInitialization = 17;
    NeighborhoodSharedProfileUpdateResponse neighborhoodSharedProfileUpdate = 18;
    StopNeighborhoodUpdatesResponse stopNeighborhoodUpdates = 19;
    CanStoreDataResponse canStoreData = 20;
    CanPublishIpnsRecordResponse canPublishIpnsRecord = 21;
  }
}





//
// An administrative message to test whether the peer is there and responds to requests.
//
// Each identity client is required to send a message not more than 60 seconds after the connection 
// was established, or after the last message has been send over the connection. For server clients,
// this limit is 300 seconds. Clients should use PingRequest if they have nothing else to send
// and want to keep the connection open.
//
//
// Roles: any
//
message PingRequest {
  bytes payload = 1;                               // At most 64 bytes of arbitrary data that will be sent back by the peer.
}

// A response to PingRequest to reassure the connection works fine.
message PingResponse {
  bytes payload = 1;                               // See 'PingRequest.payload'.
  sint64 clock = 2;                                // 64-bit signed Unix UTC time on the requestee's machine.
}



//
// Request server to provide a mapping between ports and roles.
//
// Roles: primary
//
message ListRolesRequest {
}

// A response to ListRolesRequest with a list of all open ports and associated roles.
message ListRolesResponse {
  repeated ServerRole roles = 1;                   // List of server roles.
}


// Known server roles.
enum ServerRoleType {
  PRIMARY = 0;                                     // Primary Interface server role.
  SR_NEIGHBOR = 2;                                 // Neighbors Interface server role.
  CL_NON_CUSTOMER = 6;                             // Customer Clients Interface server role.
  CL_CUSTOMER = 7;                                 // Non Customer Clients Interface server role.
  CL_APP_SERVICE = 9;                              // Application Service Interface server role.
}


// Description of a single server role.
message ServerRole {
  ServerRoleType role = 1;                         // Server role type.
  uint32 port = 2;                                 // On which port is this server role provided.
  bool isTcp = 3;                                  // true if the port is TCP port, false means UDP.
  bool isTls = 4;                                  // true if the port is TLS encrypted, false otherwise.
}









//
// Hosting Registration Request and Check-in - Identity registration and first login full sequence
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// A) Provided that the profile server's clNonCustomer port is different from clCustomer port, the sequence is as follows:
//   1) Identity connects to the server on its primary port and gets information about its roles to ports mapping.
//   2) Identity connects to the clNonCustomer port and sends a hosting registration request.
//   3) Identity connects to the clCustomer port and performs a check-in.
//
// B) If clNonCustomer port is equal to clCustomer port, the sequence is as follows:
//   1) Identity connects to the server on its primary port and gets information about its roles to ports mapping.
//   2) Identity connects to the clNonCustomer+clCustomer port and sends a hosting registration request.
//   3) Identity performs a check-in over the connection from 2).
//
//
//
// Sequence diagram A.1) - this is called "Port Discovery Process":
//
// [ Identity ]                                                       [ Server:primary ] 
//      |                                                                     |
//      |                                                                     | status = NoConversation
//      |                                                                     |
//      |  ListRolesRequest                                                   |
//      *-------------------------------------------------------------------> *
//      |                                                                     |
//      |                                                                     |
//      |                                                                     |
//      |                                                  ListRolesResponse  |
//      * <-------------------------------------------------------------------*
//      |                                                                     |
//      |                                                                     |
//
//
// Now the identity knows the list of server's roles and on which ports they are served.
//
//
//
// Sequence diagram A.2):
//
// [ Identity ]                                                       [ Server:clNonCustomer ] 
//      |                                                                     |
//      |                                                                     | status = NoConversation
//      |                                                                     |
//      |  StartConversationRequest                                           |
//      *-------------------------------------------------------------------> *
//      |                                                                     |
//      |                                                                     | status := ConversationStarted
//      |                                                                     |
//      |                                          StartConversationResponse  |
//      * <-------------------------------------------------------------------*
//      |                                                                     |
//      |                                                                     |
//      |                                                                     |
//      |  RegisterHostingRequest                                             |
//      *-------------------------------------------------------------------> *
//      |                                                                     |
//      |                                                                     |
//      |                                                                     |
//      |                                            RegisterHostingResponse  |
//      * <-------------------------------------------------------------------*
//      |                                                                     |
//      |                                                                     |
//
// Now the identity is registered and the server is hosting its profile, it can proceed with the check-in process.
//
//
//
// Sequence diagram A.3) - this is called "Check-in Process":
//
// [ Identity ]                                                       [ Server:clCustomer ] 
//      |                                                                     |
//      |                                                                     | status = NoConversation
//      |                                                                     |
//      |  StartConversationRequest                                           |
//      *-------------------------------------------------------------------> *
//      |  <clientChallenge>                                                  |
//      |                                                                     | status := ConversationStarted
//      |                                                                     |
//      |                                                                     |
//      |                                          StartConversationResponse  |
//      *<--------------------------------------------------------------------*
//      |                                <challenge, signed clientChallenge>  |
//      |                                                                     |
//      |                                                                     |
//      |  CheckInRequest                                                     |
//      *-------------------------------------------------------------------> *
//      |  <signed challenge>                                                 |
//      |                                                                     | status := Authenticated
//      |                                                                     |
//      |                                                    CheckInResponse  |
//      * <-------------------------------------------------------------------*
//      |                                                                     |
//      |                                                                     |
//
//
//
// Sequence diagram B.1) is same as A.1)
// Sequence diagram B.2) + B.3):
//
// [ Identity ]                                                       [ Server:clNonCustomer+clCustomer ] 
//      |                                                                     |
//      |                                                                     | status = NoConversation
//      |                                                                     |
//      |  StartConversationRequest                                           |
//      *-------------------------------------------------------------------> *
//      |  <clientChallenge>                                                  |
//      |                                                                     | status := ConversationStarted
//      |                                                                     |
//      |                                          StartConversationResponse  |
//      * <-------------------------------------------------------------------*
//      |                                <challenge, signed clientChallenge>  |
//      |                                                                     |
//      |                                                                     |
//      |  RegisterHostingRequest                                             |
//      *-------------------------------------------------------------------> *
//      |                                                                     |
//      |                                                                     |
//      |                                                                     |
//      |                                            RegisterHostingResponse  |
//      * <-------------------------------------------------------------------*
//      |                                                                     |
//      |                                                                     |
//      |                                                                     |
//      |  CheckInRequest                                                     |
//      *-------------------------------------------------------------------> *
//      |  <signed challenge>                                                 |
//      |                                                                     | status := Authenticated
//      |                                                                     |
//      |                                                    CheckInResponse  |
//      * <-------------------------------------------------------------------*
//      |                                                                     |
//      |                                                                     |
//
//
// 
//
// Identity Verification Process
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Similarly to how a profile server's customer checks-in in order to get to the Authenticated 
// conversation status, a remote identity (not hosted by the profile server) can verify its public key by 
// signing a challenge provided by the server in order to get to the Verified conversation status.
//
//
// Sequence diagram for so called "Identity Verification Process":
//
// [ Identity ]                                                       [ Server:clNonCustomer ] 
//      |                                                                     |
//      |                                                                     | status = NoConversation
//      |                                                                     |
//      |  StartConversationRequest                                           |
//      *-------------------------------------------------------------------> *
//      |  <clientChallenge>                                                  |
//      |                                                                     | status := ConversationStarted
//      |                                                                     |
//      |                                                                     |
//      |                                          StartConversationResponse  |
//      * <-------------------------------------------------------------------*
//      |                                <challenge, signed clientChallenge>  |
//      |                                                                     |
//      |                                                                     |
//      |  VerifyIdentityRequest                                              |
//      *-------------------------------------------------------------------> *
//      |  <signed challenge>                                                 |
//      |                                                                     | status := Authenticated
//      |                                                                     |
//      |                                             VerifyIdentityResponse  |
//      * <-------------------------------------------------------------------*
//      |                                                                     |
//      |                                                                     |


//
// A client asks server for its hosting plans that match the given criteria.
//
// Roles: clNonCustomer
//
message ListHostingPlansRequest {
  string identityType = 1;                         // A specific identity type, for which the client searches the plan.
  // Other criteria TBD.
}


//
// A response to ListHostingPlansRequest that contains a list of matching plans.
//
// Specific Error Responses: 
//   * ERROR_QUOTA_EXCEEDED - A server uses this error code in case it wants to express that it will not accept any new clients because it has no free slots.
//
message ListHostingPlansResponse {
  repeated HostingPlan plans = 1;                 // List of matching plans.
}


// Description of a hosting plan.
message HostingPlan {
  bytes planId = 1;                                // Identifier of the plan is an SHA256 hash of the HostingPlan structure in Google Protobuf v3 encoding 
                                                   // with planId initialized to a byte array of 32 zero bytes.
  bytes serverNetworkId = 2;                       // Identifier of the profile server that offers the plan.
  string identityType = 3;                         // Type of identity this plan is created for. This can include "*" as a wildcard character
                                                   // at the end of the type to support multiple types to be served with a single plan. 
                                                   // For example, the value "*" would mean that any identity type is supported,
                                                   // and the value "Taxi *" would mean that any identity type that starts with "Taxi *"
                                                   // would match this plan.
  uint64 fee = 4;                                  // TokenAmountType. Price of the plan per billing period.
  uint32 billingPeriodSeconds = 5;                 // Length of the billing period in seconds.
  repeated NameStringValuePair planParameters = 9; // List of additional service parameters that define the plan.
}

// Description of name-value structure with string values.
message NameStringValuePair {
  string name = 1;                                 // Name of the object.
  string value = 2;                                // String value.
}



//
// Every conversation starts with this request, in which the requestor sends a list of protocol versions 
// it supports and its public key that identifies it.
//
// Roles: any
//
// Conversation status: NoConversation
//
message StartConversationRequest {
  repeated bytes supportedVersions = 1;            // List of VersionType items. Ordered by requestor's preference. See 'SingleRequest.version'.
  bytes publicKey = 2;                             // Public key of the requestor. Max 128 bytes.

  bytes clientChallenge = 3;                       // 32 byte challenge data (random bytes generated by the requestor) that is used for authentication purposes.
}


//
// A response to StartConversationRequest in case the requestee found at least one protocol version that 
// both peers are willing to use. 
// 
// The 'clientChallenge' field value in raw format is signed with a signature in 'ConversationResponse.signature'.
// 
//
// After StartConversationResponse is sent, the conversation context includes version and keys of both peers.
//
// Specific Error Responses:
//   * ERROR_UNSUPPORTED - If the requestee does not support any of the requestor's versions, it replies with this error code.
//   * ERROR_INVALID_VALUE
//     * Response.details == "publicKey" - 'StartConversationRequest.publicKey' is not a valid public key value. 
//     * Response.details == "clientChallenge" - 'StartConversationRequest.clientChallenge' is not 32 byte long. 
//
message StartConversationResponse {
  bytes version = 1;                               // VersionType. The version that the requestee selected from the offered set.
  bytes publicKey = 2;                             // Public key of the requestee.

  bytes challenge = 3;                             // 32 byte challenge data (random bytes generated by the requestee) that is used for later authentication purposes.
  bytes clientChallenge = 4;                       // Copy of 'StartConversationRequest.clientChallenge' that is signed by the requestee. 
                                                   // The requestor can then verify the signature in order to check the requestee's claimed identity.
}


//
// A client asks profile server to host its profile by sending RegisterHostingRequest
// with a signed contract. The signature is provided in 'ConversationRequest.signature'.
//
// Roles: clNonCustomer
//
// Conversation status: ConversationStarted
//
message RegisterHostingRequest {
  HostingPlanContract contract = 1;                // Description of the contract that the client wants to have with the profile server.
                                                   // The 'contract.plan' has to be the exact copy of the server's offer, no field can be changed, otherwise the server will refuse it.
                                                   // The 'contract.startTime' field has to be set either to the future, or to a time that is not 
                                                   // more than 1 hour in past from the current profile server's time.
}


//
// A response to RegisterHostingRequest in case the profile server wants to accept the request.
// The response body is signed with a signature in 'ConversationResponse.signature'.
//
// Specific Error Responses:
//   * ERROR_QUOTA_EXCEEDED - A server uses this error code in case it wants to express that it will not accept any new clients because it has no free slots.
//   * ERROR_NOT_FOUND - 'HostingPlanContract.contract.planId' does not correspond to any of the server's plans, or the plan values are different from what the server offers.
//   * ERROR_INVALID_SIGNATURE - The client's signature of the contract is not valid.
//   * ERROR_ALREADY_EXISTS - The identity is hosted by the server already.
//   * ERROR_INVALID_VALUE
//     * Response.details == "contract.startTime" - 'RegisterHostingRequest.contract.startTime' is more than 1 hour in the past. 
//     * Response.details == "contract.identityPublicKey" - 'RegisterHostingRequest.contract.identityPublicKey' does not match identity's public key.
//     * Response.details == "contract.identityType" - 'RegisterHostingRequest.contract.identityType' does not match the hosting plan.
//
message RegisterHostingResponse {
  HostingPlanContract contract = 1;                // Description of the contract that the client wants to have with the server and the server accepted it.
                                                   // This has to be exactly the same contract as the profile server received in 'RegisterHostingRequest.contract'.
}


// A description of the contract between a client and a profile server.
message HostingPlanContract {
  bytes planId = 1;                                // Identifier of the profile server's hosting plan.
  bytes identityPublicKey = 2;                     // Public key of the client's identity.
  sint64 startTime = 3;                            // TimestampType. Specifies the start time of the contract.
  string identityType = 4;                         // Type of the client's identity. It has to match the 'HostingPlan.identityType' filter in the selected plan.
                                                   // For example, if 'HostingPlan.identityType' is "Taxi *" then 'identityType' can be "Taxi Driver",
                                                   // but not "Bus Driver". Also 'identityType' can not contain '*' wildcard character, so "Taxi *" is not a valid value
                                                   // for 'identityType' here even if 'HostingPlan.identityType' is "Taxi *". Max 64 bytes long.
}



// 
// A customer client announces it is online and it "logs in".
// The client has to provide a signature in 'ConversationRequest.signature'.
//
// Note that if a customer client that is authenticated already creates a second connection
// and performs the check-in process in it, the first connection has to be disconnected
// as there can not be multiple parallel connections in Authenticated state for a single identity.
//
// Roles: clCustomer
//
// Conversation status: ConversationStarted
//
message CheckInRequest {
  bytes challenge = 1;                             // The exact copy of 'StartConversationResponse.challenge' from the start of the conversation.
}

//
// A response to CheckInRequest. If no error occurs, the conversation status is upgraded to Authenticated.
//
// Specific Error Responses:
//   * ERROR_INVALID_SIGNATURE - The client's signature of the challenge is not valid.
//   * ERROR_NOT_FOUND - The identity is not a client of the profile server.
//   * ERROR_INVALID_VALUE
//     * Response.details == "challenge" - 'CheckInRequest.challenge' is not the exact copy of 'StartConversationResponse.challenge' from the start of the conversation.
//
message CheckInResponse {
}


// 
// A non-customer client verifies its public key by signing the challenge. This request is similar to CheckInRequest, 
// but it is intended for non-customer clients. The client has to provide a signature in 'ConversationRequest.signature'.
//
// Roles: clNonCustomer, srNeighbor
//
// Conversation status: ConversationStarted
//
message VerifyIdentityRequest {
  bytes challenge = 1;                             // The exact copy of 'StartConversationResponse.challenge' from the start of the conversation.
}

//
// A response to VerifyIdentityRequest. If no error occurs, the conversation status is upgraded to Verified.
//
// Specific Error Responses:
//   * ERROR_INVALID_SIGNATURE - The client's signature of the challenge is not valid.
//   * ERROR_INVALID_VALUE
//     * Response.details == "challenge" - 'VerifyIdentityRequest.challenge' is not the exact copy of 'StartConversationResponse.challenge' from the start of the conversation.
//
message VerifyIdentityResponse {
}


//
// A customer client updates its profile hosted at the profile server.
// The client must make sure that its profile is complete after processing the request.
// After sending RegisterHostingRequest, its profile is almost empty - only identity type 
// and public key are known. This means that the first call of this request 
// has to contain all required information to make the profile complete. Namely the first 
// UpdateProfileRequest has to have setVersion, setName, and setLocation set to true.
//
// The customer client is required to initialize its profile just after finishing 
// the RegisterHostingRequest. Until the initialization of the profile is made, the identity 
// is not considered as being fully initialized and can not be queried or called by other 
// identities.
//
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message UpdateProfileRequest {
  bool setVersion = 1;                             // Profile version should be updated. 'version' must contain valid data.
  bool setName = 2;                                // Profile name should be updated. 'name' must contain valid data.
  bool setImage = 3;                               // Profile image should be updated. 'image' must contain valid data.
  bool setLocation = 4;                            // Profile location should be updated. 'latitude' and 'longitude' must contain valid data.
  bool setExtraData = 5;                           // Profile extra data should be updated. 'extraData' must contain valid data.

  bytes version = 8;                               // VersionType. Version of the profile structure.
  string name = 9;                                 // Name of the profile, non-empty string, max 64 bytes long.
  bytes image = 10;                                // Profile image in PNG or JPEG format, non-empty binary data, max 20,480 bytes long, or empty binary data if the image is about to be erased.
  sfixed32 latitude = 11;                          // LocationType. GPS location latitude information.
  sfixed32 longitude = 12;                         // LocationType. GPS location longitude information.
  string extraData = 13;                           // Semicolon separated 'key=value' list, max 200 bytes long.
}


//
// A response to UpdateProfileRequest.
//
// Specific Error Responses:
//   * ERROR_NOT_FOUND - The identity is not a client of the profile server.
//   * ERROR_INVALID_VALUE
//     * Response.details == "setVersion" - 'UpdateProfileRequest.setVersion' is not set during the first request.
//     * Response.details == "setName" - 'UpdateProfileRequest.setName' is not set during the firts request.
//     * Response.details == "setLocation" - 'UpdateProfileRequest.setLocation' is not set during the firts request.
//     * Response.details == "set*" - Nothing was set to be updated.
//     * Response.details == "version" - 'UpdateProfileRequest.version' does not contain a valid version information.
//     * Response.details == "name" - 'UpdateProfileRequest.name' does not contain a valid name.
//     * Response.details == "image" - 'UpdateProfileRequest.image' does not contain a valid PNG or JPEG image.
//     * Response.details == "latitude" - 'UpdateProfileRequest.latitude' does not contain a valid latitude information.
//     * Response.details == "longitude" - 'UpdateProfileRequest.longitude' does not contain a valid longitude information.
//     * Response.details == "extraData" - 'UpdateProfileRequest.extraData' does not contain a valid extra data information.
//
message UpdateProfileResponse {
}



// 
// A customer client cancels the hosting agreement and optionally informs the profile server 
// about its new profile server location. The profile server will keep the information about 
// identity's new location for some time.
//
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message CancelHostingAgreementRequest {
  bool redirectToNewProfileServer = 1;             // true, if the client wants to inform the profile server about its new profile server location, false otherwise.
  bytes newProfileServerNetworkId = 2;             // If 'redirectToNewProfileServer' is true, an identifier of the new profile server.
}

//
// A response to CancelHostingAgreementRequest.
//
// Specific Error Responses:
//   * ERROR_NOT_FOUND - The identity is not a client of the profile server.
//   * ERROR_INVALID_VALUE
//     * Response.details == "newProfileServerNetworkId" - 'CancelHostingAgreementRequest.newProfileServerNetworkId' is not a valid profile server network identifier.
//
message CancelHostingAgreementResponse {
}



// 
// Adds (checks-in) one or more application services to the list of services that the customer 
// client supports in the current session.
//
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message ApplicationServiceAddRequest {
  repeated string serviceNames = 1;                // List of application service names to add to the list. If a service name is already 
                                                   // in the list, it will remain in the list and no error is reported.
                                                   // Each service name has to be a non-empty string, max 32 bytes long.
                                                   // Each customer client can have up to 50 application services enabled.
}

//
// A response to ApplicationServiceAddRequest.
//
//   * ERROR_QUOTA_EXCEEDED - The given set of application services can not be added because the client would have more than the maximum number of enabled services.
//   * ERROR_INVALID_VALUE
//     * Response.details == "serviceNames[i]" - 'ApplicationServiceAddRequest.serviceNames[i]' is not a valid service name, where 'i' is a zero-based index.
//
message ApplicationServiceAddResponse {
}



// 
// Removes (checks-out) a single application service from the list of services that the customer 
// client supports in the current session.
//
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message ApplicationServiceRemoveRequest {
  string serviceName = 1;                          // Name of the application service to remove. The service must be in the customer client's list.
}

//
// A response to ApplicationServiceRemoveRequest.
//
// Specific Error Responses:
//   * ERROR_NOT_FOUND - 'ApplicationServiceRemoveRequest.serviceName' does not refer to an application service that was previously added using ApplicationServiceAddRequest.
//
message ApplicationServiceRemoveResponse {
}





//
// Application Service Call - Identity A calls Identity B over application service AS1
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Prior to the service call, we assume the B (the callee) to be a customer of the profile server with 
// a fully initialized profile and that it knows the ports on which the server operates. In this example, 
// we further assume that A (the caller) is not a customer of the profile server. If A was a customer, 
// it would use the Check-in Process and communication over clCustomer port instead of communicating 
// over clNonCustomer port and doing the Identity Verification Process. We also assume that A already 
// knows which profile server hosts B's profile. Finally, we assume that B has enabled AS1 in its session 
// using ApplicationServiceAddRequest.
//
// Then A can call B over AS1 (an application service):
//
// 1) A performs Port Discovery Process to find server's clNonCustomer and clAppService ports.
// 2) A connects to clNonCustomer port and obtains information about B. A is interested 
//    to know whether B is online and whether AS1 is supported.
// 3) A initiates the call via CallIdentityApplicationServiceRequest.
// 4) The profile server checks that B is online and that AS1 is available and then it issues a callee's 
//    token and sends it to B with an information about the incoming call.
// 5) B decides to accept the call from A.
// 6) The server issues a caller's token and sends it to A together with the information that B accepted 
//    the call.
// 7,8) A and B connect to clAppService port and send the initialization message with their tokens to 
//    allow the profile server to recognize the connections. The profile server does not reply to these 
//    messages until both clients are connected.
// 9) A and B can send messages to each other.
// 
//
//
//
// Sequence diagram 2) to 6):
//
//    [ A ]                                         [ Server:clNonCustomer ]                                  [ B ]
//      |                                                   |                                                   |  
//      |                                                   |                                                   |  
//      |                                                   |                                                   |  
//      |  GetIdentityInformationRequest                    |                                                   |
//      *-------------------------------------------------> *                                                   |
//      |  <includeApplicationServices = true>              |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                   GetIdentityInformationResponse  |                                                   |
//      * <-------------------------------------------------*                                                   |
//      |                           <list of supported AS>  |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |  CallIdentityApplicationServiceRequest            |                                                   |
//      *-------------------------------------------------> *                                                   |
//      |  <AS1>                                            |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                                                   |  IncomingCallNotificationRequest                  |
//      |                                                   *-------------------------------------------------> *
//      |                                                   |  <callee's token, AS1>                            |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                  IncomingCallNotificationResponse |
//      |                                                   * <-------------------------------------------------*
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |           CallIdentityApplicationServiceResponse  |                                                   |
//      * <-------------------------------------------------*                                                   |
//      |                                 <caller's token>  |                                                   |  
//      |                                                   |                                                   |  
//                                                                                                                   
//
// Now the both clients are expected to connect to clAppService and send an initialization message to the server 
// using their token.
//
//
// Sequence diagram 7) to 9), assuming that B is the first one to send the initialization message 
// on the clAppService port:
//
//    [ A ]                                         [ Server:clAppService ]                                   [ B ]
//      |                                                   |                                                   |  
//      |                                                   |                                                   |  
//      |                                                   |                                                   |  
//      |                                                   |             ApplicationServiceSendMessageRequest  |
//      |                                                   * <-------------------------------------------------*
//      |                                                   |                       <callee's token, init msg>  |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |  ApplicationServiceSendMessageRequest             |                                                   |
//      *-------------------------------------------------> *                                                   |
//      |  <caller's token, init msg>                       |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |            ApplicationServiceSendMessageResponse  |                                                   |
//      * <-------------------------------------------------*                                                   |
//      |                                 <B is connected>  |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                                                   |  ApplicationServiceSendMessageResponse            |
//      |                                                   *-------------------------------------------------> *
//      |                                                   |  <A is connected>                                 |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |  ApplicationServiceSendMessageRequest             |                                                   |
//      *-------------------------------------------------> *                                                   |
//      |  <caller's token, message #A1>                    |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |  
//      |                                                   |  App..ReceiveMessageNotificationRequest           |
//      |                                                   *-------------------------------------------------> *
//      |                                                   |  <message #A1>                                    |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                                                   |          App..ReceiveMessageNotificationResponse  |
//      |                                                   * <-------------------------------------------------*
//      |                                                   |                                         <got it>  |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |            ApplicationServiceSendMessageResponse  |                                                   |
//      * <-------------------------------------------------*                                                   |
//      |                                      <B got #A1>  |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                                                   |             ApplicationServiceSendMessageRequest  |
//      |                                                   * <-------------------------------------------------*
//      |                                                   |                    <callee's token, message #B1>  |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |  ApplicationServiceSendMessageRequest             |                                                   |
//      *-------------------------------------------------> *                                                   |
//      |  <caller's token, message #A2>                    |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |           App..ReceiveMessageNotificationRequest  |                                                   |
//      * <-------------------------------------------------*                                                   |
//      |                                    <message #B1>  |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |  
//      |                                                   |  App..ReceiveMessageNotificationRequest           |
//      |                                                   *-------------------------------------------------> *
//      |                                                   |  <message #A2>                                    |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |  App..ReceiveMessageNotificationResponse          |                                                   |
//      *-------------------------------------------------> *                                                   |
//      |  <got it>                                         |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |  
//      |                                                   |          App..ReceiveMessageNotificationResponse  |
//      |                                                   * <-------------------------------------------------*
//      |                                                   |                                         <got it>  |
//      |                                                   |                                                   |
//      |                                                   |                                                   |  
//      |                                                   |  ApplicationServiceSendMessageResponse            |
//      |                                                   *-------------------------------------------------> *
//      |                                                   |  <A got #B1>                                      |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |            ApplicationServiceSendMessageResponse  |                                                   |
//      * <-------------------------------------------------*                                                   |
//      |                                      <B got #A2>  |                                                   |
//      |                                                   |                                                   |



// 
// Obtains a basic information about an identity hosted on the profile server.
// If the identity is online, the information includes a list of application services 
// that the identity supports in the currently active session.
//
// Roles: clNonCustomer, clCustomer
//
message GetIdentityInformationRequest {
  bytes identityNetworkId = 1;                     // Identity's network identifier.
  bool includeProfileImage = 2;                    // If set to true, the response will include a profile image.
  bool includeThumbnailImage = 3;                  // If set to true, the response will include a thumbnail image.
  bool includeApplicationServices = 4;             // If set to true and the given identity is online, the response will include 
                                                   // a list of application services that the identity supports in the currently active session.
}


//
// A response to GetIdentityInformationRequest.
//
// Specific Error Responses:
//   * ERROR_NOT_FOUND - 'GetIdentityInformationRequest.identityNetworkId' does not identify an identity hosted by the profile server.
//   * ERROR_UNINITIALIZED - The target identity's profile has not been initialized yet.
//
message GetIdentityInformationResponse {
  bool isHosted = 1;                               // True if the requested identity is a customer of the profile server.
  bool isTargetProfileServerKnown = 2;             // If 'isHosted' is false then this is true if the identity's new profile server is known to the profile server. In all other cases, this is false.
  bytes targetProfileServerNetworkId = 3;          // If 'isTargetProfileServerKnown' is true then this field contains the identity's new profile server network ID.

  // Following fields are valid only if 'isHosted' is true.
  bool isOnline = 4;                               // True if the requested identity is currently online.
  bytes version = 5;                               // VersionType. Version of the profile.
  bytes identityPublicKey = 6;                     // The requested identity's public key.
  string type = 7;                                 // The requested identity's type.
  string name = 8;                                 // The requested identity's name.
  sfixed32 latitude = 9;                           // LocationType. The requested identity's GPS location latitude information.
  sfixed32 longitude = 10;                         // LocationType. The requested identity's GPS location longitude information.
  string extraData = 11;                           // The requested identity's extra data.
  bytes profileImage = 12;                         // If 'GetIdentityInformationRequest.includeProfileImage' was set, this contains the requested identity's profile image.
  bytes thumbnailImage = 13;                       // If 'GetIdentityInformationRequest.includeThumbnailImage' was set, this contains the requested identity's thumbnail image.

  repeated string applicationServices = 14;        // If 'GetIdentityInformationRequest.includeApplicationServices' was set and if 'isOnline' is true, this contains 
                                                   // the list of application services that the requested identity supports in the currently active session.                                                   
}


// 
// Request to establish a bridged connection between a requestor (the caller) and an identity (the callee) 
// hosted on the profile server via one of its supported application service. The callee has to be online, 
// otherwise the request will fail.
//
// The profile server informs the callee about the incoming call and issues a token pair (caller's and 
// callee's tokens) to identify the caller and the callee on the Application Service Interface. The callee's 
// token is sent to the callee with the information about the incoming call. If the callee wants to accept 
// the call, the profile server informs the caller and sends it the caller's token. Both clients are then 
// expected to establish new connections to the profile server's Application Service Interface and use their 
// tokens to send a message to the other client.
//
// Roles: clNonCustomer, clCustomer
//
// Conversation status: Verified
//
message CallIdentityApplicationServiceRequest {
  bytes identityNetworkId = 1;                     // Network identifier of the identity to call.
  string serviceName = 2;                          // Name of the application service to use.
}


//
// A response to CallIdentityApplicationServiceRequest.
//
// Specific Error Responses:
//   * ERROR_NOT_AVAILABLE - The callee is not online, or it failed to reply to the notification within the required time frame.
//   * ERROR_REJECTED - The callee rejected the call.
//   * ERROR_UNINITIALIZED - The callee's profile has not been initialized yet.
//   * ERROR_INVALID_VALUE
//     * Response.details == "identityNetworkId" - 'CallIdentityApplicationServiceRequest.identityNetworkId' does not identify an identity hosted by the profile server.
//     * Response.details == "serviceName" - 'CallIdentityApplicationServiceRequest.serviceName' is not an application service supported by the callee in the current session.
//
message CallIdentityApplicationServiceResponse {
  bytes callerToken = 1;                           // Token for the caller to identify the session on the Application Service Interface.
}


// 
// This request is sent by profile server to its customer client (the callee) when another client (the caller) wants 
// to establish a call over the customer client's application service.
//
// The callee is required to send its response to this request within 10 seconds, otherwise the call channel will not be established.
//
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message IncomingCallNotificationRequest {
  bytes callerPublicKey = 1;                       // Public key of the caller.
  string serviceName = 2;                          // Name of the application service the caller wants to use.
  bytes calleeToken = 3;                           // Token for the callee to identify the session on the Application Service Interface.
}


//
// A response to CallIdentityApplicationServiceRequest. This is sent by the customer client (the callee) 
// to its profile server.
//
// Specific Error Responses:
//   * ERROR_REJECTED - The callee rejects the call.
//
message IncomingCallNotificationResponse {
}



// 
// This request is sent by a client to the profile server in order to deliver a message to the other client 
// over the opened application service call channel.
//
// After the client connects to clAppService port, it sends an initialization message using this request 
// to inform the profile server about its identity. This initialization message is not delivered to the other 
// party and the profile server responds to this initialization message only after the other party is also 
// connected. In the initialization message, the 'message' field is ignored. If the other party fails to join 
// the channel within 30 seconds, the profile server closes the existing connection to the connected client.
//
// Until the client receives a reply from the profile server to its initialization message, it is not allowed 
// to send other ApplicationServiceSendMessageRequest. This would be an error and the profile server would
// destroy the channel.
//
// If neither of clients connects to clAppService port or sends an inititial message within 30 seconds after 
// the call was initiated, the profile server destroys the channel.
// 
// Note that the clients are allowed to disconnect from clNonCustomer/clCustomer port once the caller receives 
// CallIdentityApplicationServiceResponse and the callee sends IncomingCallNotificationResponse.
//
// Each client is only allowed to have 20 ApplicationServiceSendMessageRequest messages pending, which means
// that there was no ApplicationServiceSendMessageResponse sent to the client. If a client attempts to send
// another message while having 20 pending messages, the profile server destroys the call channel.
//
//
// Roles: clAppService
//
message ApplicationServiceSendMessageRequest {
  bytes token = 1;                                 // Client's token to identify the session.
  bytes message = 2;                               // Message to send to the other client.
}


//
// A response to ApplicationServiceSendMessageRequest. This is sent by the profile server to the client to 
// confirm that it sent the message to the other client and the other client confirmed its arrival.
// 
// If the connection to one of the clients is terminated, the profile server closes the connection to the 
// other client.
//
// Specific Error Responses:
//   * ERROR_NOT_FOUND - 'ApplicationServiceSendMessageRequest.token' is not a valid token. This can have many causes.
//                       The token itself can have invalid format, or no such token was ever issued by the server. 
//                       However, it can also be the case that the token was valid in the past but the call channel 
//                       was closed by the server for any reason and thus the token is no longer valid. 
//
message ApplicationServiceSendMessageResponse {
}



// 
// This request is sent by a profile server after it received ApplicationServiceSendMessageRequest from 
// one of the clients. This forwards the message to its intended recipient.
//
// Roles: clAppService
//
message ApplicationServiceReceiveMessageNotificationRequest {
  bytes message = 1;                               // Message that was sent to the intended recipient - a copy of 'ApplicationServiceSendMessageRequest.message'.
}


//
// A response to ApplicationServiceReceiveMessageNotificationRequest.
// 
message ApplicationServiceReceiveMessageNotificationResponse {
}


//
// Obtains identity profiles statistics from a profile server.
//
// Only actively hosted profiles are counted regardless of whether or not the profiles are initialized.
//
// Roles: clNonCustomer, clCustomer
//
message ProfileStatsRequest {
}


//
// A response to ProfileStatsRequest.
// 
message ProfileStatsResponse {
  repeated ProfileStatsItem stats = 1;             // List of profile statistics grouped by identity type.
}


//
// Statistical information on identities of a specific type.
//
message ProfileStatsItem {
  string identityType = 1;                         // Type of identity. 
  uint32 count = 2;                                // Number of profiles hosted on the profile server of the specific type of identity.
}


//
// Asks a profile server for a list of all identities that match the search criteria. This search never returns 
// profiles of old customer identities who cancelled their hosting agreements, even if the profile server still 
// holds some information about those identities.
//
// Each search request only produces a limited number of results. The maximal size of the first set of results 
// is provided by 'maxResponseRecordCount' field. The response to this message contains up to 'maxResponseRecordCount' 
// results. If there are more results available, they are saved to the conversation context, which enables the client 
// to obtain more results with subsequent ProfileSearchPartRequest messages.
//
// The profile server will not save more than 'maxTotalRecordCount' search requests. 
// The profile server has to allow the client to get additional results at least 1 minute from receiving 
// ProfileSearchRequest, but it can maintain the result cache for longer than that.
//
// Once the client sends another ProfileSearchRequest, or if it disconnects, the old search results are discarded.
//
// Roles: clNonCustomer, clCustomer
//
// Conversation status: ConversationStarted, Verified, Authenticated
//
message ProfileSearchRequest {
  bool includeHostedOnly = 1;                      // If set to true, the profile server only returns profiles of its own customers.
                                                   // If set to false, profiles from the server's neighborhood can be included in the result.
  bool includeThumbnailImages = 2;                 // If set to true, the response will include a thumbnail image of each profile.
  uint32 maxResponseRecordCount = 3;               // Maximal number of results to be delivered in the response. If 'includeThumbnailImages'
                                                   // is true, this has to be an integer between 1 and 100. If 'includeThumbnailImages' is false,
                                                   // this has to be an integer between 1 and 1000. The value must not be greater than 'maxTotalRecordCount'.
  uint32 maxTotalRecordCount = 4;                  // Maximal number of total results that the profile server will look for and save. If 'includeThumbnailImages'
                                                   // is true, this has to be an integer between 1 and 1,000. If 'includeThumbnailImages' is false,
                                                   // this has to be an integer between 1 and 10,000.

  // Search filters.
  string type = 5;                                 // WildcardType or empty string. If not empty, the profile server will only return profiles 
                                                   // of identity types that match the wildcard string. If empty, all identity types are allowed.
                                                   // Max 64 bytes long.
  string name = 6;                                 // WildcardType or empty string. If not empty, the profile server  will only return profiles 
                                                   // with names that match the wildcard string. If empty, all profile names are allowed.
                                                   // Max 64 bytes long.
  sfixed32 latitude = 7;                           // LocationType. Encoded target GPS location latitude or NO_LOCATION. If not NO_LOCATION, 
                                                   // it is, in combination with 'longitude' and 'radius' a specification of target area, 
                                                   // where the identity has to be located (according to its profile information) in order to be 
                                                   // included in the search results. If NO_LOCATION, 'longitude' and 'radius' are ignored 
                                                   // and all locations are allowed.
  sfixed32 longitude = 8;                          // LocationType. If 'latitude' is not NO_LOCATION, this is encoded target GPS location longitude.
  uint32 radius = 9;                               // If 'latitude' is not NO_LOCATION, this is target location radius in metres.
  string extraData = 10;                           // RegexType or empty string. If not empty, specifies the regular expression that identity
                                                   // profile's extra data information must match in order to be included in the results. 
                                                   // If empty, no filtering based on extra data information is made.
                                                   // Max 256 bytes long.
}


//
// A response to ProfileSearchRequest.
//
// If 'maxResponseRecordCount' is lower than 'totalRecordCount', the client is allowed to send 
// ProfileSearchPartRequest messages to obtain more results.
//
// If a client is looking for a small set of profiles within a large area, it might need to perform 
// multiple search queries across several profile servers in the target area in order to "cover" it. 
// 'coveredServers' contains a list of profile servers forming the neighborhood of the profile server 
// being queried. Neighborhood servers share their profile databases and a query to one server will 
// thus cover profile servers in its neighborhood. Note that this information is not much relevant 
// in case the number of result is large and is limited by the protocol. In this case, it is possible 
// that the profile server returns results from profile databases only from a small subset of its 
// neighborhood provided in the 'coveredServers' value, or even only from its own database.
//
//
// Specific Error Responses:
//   * ERROR_INVALID_VALUE
//     * Response.details == "maxResponseRecordCount" - 'ProfileSearchRequest.maxResponseRecordCount' is not within the required range.
//     * Response.details == "maxTotalRecordCount" - 'ProfileSearchRequest.maxTotalRecordCount' is not within the required range.
//     * Response.details == "type" - 'ProfileSearchRequest.type' is too long.
//     * Response.details == "name" - 'ProfileSearchRequest.name' is too long.
//     * Response.details == "latitude" - 'ProfileSearchRequest.latitude' is not a valid location latitude.
//     * Response.details == "longitude" - 'ProfileSearchRequest.longitude' is not a valid location longitude.
//     * Response.details == "radius" - 'ProfileSearchRequest.radius' is not a valid radius value.
//     * Response.details == "extraData" - 'ProfileSearchRequest.extraData' is too long or it is not a valid value of RegexType.
//
message ProfileSearchResponse {
  uint32 totalRecordCount = 1;                     // Total number of profiles that matched the search criteria. Up to 'maxResponseRecordCount' of them are in 'profiles' list.
  uint32 maxResponseRecordCount = 2;               // Limit of the number of results provided. This is equal to 'ProfileSearchRequest.maxResponseRecordCount'.

  repeated bytes coveredServers = 3;               // List of network identifiers of profile servers whose profile databases were be used to produce the results, 
                                                   // whether or not any of their hosted profiles actually appear in the results.
                                                   // This information is relevant if 'totalRecordCount' is lower than 'ProfileSearchRequest.maxTotalRecordCount',
                                                   // because otherwise there is no guarantee the results actually contain any records from neighborhood profile servers.

  // Search results.
  repeated IdentityNetworkProfileInformation profiles = 4;  // List of results that contains no more than 'maxResponseRecordCount' items.
}



//
// Information about a single profile record from a profile search query.
//
message IdentityNetworkProfileInformation {
  bool isHosted = 1;                               // True if the requested identity is a customer of the profile server.
  bytes hostingServerNetworkId = 2;                // If 'isHosted' is false, this field contains the network ID of the neighbor profile server that hosts the target profile.

  bool isOnline = 3;                               // If 'isHosted' is true, this is true if the requested identity is currently online.

  bytes version = 4;                               // VersionType. Version of the profile.
  bytes identityPublicKey = 5;                     // The identity's public key.
  string type = 6;                                 // The identity's type.
  string name = 7;                                 // The identity's name.
  sfixed32 latitude = 8;                           // LocationType. The identity's GPS location latitude information.
  sfixed32 longitude = 9;                          // LocationType. The identity's GPS location longitude information.
  string extraData = 10;                           // The identity's extra data.

  bytes thumbnailImage = 11;                       // If 'ProfileSearchRequest.includeThumbnailImages' was set, this contains the identity's thumbnail image, 
                                                   // or zero-length byte array if the profile has no image set.
}



//
// Request to get another part from the search query.
//
// This request only makes sense only if the client previously sent ProfileSearchRequest to 
// the profile server and the search result contained more records than the server provided 
// in the ProfileSearchResponse, and the search results have not expired yet.
//
//
// Roles: clNonCustomer, clCustomer
//
// Conversation status: ConversationStarted, Verified, Authenticated
//
message ProfileSearchPartRequest {
  uint32 recordIndex = 1;                           // Zero-based record index of the first result to retrieve. It has to be an integer between 0 and 'ProfileSearchResponse.totalRecordCount' - 1.
  uint32 recordCount = 2;                           // Number of results to obtain. 'recordIndex' + 'recordCount' must not be greater than 'ProfileSearchResponse.totalRecordCount'.
                                                    // If 'ProfileSearchResponse.includeThumbnailImages' was set, this has to be an integer between 1 and 100,
                                                    // otherwise it has to be an integer between 1 and 1,000.
}


//
// A response to ProfileSearchPartRequest.
//
// Specific Error Responses:
//   * ERROR_NOT_AVAILABLE - No cached search results are available. Either the client did not send ProfileSearchRequest previously
//                           in this session, or its results have expired already.
//   * ERROR_INVALID_VALUE
//     * Response.details == "recordIndex" - 'ProfileSearchRequest.recordIndex' is not a valid index of the result.
//     * Response.details == "recordCount" - 'ProfileSearchRequest.recordCount' is not a valid number of results to obtain in combination with 'ProfileSearchRequest.recordIndex'.
//
message ProfileSearchPartResponse {
  uint32 recordIndex = 1;                           // Index of the first result. Copy of 'ProfileSearchPartRequest.recordIndex' value.
  uint32 recordCount = 2;                           // Number of results. Copy of 'ProfileSearchPartRequest.recordCount' value.

  // Search results.
  repeated IdentityNetworkProfileInformation profiles = 3;  // List of results that contains 'ProfileSearchPartRequest.recordCount' items.
}


//
// A customer client announces a relation between its identity and another identity using 
// a relationship card.
//
// The 'cardApplication' field is signed with a signature in 'ConversationRequest.signature'. 
// This signature can be used to prove that the card recipient wanted to use the card for 
// the given purpose. The signature on the card of the card's issuer then can be used to prove 
// that the issuer issued the card for the recipient. The customer's public key has to be equal 
// to the card's recipient public key.
//
// Each profile server is allowed to define its own limit of number of relations that a single 
// identity can have. However, this limit should not exceed the maximal limit of 2,000 relations, 
// which is given by the maximal protocol message size.
//
//
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message AddRelatedIdentityRequest {
  CardApplicationInformation cardApplication = 1;   // Description of the relationship, which must correspond to the given 'card' - i.e. 'cardApplication.cardId' 
                                                    // has to match 'signedCard.card.cardId'.
  SignedRelationshipCard signedCard = 2;            // Signed relationship card. 'signedCard.card.recipientPublicKey' has to be the public key of the customer
                                                    // that sends AddRelatedIdentityRequest to the profile server.
}



//
// A response to AddRelatedIdentityRequest.
//
//
// Specific Error Responses:
//   * ERROR_QUOTA_EXCEEDED - The caller has reached its limit for a number of related identities on its profile.
//   * ERROR_INVALID_SIGNATURE - The client's signature of the 'AddRelatedIdentityRequest.cardApplication' in 'ConversationRequest.signature' is not valid.
//   * ERROR_ALREADY_EXISTS - A relationship with application identifier equal to 'AddRelatedIdentityRequest.cardApplication.applicationId' already exists.
//   * ERROR_INVALID_VALUE
//     * Response.details == "cardApplication.cardId" - 'AddRelatedIdentityRequest.cardApplication.cardId' does not match 'AddRelatedIdentityRequest.signedCard.card.cardId'.
//     * Response.details == "cardApplication.applicationId" - 'AddRelatedIdentityRequest.cardApplication.applicationId' is not a valid application identifier.
//     * Response.details == "signedCard.issuerSignature" - 'AddRelatedIdentityRequest.signedCard.issuerSignature' is not a valid signature of 'AddRelatedIdentityRequest.signedCard.card' structure
//                                                          using private key of the issuer whose public key is 'AddRelatedIdentityRequest.signedCard.card.issuerPublicKey'.
//     * Response.details == "signedCard.card.cardId" - 'AddRelatedIdentityRequest.signedCard.card.cardId' is not a valid SHA256 hash of 'AddRelatedIdentityRequest.signedCard.card' structure.
//     * Response.details == "signedCard.card.version" - 'AddRelatedIdentityRequest.signedCard.card.version' is not a valid card version.
//     * Response.details == "signedCard.card.type" - 'AddRelatedIdentityRequest.signedCard.card.type' is not a valid card type.
//     * Response.details == "signedCard.card.issuerPublicKey" - 'AddRelatedIdentityRequest.signedCard.card.issuerPublicKey' is not a valid public key.
//     * Response.details == "signedCard.card.recipientPublicKey" - 'AddRelatedIdentityRequest.signedCard.card.recipientPublicKey' is not the public key of the caller.
//     * Response.details == "signedCard.card.validFrom" - 'AddRelatedIdentityRequest.signedCard.card.validFrom' is greater than 'AddRelatedIdentityRequest.signedCard.card.validTo'.
//
message AddRelatedIdentityResponse {
}



//
// A customer client removes the announcement of a relationship between its identity and another identity.
//
//
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message RemoveRelatedIdentityRequest {
  bytes applicationId = 1;                          // Identifier of the card application to remove. 
}



//
// A response to RemoveRelatedIdentityRequest.
//
//
// Specific Error Responses:
//   * ERROR_NOT_FOUND - A relationship with application identifier equal to 'AddRelatedIdentityRequest.cardApplication.applicationId' was not found.
//
message RemoveRelatedIdentityResponse {
}



//
// Description of a relationship card application. It consists of a card identifier, which is a hash 
// of the card data and the 'applicationId', which binds the use of the card with some other object, 
// transaction, or action, which is specific for the given use of the card.
//
message CardApplicationInformation {
  bytes cardId = 1;                                 // Identifier of a relationship card. See 'RelationshipCard.cardId'.
  bytes applicationId = 2;                          // Unique identifier of the action that represents using the card. This is used to bind the application of the card 
                                                    // with a specific transaction or action. If no transaction or action identifier exists, the recipient should 
                                                    // generate a new GUID. If the given card is guaranteed to be used only once, this can be equal to 'cardId'.
                                                    // Max 32 bytes long. Must not be empty.
}


// 
// Description of a relationship card signed by its issuer. Only the identifier of the card is 
// signed, but since this is a SHA256 hash of all the card's fields (except for the ID itself), 
// the signature of the identifier effectively signs the whole card information.
//
message SignedRelationshipCard {
  RelationshipCard card = 1;                        // Description of the relationship card.
  bytes issuerSignature = 2;                        // Signature of 'card.cardId' value in raw format using private key of the issuer of the card.
                                                    // Max 100 bytes long.
}


//
// Description of a relationship card.
//
message RelationshipCard {
  bytes cardId = 1;                                 // Identifier of a relationship card is an SHA256 hash of the RelationshipCard structure in Google Protobuf v3 encoding 
                                                    // with cardId initialized to a byte array of 32 zero bytes.
  bytes version = 2;                                // VersionType. Version of the relationship card structure.
  string type = 3;                                  // Type of the relationship card. This is an application defined value. Max 64 bytes long.
  sint64 validFrom = 4;                             // TimestampType. Time from which the card is valid. It must not be greater than 'validTo'.
  sint64 validTo = 5;                               // TimestampType. Time after which the card is not valid.
  bytes issuerPublicKey = 6;                        // Public key of the issuer of the card. Max 128 bytes long.
  bytes recipientPublicKey = 7;                     // Public key of the recipient of the card. Max 128 bytes long.
}




// 
// Obtains list of identity's relationships that match the given criteria.
//
// Roles: clNonCustomer, clCustomer
//
message GetIdentityRelationshipsInformationRequest {
  bytes identityNetworkId = 1;                     // Identity's network identifier.
  bool includeInvalid = 2;                         // If set to true, the response may include relationships which cards are no longer valid or not yet valid.
  
  string type = 3;                                 // WildcardType or empty string. If not empty, the server will only return relationships which card types 
                                                   // match the wildcard string. If empty, all card types are allowed.
                                                   // Max 64 bytes long.

  bool specificIssuer = 4;                         // If set to true, the response will only include relationships which cards were issued by issuer with network identifier equal to 'issuerNetworkId'.
  bytes issuerNetworkId = 5;                       // If 'specificIssuer' is true, this is the network identifier of the card issuer whose relationships with the target identity are being queried.
}



//
// A response to GetIdentityRelationshipsInformationRequest.
//
// Specific Error Responses:
//   * ERROR_INVALID_VALUE
//     * Response.details == "type" - 'GetIdentityRelationshipsInformationRequest.type' is too long.
//
message GetIdentityRelationshipsInformationResponse {
  repeated IdentityRelationship relationships = 1; // List of all matching identity relationships together with their relationship cards.
}


//
// Description of a relationship between two identities together with signature proofs.
//
message IdentityRelationship {
  CardApplicationInformation cardApplication = 1;  // Relationship card application.
  bytes cardApplicationSignature = 2;              // Relationship card recipient's signature of 'cardApplication' structure.
  SignedRelationshipCard card = 3;                 // Relationship card signed by its issuer.
}



//
// Initiates sharing of the profile database with a neighbor profile server.
//
// Profile server joining the network needs to contact its neighbors and ask them to share their 
// profile databases, so that it can include the profiles of their clients into its own searches.
// Similarly, profile servers that detect a new neighbor in their neighborhood need to contact 
// it and ask it to share its profile database with them.
//
// Sharing the profile list always goes from one profile server S (who acts as the server in 
// the session) to the requesting profile server C (who acts as a client in the session). It is C 
// who connects to S and sends a request asking S to share its database. If the server C wants 
// to share its profile database with the server S, it has to wait for the request from C, which 
// will ask it to share its database. This request will come if S considers C its neighbor.
//
// The process starts with the server C sending StartNeighborhoodInitializationRequest message to S.
// If S accepts the request, it replies with StartNeighborhoodInitializationResponse and then 
// it starts sending NeighborhoodSharedProfileUpdateRequest messages until a full database is sent to C. 
// With each update message, C has to check the validity of the data and if it accepts the batch
// it replies with NeighborhoodSharedProfileUpdateResponse. Once all of the profiles are sent to C,
// S sends FinishNeighborhoodInitializationRequest and if C replies with successful message
// FinishNeighborhoodInitializationResponse, the process is completed. 
//
// If S does not host any profiles yet, it may send FinishNeighborhoodInitializationRequest message 
// without sending any NeighborhoodSharedProfileUpdateRequest messages.
//
// Once C replies with FinishNeighborhoodInitializationResponse, the initialization process is 
// finished and C can consider the profiles hosted on S in its search queries. If a connection 
// is terminated or the process is disrupted in any other way, C can not consider the process 
// as finished and must not include the profiles of S in its searches.
//
// The profile server S has the responsibility of keeping the information on C up to date. With 
// each change of profile S hosts, it has to contact C and inform it about the change. This is done 
// using NeighborhoodSharedProfileUpdateRequest messages that are sent outside the initialization 
// process (i.e. without sending StartNeighborhoodInitializationRequest message first).
//
// If the request is processed successfully, the initialization of the neighbor relationship is 
// started on the opened session and the initialization process has to be finished with 
// FinishNeighborhoodInitializationRequest or it will fail when the connection is terminated. 
//
// All profiles received from a neighbor have expiration time after which the profile server can 
// delete them from its database. The minimal refresh time is 24 hours, which means that each server 
// has to keep the profiles from its neighbors for at least 24 hours from the time of last update.
// Each server is free to define its own refresh time longer than 24 hours, which means it will 
// not deleted unrefreshed data for more than 24 hours.
//
//
// Roles: srNeighbor
//
// Conversation status: Verified
//
message StartNeighborhoodInitializationRequest {
  uint32 primaryPort = 1;                          // Port of the profile server's Primary Interface.
  uint32 srNeighborPort = 2;                       // Port of the profile server's Neighbors Interface.
}


//
// A response to StartNeighborhoodInitializationRequest.
//
//
// General Error Responses:
//   * ERROR_REJECTED - Profile server already has reached its limit of a number of servers that it shares its profile database with and is not willing to have more.
//   * ERROR_ALREADY_EXISTS - Neighborhood initialization process has already been done.
//   * ERROR_BUSY - Profile server can use this error code during the start of the neighborhood initialization process to express that it is currently busy 
//                  with the neighborhood initialization process with one or more other profile servers.
//   * ERROR_INVALID_VALUE
//     * Response.details == "primaryPort" - 'StartNeighborhoodInitializationRequest.primaryPort' must be an integer between 1 and 65535.
//     * Response.details == "srNeighborPort" - 'StartNeighborhoodInitializationRequest.srNeighborPort' must be an integer between 1 and 65535.
//
message StartNeighborhoodInitializationResponse {
}


//
// Profile server that was requested to share its profile database with its neighbor using 
// StartNeighborhoodInitializationRequest uses this request to finish the initialization process. 
// Sending this message means that all profiles were successfully shared.
//
//
// Roles: srNeighbor
//
// Conversation status: Verified
//
message FinishNeighborhoodInitializationRequest {
}


//
// A response to FinishNeighborhoodInitializationRequest. 
//
// Sending this response means that the sender will now consider the shared profiles from 
// the other server in its search queries.
//
// Specific Error Responses:
//   * ERROR_REJECTED - No neighborhood initialization process was started on this session using StartNeighborhoodInitializationRequest.
//
message FinishNeighborhoodInitializationResponse {
}


//
// This request is sent by a profile server to announce a change in one or more of the profiles 
// of its customers. This request is also used during the neighborhood initialization to send 
// the profile server's profile database to the requesting server. If the request is sent outside 
// the neighborhood initialization process, it is considered as a standalone request.
//
// During the neighborhood initialization process, only items with `SharedProfileUpdateItem.ActionType` 
// of `SharedProfileAddItem` can be sent.
//
//
// Roles: srNeighbor
//
// Conversation status: Verified
//
message NeighborhoodSharedProfileUpdateRequest {
  repeated SharedProfileUpdateItem items = 1;      // List of profile update items.
}


//
// A response to NeighborhoodSharedProfileUpdateRequest.
//
// Specific Error Responses:
//   * ERROR_REJECTED - Neighborhood initialization process has not been done or finished yet, or profile server is no longer interested in receiving updates 
//                      from the requesting profile server. This should have the same effect as if the profile server sent StopNeighborhoodUpdatesRequest to 
//                      the requesting profile server. If the requesting profile server wants to share its database, it has to go through neighborhood 
//                      initialization process from start.
//   * ERROR_INVALID_VALUE
//     * Response.details == "$index.$field" - All items up to 'NeighborhoodSharedProfileUpdateRequest.items[$index]' (exclusive) were processed correctly
//                                             and an error occurred while processing the item with zero-based index $index. Items with index greater 
//                                             then $index were not processed. The $field specifies which field was invalid as follows:
//       * $field == "add" - Number of shared profiles from the requesting profile server exceeds the limit.
//       * $field == "add.version" - `items[$index].add.version` is not a valid VersionType value.
//       * $field == "add.identityPublicKey" - `items[$index].add.identityPublicKey` is not a valid public key value or the same identity already exists.
//       * $field == "add.name" - `items[$index].add.name` is not a valid profile name.
//       * $field == "add.type" - `items[$index].add.type` is not a valid identity type.
//       * $field == "add.thumbnailImage" - `items[$index].add.thumbnailImage` is not a valid thumbnail image.
//       * $field == "add.latitude" - `items[$index].add.latitude` is not a valid latitude value.
//       * $field == "add.longitude" - `items[$index].add.longitude` is not a valid longitude value.
//       * $field == "add.extraData" - `items[$index].add.extraData` is not a valid extraData value.
//       * $field == "change.set*" - `items[$index].change.set*` are all false.
//       * $field == "change.identityNetworkId" - `items[$index].change.identityNetworkId` does not represent an existing identity.
//       * $field == "change.version" - `items[$index].change.version` is not a valid VersionType value.
//       * $field == "change.name" - `items[$index].change.name` is not a valid profile name.
//       * $field == "change.thumbnailImage" - `items[$index].change.thumbnailImage` is not a valid thumbnail image.
//       * $field == "change.latitude" - `items[$index].change.latitude` is not a valid latitude value.
//       * $field == "change.longitude" - `items[$index].change.longitude` is not a valid longitude value.
//       * $field == "change.extraData" - `items[$index].change.extraData` is not a valid extraData value.
//       * $field == "delete.identityNetworkId" - `items[$index].delete.identityNetworkId` does not represent an existing identity.
//       * $field == "actionType" - During the neighborhood initialization process, only `SharedProfileAddItem` is a valid update message.
//
message NeighborhoodSharedProfileUpdateResponse {
}


//
// Information about update of a neighborhood's profile.
//
message SharedProfileUpdateItem {
  oneof ActionType {                               // Update operation can be:
    SharedProfileAddItem add = 1;                  //  * adding a new profile to the database,
    SharedProfileChangeItem change = 2;            //  * changing an existing profile,
    SharedProfileDeleteItem delete = 3;            //  * deleting an existing profile,
    SharedProfileRefreshAllItem refresh = 4;       //  * refresh expiration date of all existing profiles.
  }
}


//
// Information about newly created profile that is to be shared with a neighbor.
//
message SharedProfileAddItem {
  bytes version = 1;                               // VersionType. Version of the profile structure.
  bytes identityPublicKey = 2;                     // The identity's public key. Max 128 bytes long.
  string name = 3;                                 // Name of the profile or empty string, max 64 bytes long.
  string type = 4;                                 // The identity's type, non-empty string, max 64 bytes long. 
  bool setThumbnailImage = 5;                      // If true, 'thumbnailImage' has to contain valid image date. If false, 'thumbnailImage' is ignored.
  bytes thumbnailImage = 6;                        // If 'setThumbnailImage' is true, this contains profile image in PNG or JPEG format, max 5,120 bytes long.
  sfixed32 latitude = 7;                           // LocationType. GPS location latitude information.
  sfixed32 longitude = 8;                          // LocationType. GPS location longitude information.
  string extraData = 9;                            // Semicolon separated 'key=value' list, or empty string, max 200 bytes long.
}


//
// Information about changes in an existing profile data that are to be shared with a neighbor.
//
message SharedProfileChangeItem {
  bytes identityNetworkId = 1;                     // The identity's network identifier.

  bool setVersion = 2;                             // Profile version should be updated. 'version' must contain valid data.
  bool setName = 3;                                // Profile name should be updated. 'name' must contain valid data.
  bool setThumbnailImage = 4;                      // Profile image should be updated. 'thumbnailImage' must contain valid data.
  bool setLocation = 5;                            // Profile location should be updated. 'latitude' and 'longitude' must contain valid data.
  bool setExtraData = 6;                           // Profile extra data should be updated. 'extraData' must contain valid data.

  bytes version = 7;                               // VersionType. Version of the profile structure.
  string name = 8;                                 // Name of the profile, non-empty string, max 64 bytes long.
  bytes thumbnailImage = 9;                        // Profile thumbnail image in PNG or JPEG format, non-empty binary data, max 5,120 bytes long, or zero length binary data if the image is about to be deleted.
  sfixed32 latitude = 10;                          // LocationType. GPS location latitude information.
  sfixed32 longitude = 11;                         // LocationType. GPS location longitude information.
  string extraData = 12;                           // Semicolon separated 'key=value' list, max 200 bytes long.
}


//
// Information about the removal of an existing profile that is to be shared with a neighbor.
//
message SharedProfileDeleteItem {
  bytes identityNetworkId = 1;                     // The identity's network identifier.
}


//
// Request to refresh all existing profiles of the requesting server on the target server.
//
message SharedProfileRefreshAllItem {
}



//
// Asks a (former) neighbor to stop sending updates of its database to the profile server.
//
//
// Roles: srNeighbor
//
// Conversation status: Verified
//
message StopNeighborhoodUpdatesRequest {
}


//
// A response to StopNeighborhoodUpdatesRequest. 
//
// Specific Error Responses:
//   * ERROR_NOT_FOUND - The target server does not recognize the profile server as its neighbor.
//
message StopNeighborhoodUpdatesResponse {
}





//
// CAN Integration
//
// CAN provides globally accessible distribute storage that is used for multiple purposes in IoP. From profile 
// server's point of view, the most important use case is implementation of indexing that allows IoP users 
// to find other users or profile servers only using their network identifier. 
//
// A profile server publishes its contact information in CAN when it is started for the first time. It also 
// creates a so called IPNS record that maps the profile server network ID to this contact information record 
// and thus allows anyone to find the contact information known just the network ID of the profile server.
//
// An identity client uses the CanStoreDataRequest and CanPublishIpnsRecordRequest to do a similar thing. 
// The client creates a CAN data object that must contain a link back to its hosting profile server, but it can 
// also contain arbitrary data defined by the client. The client asks its hosting profile server to store that 
// object in CAN and then it also creates and submits an IPNS record that binds the CAN object with the client's 
// network identifier. The client must have a valid hosting agreement with a profile server in order to be 
// allowed to use the CAN related requests.
//
// To delete the object, a client uses CanStoreDataRequest with empty data.
//
// CAN data objects are immutable. The profile server is responsible for deleting the old object from CAN when 
// it wants to replace it by a new object. When the profile server's contact information changes, the profile 
// server asks CAN to delete the old contact information object and publishes a new contact information object.
// Then it has to submit a new IPNS to point to the new object. Similarly, if the identity client wants to 
// change its CAN object, the profile server asks CAN to delete the old client's object (if there is any) 
// and then uploads the new one. Again, client's IPNS record must be resubmitted as well.
//
// IPNS records expire in time and must be refreshed. This is done by creating a new IPNS record by the IPNS 
// record owner and replacing the old version of the record with the new one. Profile server can do this directly 
// for its IPNS records, but clients do not have a direct write access to CAN. In order to refresh IPNS record,
// the client uses CanPublishIpnsRecordRequest again. If an IPNS record expires, it becomes invalid and will be 
// discarded by CAN network.
//
// IPNS records has to be signed by the private key of its owner, otherwise they are invalid. This requirement 
// prevents malicious manipulations of IPNS records.
//


//
// Profile server contact information.
//
message CanProfileServerContact {
  bytes publicKey = 1;                             // Profile server's public key.
  bytes ipAddress = 2;                             // IPv4 or IPv6 public address of the network interface on which profile server operates.
  uint32 primaryPort = 3;                          // TCP port of profile server's primary interface.
}


//
// Structure of data an identity client can store in CAN storage.
//
message CanIdentityData {
  bytes hostingServerId = 1;                       // Network ID of the profile server that hosts the identity.
  repeated CanKeyValue keyValueList = 2;           // Key-value dictionary that contain client defined data.
                                                   // Keys should not be repeated in the list, but this is not enforced. 
                                                   // However, different application can behave differently if a single key 
                                                   // is used more than once.
}


//
// Description of a single item in key-value type of structure.
//
message CanKeyValue {
  string key = 1;                                  // Name of the item, which should be unique within the client's CAN object.
  oneof ValueType {                                // Type of the item and item value.
    bytes binaryValue = 2;
    int32 uint32Value = 3;
    int64 uint64Value = 4;
    double doubleValue = 5;
    bool boolValue = 6;
    string stringValue = 7;
  }
}


// 
// Uploads client's object to CAN and deletes the old one if there is any.
//
// Once an identity is hosted on a profile server, it can use CanStoreDataRequest to upload its CAN object 
// to CAN. The object has to contain a link back to its profile server, but otherwise, it can contain arbitrary 
// information as per client's needs. 
//
//
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message CanStoreDataRequest {
  CanIdentityData data = 1;                        // Data to store in CAN, or null to just delete the old object.
}


//
// A response to CanStoreDataRequest. 
//
// When CAN accepts the object, it returns its hash, which has to be returned to the client. The client uses 
// the hash to create its IPNS record.
//
// Specific Error Responses:
//   * ERROR_REJECTED - CAN server reported error, see 'Response.details' for the error message it sent.
//   * ERROR_INVALID_VALUE
//     * Response.details == "data.hostingServerId" - 'CanStoreDataRequest.data.hostingServerId' is not the profile server's network ID.
//
message CanStoreDataResponse {
  bytes hash = 1;                                  // Hash of 'CanStoreDataRequest.data' received from CAN in multihash binary format, or empty array if 'CanStoreDataRequest.data' was null.
}





//
// Identity client asks its hosting profile server to publish its IPNS record in CAN on its behalf.
// 
//
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message CanPublishIpnsRecordRequest {
  CanIpnsEntry record = 1;                         // Signed IPNS record. Its expiration date must not exceed the expiration date 
                                                   // of the hosting contract the client has with the profile server.
}

//
// A response to CanPublishIpnsRecordRequest.
//
// Specific Error Responses:
//   * ERROR_REJECTED - CAN server reported error, see 'Response.details' for the error message it sent.
//   * ERROR_NOT_FOUND - Client did not upload any CAN object yet.
//   * ERROR_INVALID_VALUE
//     * Response.details == "record" - 'CanPublishIpnsRecordRequest.record' does not represent a valid IPNS record.
//     * Response.details == "record.value" - 'CanPublishIpnsRecordRequest.value' does not match the path to the last CAN object the client uploaded using CanStoreDataRequest.
//     * Response.details == "record.validity" - 'CanPublishIpnsRecordRequest.record.validity' is invalid expiration date or it is greater than the client's hosting contract validity.
//
message CanPublishIpnsRecordResponse {
}


//
// IPNS record as defined in https://github.com/DeCentral-Budapest/go-ipfs/blob/master/namesys/pb/namesys.proto
//
message CanIpnsEntry {
  // Type of validity value.
  enum ValidityType {
    EOL = 0;                                       // Validity value is specifies a time until which the IPNS record is valid.
  }

  bytes value = 1;                                 // IPFS path string converted to byte array. The path string has to be "/ipfs/$objectHashEncoded",
                                                   // where $objectHashEncoded is base58 encoded hash of the CAN object that the client received as `CanStoreDataResponse.hash`.
                                                   // The base58 encoding must be used without the multibase prefix - for example "/ipfs/QmaRvpLT4RgBDVY6cQKwqQGQNtbM31KSqh8TxvQgFoEUus".
  bytes signature = 2;                             // Signature of the IPNS record by its owner's private key.
                                                   // See https://github.com/DeCentral-Budapest/go-ipfs/blob/master/namesys/publisher.go.

  ValidityType validityType = 3;                   // Type of meaning of 'validity' field.
  bytes validity = 4;                              // RFC3339 UTF-8 string converted to byte array.

  uint64 sequence = 5;                             // Record sequence number that has to be increased on updates.

  uint64 ttl = 6;                                  // Time to live of the IPNS record in cache in nanoseconds.
}


//
// Representation of a cryptographic key in CAN API.
//
message CanCryptoKey {
  // Type of the key algorithm. 
  enum KeyType {
    RSA = 0;
    Ed25519 = 1;
  }
  KeyType type = 1;                                // Type of the key.
  bytes data = 2;                                  // Key binary data.
}
