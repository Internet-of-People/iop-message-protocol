### PS05xxx - Application Service Calls Related Functionality Tests

#### PS05001 - Application Service Call

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test simulates two clients exchanging couple of messages in an application service all.


###### Step 1:
The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:
Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest*. Then it queries information about the first 
identity using *GetIdentityInformationRequest* and leaves the connection open.


###### Step 3:
Over the existing connection, the second identity sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 4`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 4:
The first identity reads the incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse*.

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized


###### Step 5:

The second identity reads the response in form of *CallIdentityApplicationServiceResponse*:

  * `$callerToken := CallIdentityApplicationServiceResponse.callerToken`

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and reads the response. Then it terminates the connection to clNonCustomer port.


###### Step 6:

On clAppService port, the first identity reads *ApplicationServiceSendMessageResponse*.

###### Step 7:

The second identity sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #1 to callee."`

And then it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 3`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #2 to callee."`

And then it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 4`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #3 to callee."`


###### Step 8:

On clAppService port, the first identity reads *ApplicationServiceReceiveMessageNotificationRequest* (#1 to callee).

Then it sends *ApplicationServiceReceiveMessageNotificationResponse*. 

Then it reads *ApplicationServiceReceiveMessageNotificationRequest* (#2 to callee).

Then it sends *ApplicationServiceReceiveMessageNotificationResponse*.

And then it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #1 to CALLER."`

and waits 3 seconds.

Then it sends *PingRequest*:

  * `Message.id := 3`
  * `SingleRequest.version := [1,0,0]`
  * `PingRequest.payload = "test"`


Then it reads *ApplicationServiceReceiveMessageNotificationRequest* (#3 to callee).

Then it reads *PingResponse*.

Then it sends *ApplicationServiceReceiveMessageNotificationResponse*.

And then it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 4`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #2 to CALLER."`

and waits 3 seconds.


###### Step 9:

The second identity reads *ApplicationServiceSendMessageResponse* (#1 to callee received).

Then it reads *ApplicationServiceSendMessageResponse* (#2 to callee received).

Then it reads *ApplicationServiceReceiveMessageNotificationRequest* (#1 to CALLER).

Then it sends *ApplicationServiceReceiveMessageNotificationResponse*.

Then it reads *ApplicationServiceSendMessageResponse* (#3 to callee received). 

Then it reads *ApplicationServiceReceiveMessageNotificationRequest* (#2 to CALLER).

Then it sends *ApplicationServiceReceiveMessageNotificationResponse*.


###### Step 10:

On clAppService, the first identity reads *ApplicationServiceSendMessageResponse* (#1 to CALLER received).

Then it reads *ApplicationServiceSendMessageResponse* (#2 to CALLER received).



  
##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity and obtains information about the first 
identity. The first identity should be presented as online with "Test Service" application 
service ready to be used and its public key should be equal to $PubKeyCallee.


###### Step 3:

Nothing to check.


###### Step 4:

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`


###### Step 5:

Server replies with *CallIdentityApplicationServiceResponse*:

  * `Message.id == 4`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 6:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 7:

Nothing to check.


###### Step 8:

Server sends *ApplicationServiceReceiveMessageNotificationRequest*:

  * `SingleRequest.version == [1,0,0]`
  * `ApplicationServiceReceiveMessageNotificationRequest.message == "Message #1 to callee."`

Server sends *ApplicationServiceReceiveMessageNotificationRequest*:

  * `SingleRequest.version == [1,0,0]`
  * `ApplicationServiceReceiveMessageNotificationRequest.message == "Message #2 to callee."`

Server sends *ApplicationServiceReceiveMessageNotificationRequest*:

  * `SingleRequest.version == [1,0,0]`
  * `ApplicationServiceReceiveMessageNotificationRequest.message == "Message #3 to callee."`

Server replies with *PingResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`
  * `SingleResponse.version == [1,0,0]`
  * `PingResponse.payload == "test"`


###### Step 9:


Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 2`
  * `SingleResponse.version == [1,0,0]`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 3`
  * `SingleResponse.version == [1,0,0]`
  * `Response.status == STATUS_OK`

Server sends *ApplicationServiceReceiveMessageNotificationRequest*:

  * `SingleRequest.version == [1,0,0]`
  * `ApplicationServiceReceiveMessageNotificationRequest.message == "Message #1 to CALLER."`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 4`
  * `SingleResponse.version == [1,0,0]`
  * `Response.status == STATUS_OK`

Server sends *ApplicationServiceReceiveMessageNotificationRequest*:

  * `SingleRequest.version == [1,0,0]`
  * `ApplicationServiceReceiveMessageNotificationRequest.message == "Message #2 to CALLER."`



###### Step 10:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 2`
  * `SingleResponse.version == [1,0,0]`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 4`
  * `SingleResponse.version == [1,0,0]`
  * `Response.status == STATUS_OK`









#### PS05002 - Application Service Call - Extensive Test

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test simulates two clients exchanging a large number of messages in an application service call 
while processing and sending message in parallel.


###### Step 1:
The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:
Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 3:
The first identity reads the incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse*.

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized


###### Step 4:

The second identity reads the response in form of *CallIdentityApplicationServiceResponse*:

  * `$callerToken := CallIdentityApplicationServiceResponse.callerToken`

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and reads the response. Then it terminates the connection to clNonCustomer port.


###### Step 5:

On clAppService port, the first identity reads *ApplicationServiceSendMessageResponse*.




###### Step 6:

Both identities then starts a message processing loop that will handle incoming messages 
over the established call. This means that for every *ApplicationServiceReceiveMessageNotificationRequest* 
message they receive, they will reply with corresponding *ApplicationServiceReceiveMessageNotificationResponse*.

Then each identity starts a message sending loop, in which each identity generates 100 
messages with random content of 4 to 10000 bytes and sends them to the other party with 
a random delay between 0 ms and 200 ms. 

The recipient of a such a message has to store it and when 1000 messages are received, 
it calculates an SHA256 hash from all messages concatenated together. Then the hashes 
are compared with their expected values counted in the sending loops.
                                  

  
##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.


###### Step 3:

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`


###### Step 4:

Server replies with *CallIdentityApplicationServiceResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 5:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 6:

The final hashes of messages on both sides match their expected values.





#### PS05003 - Application Service Call - Extensive Test 2

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test simulates three pairs of clients exchanging a large number of messages in an application 
service call while processing and sending message in parallel.

The implementation just runs the code of PS05002 in three parallel instances.


##### Acceptance Criteria

Same as in PS05002, just considering three pairs of clients.






#### PS05004 - Application Service Call - Extensive Test 3

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test simulates two pairs of clients exchanging a large number of messages in an application 
service call while processing and sending message in parallel.

The implementation just runs the code of PS05002 in two parallel instances.

The difference over PS05003 here is that in this test the callee is the same for both pairs.


##### Acceptance Criteria

Same as in PS05002, just considering two pairs of clients.







#### PS05005 - Disconnection of Inactive TCP Client from AppService Port

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * Server's clNonCustomer port != srNeighbor port

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test simulates two clients exchanging a couple of messages in an application service call 
and then they wait 180 seconds without sending a message, which is followed by an attempt 
to send next message. This should fail as the clients should be disconnected due to inactivity.


###### Step 1:

The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 3:

The first identity reads the incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse*.

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized


###### Step 4:

The second identity reads the response in form of *CallIdentityApplicationServiceResponse*:

  * `$callerToken := CallIdentityApplicationServiceResponse.callerToken`

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and reads the response. Then it terminates the connection to clNonCustomer port.


###### Step 5:

On clAppService port, the first identity reads *ApplicationServiceSendMessageResponse*.


###### Step 6:

The second identity sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #1 to callee."`


###### Step 7:

On clAppService port, the first identity reads *ApplicationServiceReceiveMessageNotificationRequest* (#1 to callee).

Then it sends *ApplicationServiceReceiveMessageNotificationResponse*. 

And then it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #1 to CALLER."`


###### Step 8:

The second identity reads *ApplicationServiceSendMessageResponse* (#1 to callee received).

Then it reads *ApplicationServiceReceiveMessageNotificationRequest* (#1 to CALLER).

Then it sends *ApplicationServiceReceiveMessageNotificationResponse*. 


###### Step 9:

The first identity reads *ApplicationServiceSendMessageResponse* (#1 to CALLER received).

Then both identities do nothing for 180 seconds.


###### Step 10:

The second identity sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 3`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #2 to callee."`

and reads the response. 


###### Step 11:

On clAppService, the first identity sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 3`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #2 to CALLER."`

and reads the response. 


  
##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.


###### Step 3:

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`


###### Step 4:

Server replies with *CallIdentityApplicationServiceResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 5:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 6:

Nothing to check.


###### Step 7:

Server sends *ApplicationServiceReceiveMessageNotificationRequest*:

  * `SingleRequest.version == [1,0,0]`
  * `ApplicationServiceReceiveMessageNotificationRequest.message == "Message #1 to callee."`


###### Step 8:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 2`
  * `SingleResponse.version == [1,0,0]`
  * `Response.status == STATUS_OK`

Server sends *ApplicationServiceReceiveMessageNotificationRequest*:

  * `SingleRequest.version == [1,0,0]`
  * `ApplicationServiceReceiveMessageNotificationRequest.message == "Message #1 to CALLER."`


###### Step 9:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 2`
  * `SingleResponse.version == [1,0,0]`
  * `Response.status == STATUS_OK`


###### Step 10:

Server disconnects the second identity and this prevents it to send the message or read a response.


###### Step 11:

Server disconnects the first identity and this prevents it to send the message or read a response.














#### PS05006 - Call Identity Application Service - Not Available 1

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's primary port

##### Description 

The test tries to call identity which is not online.

###### Step 1:

The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`

and reads the response.

##### Acceptance Criteria

###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 


###### Step 2:

The test successfully verifies its second identity.

Server replies with *Response*:

  * `Message.id == 3`
  * `Response.status == ERROR_NOT_AVAILABLE`






#### PS05007 - Call Identity Application Service - Not Available 2

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's primary port

##### Description 

The test tries to call identity which is online, but it does not reply to incoming call requests.

###### Step 1:

The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`

and reads the response.


##### Acceptance Criteria

###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.

Server replies with *Response*:

  * `Message.id == 3`
  * `Response.status == ERROR_NOT_AVAILABLE`














#### PS05008 - Call Identity Application Service - Not Available 3

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's primary port

##### Description 

The test tries to call identity which is online, but it disconnects.

###### Step 1:

The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 3:

After waiting 2 seconds, the first identity disconnects.


###### Step 4:

The second identity reads the response.


##### Acceptance Criteria

###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.

###### Step 3:

Nothing to check.

###### Step 4:

Server replies with *Response*:

  * `Message.id == 3`
  * `Response.status == ERROR_NOT_AVAILABLE`






#### PS05009 - Call Identity Application Service - Invalid Service Name

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's primary port

##### Description 

The test tries to call identity which is online, but it does not reply to incoming call requests.

###### Step 1:

The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service Invalid"`

and reads the response.

##### Acceptance Criteria

###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.

Server replies with *Response*:

  * `Message.id == 3`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "serviceName"`








#### PS05010 - Call Identity Application Service - Rejected

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test tries to call identity which is online, but it rejects the call.


###### Step 1:

The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 3:

The first identity reads the incoming request *IncomingCallNotificationRequest*,
to which it replies with *Response*:

  * `Response.status == ERROR_REJECTED`


###### Step 4:

The second identity reads the response.


  
##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.


###### Step 3:

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`


###### Step 4:

Server replies with *Response*:

  * `Message.id == 3`
  * `Response.status == ERROR_REJECTED`














#### PS05011 - Callee Fails AppService Port Initialization - No Connection

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

A customer client is being called by a caller and it accepts the call, but then it fails to 
connect to the clAppService port.


###### Step 1:

The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 3:

The first identity reads the incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse*.


###### Step 4:

The second identity reads the response in form of *CallIdentityApplicationServiceResponse*:

  * `$callerToken := CallIdentityApplicationServiceResponse.callerToken`

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and reads the response. 


  
##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.


###### Step 3:

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`


###### Step 4:

Server replies with *CallIdentityApplicationServiceResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server replies with *Response*:

  * `Message.id == 1`
  * `Response.status == ERROR_NOT_FOUND`










#### PS05012 - Caller Fails AppService Port Initialization - No Connection

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

A customer client is being called by a caller and it accepts the call, but then the caller fails to 
connect to the clAppService port.


###### Step 1:

The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 3:

The first identity reads the incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse*.


Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized


###### Step 4:

The second identity reads the response in form of *CallIdentityApplicationServiceResponse*.


###### Step 5

The first identity reads the response.



  
##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.


###### Step 3:

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`


###### Step 4:

Server replies with *CallIdentityApplicationServiceResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`


###### Step 5:

Server replies with *Response*:

  * `Message.id == 1`
  * `Response.status == ERROR_NOT_FOUND`










#### PS05013 - Application Service Callee Disconnects After Initialization

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

A customer client is being called by a caller and it accepts the call and sends and initialization 
message over the clAppService port, but then it disconnects immediately.


###### Step 1:

The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 3:

The first identity reads the incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse*.

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized


###### Step 4:

The second identity reads the response in form of *CallIdentityApplicationServiceResponse*:

  * `$callerToken := CallIdentityApplicationServiceResponse.callerToken`

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and reads the response. Then it terminates the connection to clNonCustomer port.


###### Step 5:

On clAppService port, the first identity reads *ApplicationServiceSendMessageResponse* and disconnects.


###### Step 6:

After waiting 2 seconds, the second identity sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #1 to callee."`

and reads the response. 


  
##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.


###### Step 3:

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`


###### Step 4:

Server replies with *CallIdentityApplicationServiceResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 5:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 6:

The client should be disconnected then and this should prevent sending the second message or receiving a response.










#### PS05014 - Application Service Callee Disconnects After Initialization 2

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

A customer client is being called by a caller and it accepts the call and sends and initialization 
message over the clAppService port, but then it disconnects after a couple of seconds.


###### Step 1:

The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 3:

The first identity reads the incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse*.

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized


###### Step 4:

The second identity reads the response in form of *CallIdentityApplicationServiceResponse*:

  * `$callerToken := CallIdentityApplicationServiceResponse.callerToken`

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and reads the response. Then it terminates the connection to clNonCustomer port.


###### Step 5:

On clAppService port, the first identity reads *ApplicationServiceSendMessageResponse*.


###### Step 6:

The second identity sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #1 to callee."`


###### Step 7:

After waiting 2 seconds, the first identity disconnects from clAppService port.


###### Step 8:

The second identity reads the response and then it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 3`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #2 to callee."`

and reads the response.



  
##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.


###### Step 3:

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`


###### Step 4:

Server replies with *CallIdentityApplicationServiceResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 5:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 6:

Nothing to check.


###### Step 7:

Nothing to check.


###### Step 8:

Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_NOT_FOUND`


The client should be disconnected then and this should prevent sending the second message or receiving a response.



















#### PS05015 - Application Service Caller Uses Invalid Token

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

A customer client is being called by a caller and it accepts the call and sends and initialization 
message over the clAppService port. The caller then uses an invalid caller's token to send a message.


###### Step 1:

The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 3:

The first identity reads the incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse*.

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized


###### Step 4:

The second identity reads the response in form of *CallIdentityApplicationServiceResponse*:

  * `$callerToken := CallIdentityApplicationServiceResponse.callerToken`

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and reads the response. Then it terminates the connection to clNonCustomer port.


###### Step 5:

On clAppService port, the first identity reads *ApplicationServiceSendMessageResponse*.


###### Step 6:

The second identity sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := SHA256("test")`
  * `ApplicationServiceSendMessageRequest.message := "Message #1 to callee."`

and reads the response. Then it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 3`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #2 to callee."`

and reads the response.

###### Step 7:

The first identity sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #1 to CALLER."`

and reads the response. 


  
##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.


###### Step 3:

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`


###### Step 4:

Server replies with *CallIdentityApplicationServiceResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 5:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 6:

Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_NOT_FOUND`

The client should be disconnected then and this should prevent sending the second message or receiving a response.

###### Step 7:

The client should be disconnected then and this should prevent sending the message or receiving a response.












#### PS05016 - Application Service First Client Late Join

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

A customer client is being called by a caller and it accepts the call, but neither of the clients 
manages to send an initialization message over the clAppService port on time.


###### Step 1:

The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 3:

The first identity reads the incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse*.


###### Step 4:

The second identity reads the response in form of *CallIdentityApplicationServiceResponse*:

  * `$callerToken := CallIdentityApplicationServiceResponse.callerToken`


###### Step 5:

The first identity establishes a new TLS connection to the clAppService port and waits 35 seconds 
and then it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized


###### Step 6:

The second identity establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and reads the response. 


###### Step 7:

The first identity reads the response.




  
##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.


###### Step 3:

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`


###### Step 4:

Server replies with *CallIdentityApplicationServiceResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`


###### Step 5:

Nothing to check.


###### Step 6:


Server replies with *Response*:

  * `Message.id == 1`
  * `Response.status == ERROR_NOT_FOUND`


###### Step 7:

Server replies with *Response*:

  * `Message.id == 1`
  * `Response.status == ERROR_NOT_FOUND`












#### PS05017 - Application Service Second Client Late Join

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

A customer client is being called by a caller and it accepts the call. Then the callee 
connects to clAppService port and sends the initialization message, but then the caller 
fails to send an initialization message over the clAppService port on time.


###### Step 1:

The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 3:

The first identity reads the incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse*.


Then it establishes a new TLS connection to the clAppService port and then it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized


###### Step 4:

The second identity reads the response in form of *CallIdentityApplicationServiceResponse*:

  * `$callerToken := CallIdentityApplicationServiceResponse.callerToken`

Then it establishes a new TLS connection to the clAppService port and waits 35 seconds and then it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and reads the response. 


###### Step 5:

The first identity reads the response.




  
##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.


###### Step 3:

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`


###### Step 4:

Server replies with *CallIdentityApplicationServiceResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`


Server replies with *Response*:

  * `Message.id == 1`
  * `Response.status == ERROR_NOT_FOUND`


###### Step 5:

Server replies with *Response*:

  * `Message.id == 1`
  * `Response.status == ERROR_NOT_FOUND`















#### PS05018 - Application Service Callee Closes Connection

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test simulates two clients exchanging a couple of messages in an application service call 
and then the callee closes the connection, while the caller still wants to send a message.


###### Step 1:

The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 3:

The first identity reads the incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse*.

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized


###### Step 4:

The second identity reads the response in form of *CallIdentityApplicationServiceResponse*:

  * `$callerToken := CallIdentityApplicationServiceResponse.callerToken`

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and reads the response. Then it terminates the connection to clNonCustomer port.


###### Step 5:

On clAppService port, the first identity reads *ApplicationServiceSendMessageResponse*.


###### Step 6:

The second identity sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #1 to callee."`


###### Step 7:

On clAppService port, the first identity reads *ApplicationServiceReceiveMessageNotificationRequest* (#1 to callee).

Then it sends *ApplicationServiceReceiveMessageNotificationResponse*. 

And then it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #1 to CALLER."`

and disconnects.


###### Step 8:

After a 5 second wait, the second identity reads *ApplicationServiceSendMessageResponse* (#1 to callee received).

Then it reads *ApplicationServiceReceiveMessageNotificationRequest* (#1 to CALLER).

Then it sends *ApplicationServiceReceiveMessageNotificationResponse*. 

Then it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 3`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #2 to callee."`

and reads the response. 


  
##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.


###### Step 3:

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`


###### Step 4:

Server replies with *CallIdentityApplicationServiceResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 5:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 6:

Nothing to check.


###### Step 7:

Server sends *ApplicationServiceReceiveMessageNotificationRequest*:

  * `SingleRequest.version == [1,0,0]`
  * `ApplicationServiceReceiveMessageNotificationRequest.message == "Message #1 to callee."`


###### Step 8:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 2`
  * `SingleResponse.version == [1,0,0]`
  * `Response.status == STATUS_OK`

Server sends *ApplicationServiceReceiveMessageNotificationRequest*:

  * `SingleRequest.version == [1,0,0]`
  * `ApplicationServiceReceiveMessageNotificationRequest.message == "Message #1 to CALLER."`


Server disconnects the second identity and this prevents it to either send *ApplicationServiceReceiveMessageNotificationResponse* 
or send *ApplicationServiceSendMessageRequest* message or read a response.










#### PS05019 - Application Service Callee Disconnects Administrative Connection

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

A customer client is called using application service. It accepts the call and immediately 
disconnects from clCustomerPort. The caller receives notification about the accepted call 
and immediately disconnects from clNonCustomer port. Then they exchange messages over clAppService port.


###### Step 1:

The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 3:

The first identity reads the incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse* and disconnects and waits 3 seconds.


###### Step 4:

The second identity reads the response in form of *CallIdentityApplicationServiceResponse*:

  * `$callerToken := CallIdentityApplicationServiceResponse.callerToken`

and disconnects and waits 3 seconds.

###### Step 5:

The first identity establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized


###### Step 6:

The second identity establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and reads the response. 


###### Step 7:

On clAppService port, the first identity reads *ApplicationServiceSendMessageResponse*.


###### Step 8:

The second identity sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #1 to callee."`


###### Step 9:

The first identity reads *ApplicationServiceReceiveMessageNotificationRequest* (#1 to callee).

Then it sends *ApplicationServiceReceiveMessageNotificationResponse*. 

And then it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #1 to CALLER."`


###### Step 10:

The second identity reads *ApplicationServiceSendMessageResponse* (#1 to callee received).

Then it reads *ApplicationServiceReceiveMessageNotificationRequest* (#1 to CALLER).

Then it sends *ApplicationServiceReceiveMessageNotificationResponse*. 


###### Step 11:

The first identity reads *ApplicationServiceSendMessageResponse* (#1 to CALLER received).



  
##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.


###### Step 3:

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`


###### Step 4:

Server replies with *CallIdentityApplicationServiceResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`


###### Step 5:

Nothing to check.


###### Step 6:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 7:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 8:

Nothing to check.


###### Step 9:


Server sends *ApplicationServiceReceiveMessageNotificationRequest*:

  * `SingleRequest.version == [1,0,0]`
  * `ApplicationServiceReceiveMessageNotificationRequest.message == "Message #1 to callee."`


###### Step 10:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 2`
  * `SingleResponse.version == [1,0,0]`
  * `Response.status == STATUS_OK`

Server sends *ApplicationServiceReceiveMessageNotificationRequest*:

  * `SingleRequest.version == [1,0,0]`
  * `ApplicationServiceReceiveMessageNotificationRequest.message == "Message #1 to CALLER."`


###### Step 11:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 2`
  * `SingleResponse.version == [1,0,0]`
  * `Response.status == STATUS_OK`










#### PS05020 - Application Service Call - No Message Confirmation

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * Server's clNonCustomer port != srNeighbor port

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test simulates two clients with an open application service call, in which the caller 
sends messages to the callee, but the callee does not confirm them. 


###### Step 1:

The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 3:

The first identity reads the incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse*.

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized


###### Step 4:

The second identity reads the response in form of *CallIdentityApplicationServiceResponse*:

  * `$callerToken := CallIdentityApplicationServiceResponse.callerToken`

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and reads the response. Then it terminates the connection to clNonCustomer port.


###### Step 5:

On clAppService port, the first identity reads *ApplicationServiceSendMessageResponse*.


###### Step 6:

The second identity sends *ApplicationServiceSendMessageRequest* messages in a loop:

  * `Message.id := $i+1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #$i to callee."`

After each message sent by the second identity, the first identity always reads *ApplicationServiceReceiveMessageNotificationRequest* 
sent to it by the profile server. Then the second identity waits 10 seconds before sending the next round message.

After sending 20 messages, the second identity reads responses in a loop.


  
##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.


###### Step 3:

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`


###### Step 4:

Server replies with *CallIdentityApplicationServiceResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 5:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 6:

Some messages are delivered successfully, but then the server disconnects both identities 
and thus prevents the second identity to send all 20 messages.









#### PS05021 - Application Service Call - Too Many Pending Messages

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test simulates two clients with an open application service call, in which the caller 
sends too many messages to the callee without waiting for a confirmation. 


###### Step 1:

The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 3:

The first identity reads the incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse*.

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized


###### Step 4:

The second identity reads the response in form of *CallIdentityApplicationServiceResponse*:

  * `$callerToken := CallIdentityApplicationServiceResponse.callerToken`

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and reads the response. Then it terminates the connection to clNonCustomer port.


###### Step 5:

On clAppService port, the first identity reads *ApplicationServiceSendMessageResponse*.


###### Step 6:

The second identity sends 21 *ApplicationServiceSendMessageRequest* messages in a loop:

  * `Message.id := $i+1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #$i to callee."`

After sending 21 messages it reads the response.



  
##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.


###### Step 3:

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`


###### Step 4:

Server replies with *CallIdentityApplicationServiceResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 5:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 6:

Server replies with *Response*:
  
  * `Response.status == ERROR_NOT_FOUND`















#### PS05022 - Application Service Call - Sending Message Before Initialization Completes

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test simulates two clients with an open application service call, in which the caller
sends a message to the callee before the callee sends its initialization message.


###### Step 1:

The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 3:

The first identity reads the incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse*.


###### Step 4:

The second identity reads the response in form of *CallIdentityApplicationServiceResponse*:

  * `$callerToken := CallIdentityApplicationServiceResponse.callerToken`

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and then it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #1 to callee."`

and reads the response.



###### Step 5:

The first identity establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and reads the response.



  
##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.


###### Step 3:

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`


###### Step 4:

Server replies with *CallIdentityApplicationServiceResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server replies with *Response*:

  * `Message.id == 1`
  * `Response.status == ERROR_NOT_FOUND`


###### Step 5:

Server replies with *Response*:

  * `Message.id == 1`
  * `Response.status == ERROR_NOT_FOUND`













#### PS05023 - Application Service Call - Two Customers

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test simulates two customer clients exchanging couple of messages in an application service all.


###### Step 1:
The test creates two identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller` set to public key of the second identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller := SHA256($PubKeyCaller)` is the network ID of the second identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 

Then it uses the second identity and establishes a hosting agreement over clNonCustomer port and then 
it closes the connection. Then it checks-in the second identity over clCustomer port. The test then 
initializes its profile using *UpdateProfileRequest* and leaves the connection open. 



###### Step 2:
Over the existing connection, the second identity sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 4`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 3:
The first identity reads the incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse*.

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized


###### Step 4:

The second identity reads the response in form of *CallIdentityApplicationServiceResponse*:

  * `$callerToken := CallIdentityApplicationServiceResponse.callerToken`

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and reads the response. 


###### Step 5:

On clAppService port, the first identity reads *ApplicationServiceSendMessageResponse*.

###### Step 6:

On clAppService port, the second identity sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #1 to callee."`

And then it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 3`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #2 to callee."`

And then it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 4`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #3 to callee."`


###### Step 7:

On clAppService port, the first identity reads *ApplicationServiceReceiveMessageNotificationRequest* (#1 to callee).

Then it sends *ApplicationServiceReceiveMessageNotificationResponse*. 

Then it reads *ApplicationServiceReceiveMessageNotificationRequest* (#2 to callee).

Then it sends *ApplicationServiceReceiveMessageNotificationResponse*.

And then it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #1 to CALLER."`

Then it reads *ApplicationServiceReceiveMessageNotificationRequest* (#3 to callee).

Then it sends *ApplicationServiceReceiveMessageNotificationResponse*.

And then it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 4`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #2 to CALLER."`


###### Step 8:

On clAppService port, the second identity reads *ApplicationServiceSendMessageResponse* (#1 to callee received).

Then it reads *ApplicationServiceSendMessageResponse* (#2 to callee received).

Then it reads *ApplicationServiceReceiveMessageNotificationRequest* (#1 to CALLER).

Then it sends *ApplicationServiceReceiveMessageNotificationResponse*.

Then it reads *ApplicationServiceSendMessageResponse* (#3 to callee received). 

Then it reads *ApplicationServiceReceiveMessageNotificationRequest* (#2 to CALLER).

Then it sends *ApplicationServiceReceiveMessageNotificationResponse*.


###### Step 9:

On clAppService, the first identity reads *ApplicationServiceSendMessageResponse* (#1 to CALLER received).

Then it reads *ApplicationServiceSendMessageResponse* (#2 to CALLER received).



  
##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
The test successfully checks-in the application service for the first identity.


For the second identity, the test successfully establishes a hosting agreement.
Then the test successfully checks-in this identity and initializes its profile. 


###### Step 2:

Nothing to check.


###### Step 3:

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`


###### Step 4:

Server replies with *CallIdentityApplicationServiceResponse*:

  * `Message.id == 4`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 5:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 6:

Nothing to check.


###### Step 7:

Server sends *ApplicationServiceReceiveMessageNotificationRequest*:

  * `SingleRequest.version == [1,0,0]`
  * `ApplicationServiceReceiveMessageNotificationRequest.message == "Message #1 to callee."`

Server sends *ApplicationServiceReceiveMessageNotificationRequest*:

  * `SingleRequest.version == [1,0,0]`
  * `ApplicationServiceReceiveMessageNotificationRequest.message == "Message #2 to callee."`

Server sends *ApplicationServiceReceiveMessageNotificationRequest*:

  * `SingleRequest.version == [1,0,0]`
  * `ApplicationServiceReceiveMessageNotificationRequest.message == "Message #3 to callee."`


###### Step 8:


Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 2`
  * `SingleResponse.version == [1,0,0]`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 3`
  * `SingleResponse.version == [1,0,0]`
  * `Response.status == STATUS_OK`

Server sends *ApplicationServiceReceiveMessageNotificationRequest*:

  * `SingleRequest.version == [1,0,0]`
  * `ApplicationServiceReceiveMessageNotificationRequest.message == "Message #1 to CALLER."`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 4`
  * `SingleResponse.version == [1,0,0]`
  * `Response.status == STATUS_OK`

Server sends *ApplicationServiceReceiveMessageNotificationRequest*:

  * `SingleRequest.version == [1,0,0]`
  * `ApplicationServiceReceiveMessageNotificationRequest.message == "Message #2 to CALLER."`



###### Step 9:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 2`
  * `SingleResponse.version == [1,0,0]`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 4`
  * `SingleResponse.version == [1,0,0]`
  * `Response.status == STATUS_OK`










#### PS05024 - Application Service Callee Uses Same Connection Twice

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test simulates a callee accepting calls from two different callers but only using 
one TCP connection to clAppService port, which is forbidden.


###### Step 1:

The test creates three identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller1` set to public key of the second identity
  * `$PubKeyCaller2` set to public key of the third identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller1 := SHA256($PubKeyCaller1)` is the network ID of the second identity
  * `$IdentityIdCaller2 := SHA256($PubKeyCaller2)` is the network ID of the third identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`

Using its third identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 3:

The first identity reads the incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken1 := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse*.

Then it reads the second incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken2 := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse*.


Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken1`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized


###### Step 4:

The second identity reads the response in form of *CallIdentityApplicationServiceResponse*:

  * `$callerToken := CallIdentityApplicationServiceResponse.callerToken`

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and reads the response. 


###### Step 5:

On clAppService port, the first identity reads *ApplicationServiceSendMessageResponse*.


###### Step 6:

The second identity sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken`
  * `ApplicationServiceSendMessageRequest.message := "Message #1 to callee."`



###### Step 7:

On clAppService port, the first identity reads *ApplicationServiceReceiveMessageNotificationRequest* (#1 to callee).

Then it sends *ApplicationServiceReceiveMessageNotificationResponse*. 

And then after 3 second wait, it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken2`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and reads the response.


###### Step 8:

The third identity reads the response.


###### Step 9:

The second identity reads *ApplicationServiceSendMessageResponse* (#1 to callee received).




  
##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.
The test successfully verifies its third identity.


###### Step 3:

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller1`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller2`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`


###### Step 4:

Server replies with *CallIdentityApplicationServiceResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 5:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 6:

Nothing to check.


###### Step 7:

Server sends *ApplicationServiceReceiveMessageNotificationRequest*:

  * `ApplicationServiceReceiveMessageNotificationRequest.message == "Message #1 to callee."`

Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_NOT_FOUND`


###### Step 8:

Either the Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `SingleResponse.version == [1,0,0]`
  * `Response.status == ERROR_NOT_FOUND`

or the third client will be disconnected and will fail to read the response.


###### Step 9:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 2`
  * `SingleResponse.version == [1,0,0]`
  * `Response.status == STATUS_OK`









#### PS05025 - Application Service Callee Uses Same Connection Twice 2

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test simulates a callee accepting calls from two different callers but only using 
one TCP connection to clAppService port, which is forbidden. The difference over PS05024 
is that in this test, both calls are initialized properly and the callee mixes 
the connections after the initialization, not during the initialization.


###### Step 1:

The test creates three identities:

  * `$PubKeyCallee` set to public key of the first identity
  * `$PubKeyCaller1` set to public key of the second identity
  * `$PubKeyCaller2` set to public key of the third identity
  * `$IdentityIdCallee := SHA256($PubKeyCallee)` is the network ID of the first identity
  * `$IdentityIdCaller1 := SHA256($PubKeyCaller1)` is the network ID of the second identity
  * `$IdentityIdCaller2 := SHA256($PubKeyCaller2)` is the network ID of the third identity

Then it connects to the profile server's primary port and obtains a list of server roles using *ListRolesRequest* 
and closes the connection. Then it uses the first identity and establishes a hosting agreement over 
clNonCustomer port and then it closes the connection. Then it checks-in the first identity over clCustomer 
port. The test then initializes its profile using *UpdateProfileRequest*. Finally, it checks-in 
application service called "Test Service" using *ApplicationServiceAddRequest* and leaves the connection 
open. 


###### Step 2:

Using its second identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`

Using its third identity, the test establishes a new TLS connection to the profile server's clNonCustomer port 
and verifies its identity using *VerifyIdentityRequest* and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := $IdentityIdCallee`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`


###### Step 3:

The first identity reads the incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken1 := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse*.

Then it reads the second incoming request *IncomingCallNotificationRequest*:

  * `$calleeToken2 := IncomingCallNotificationRequest.calleeToken`

to which it replies with *IncomingCallNotificationResponse*.


Then it establishes a new TLS connection (FIRST connection) to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken1`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized


Then it establishes a new TLS connection (SECOND connection) to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken2`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized


###### Step 4:

The second identity reads the response in form of *CallIdentityApplicationServiceResponse*:

  * `$callerToken1 := CallIdentityApplicationServiceResponse.callerToken`

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken1`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and reads the response. 



The third identity reads the response in form of *CallIdentityApplicationServiceResponse*:

  * `$callerToken2 := CallIdentityApplicationServiceResponse.callerToken`

Then it establishes a new TLS connection to the clAppService port and sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken2`
  * `ApplicationServiceSendMessageRequest.message` is uninitialized

and reads the response. 



###### Step 5:

On clAppService port, the first identity reads *ApplicationServiceSendMessageResponse*.
Then it reads *ApplicationServiceSendMessageResponse* again.


###### Step 6:

The second identity sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken1`
  * `ApplicationServiceSendMessageRequest.message := "Message #1 to callee from caller1."`



###### Step 7:

From the FIRST connection, the first identity reads *ApplicationServiceReceiveMessageNotificationRequest* (#1 to callee).

Then it sends *ApplicationServiceReceiveMessageNotificationResponse*. 

And then after 3 second wait, it sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $calleeToken2`
  * `ApplicationServiceSendMessageRequest.message := "Invalid Message"`

and reads the response.


###### Step 8:

After 3 second wait, the second identity sends *ApplicationServiceSendMessageRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ApplicationServiceSendMessageRequest.token := $callerToken1`
  * `ApplicationServiceSendMessageRequest.message := "Message #1 to callee from caller2."`

and reads the response.


###### Step 9:

The second identity reads *ApplicationServiceSendMessageResponse* (#1 to callee received).




  
##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes a hosting agreement for its first identity.
Then the test successfully checks-in this identity and initializes its profile. 
Finally, the test successfully checks-in the application service.


###### Step 2:

The test successfully verifies its second identity.
The test successfully verifies its third identity.


###### Step 3:

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller1`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`

Server sends *IncomingCallNotificationRequest*:

  * `IncomingCallNotificationRequest.callerPublicKey == $PubKeyCaller2`
  * `IncomingCallNotificationRequest.serviceName == "Test Service"`


###### Step 4:

Server replies with *CallIdentityApplicationServiceResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


Server replies with *CallIdentityApplicationServiceResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 5:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`


###### Step 6:

Nothing to check.


###### Step 7:

Server sends *ApplicationServiceReceiveMessageNotificationRequest*:

  * `ApplicationServiceReceiveMessageNotificationRequest.message == "Message #1 to callee."`

Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_NOT_FOUND`


###### Step 8:

Either the Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 1`
  * `SingleResponse.version == [1,0,0]`
  * `Response.status == ERROR_NOT_FOUND`

or the third client will be disconnected and will fail to read the response.


###### Step 9:

Server replies with *ApplicationServiceSendMessageResponse*:

  * `Message.id == 2`
  * `SingleResponse.version == [1,0,0]`
  * `Response.status == STATUS_OK`





