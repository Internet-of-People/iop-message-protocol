### PS02xxx - Client Non-Customer Port Functionality Tests

#### PS02001 - Client Non-Customer Port Ping

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 
The test sends a ping request to the profile server and expects to receive a ping response.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *PingRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `PingRequest.payload := "Hello"`

and reads the response.

##### Acceptance Criteria

###### Step 1:

Server replies with *PingResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `PingResponse.payload == "Hello"`
  * `PingResponse.clock` does not differ more than 10 minutes from the test's machine clock.









#### PS02002 - Invalid Role Request - List Roles

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test requests a list of profile server's roles on its clNonCustomer port, but *ListRolesRequest* request requires the primary port to be used.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *ListRolesRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  
and reads the response.


##### Acceptance Criteria

###### Step 1:
Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_BAD_ROLE`







#### PS02003 - Start Conversation

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test starts conversation with the profile server.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity's 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response
  
##### Acceptance Criteria

###### Step 1:
Server replies with *StartConversationResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.version == [1,0,0]`
  * `StartConversationResponse.publicKey.Length == 32`
  * `StartConversationResponse.challenge.Length == 32`
  * `StartConversationResponse.clientChallenge == $ClientChallenge`












#### PS02004 - Start Conversation - Unsupported Version

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test starts the conversation with the profile server but no version of the protocol is supported by both sides.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[255,255,255], [255,255,254]]`
  * `StartConversationRequest.publicKey` set to the test identity's 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:
Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_UNSUPPORTED`







#### PS02005 - Register Hosting Request

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test identity establishes a hosting agreement with the profile server. Note that the profile server contract is empty at this stage.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity's 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract` is uninitialized

and reads the response.

  
##### Acceptance Criteria

###### Step 1:
Server replies with *StartConversationResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.version == [1,0,0]`
  * `StartConversationResponse.publicKey.Length == 32`
  * `StartConversationResponse.challenge.Length == 32`
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`








#### PS02006 - Register Hosting Request - Bad Conversation Status

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test sends *RegisterHostingRequest* to the profile server without starting the conversation first.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *RegisterHostingRequest*:

  * `Message.id := 1`
  * `RegisterHostingRequest.contract` is uninitialized
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:
Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_BAD_CONVERSATION_STATUS`







#### PS02007 - Register Hosting Request - Quota Exceeded

##### Prerequisites/Inputs

###### Prerequisites:
  * Server is configured to host 1 identity at maximum.
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test identity #1 establishes a hosting agreement with the profile server. Then the test tries to establish a hosting agreement for its identity #2, which should fail due to the profile server's quota.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity #1 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract` is uninitialized
  
and reads the response.
  
###### Step 2:
The test then closes the connection and creates a new TLS connection to the clNonCustomer port and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity #2 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract` is uninitialized

and reads the response.
  
##### Acceptance Criteria


###### Step 1:

Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`


Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_QUOTA_EXCEEDED`












#### PS02008 - Register Hosting Request - Already Exists

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test establishes a hosting agreement with the profile server. Then it tries to establish a new agreement with the same identity, which should fail.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract` is uninitialized

and reads the response.
 
###### Step 2:
The test then closes the connection and creates a new TLS connection to the clNonCustomer port and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract` is uninitialized

and reads the response.

##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`
                                                                  
Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_ALREADY_EXISTS`








#### PS02009 - Verify Identity

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer

##### Description 

The test establishes a conversation with the profile server and verifies its public key by signing a challenge.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *VerifyIdentityResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`








#### PS02010 - Verify Identity - Invalid Signature

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer

##### Description 

The test establishes a conversation with the profile server and tries to verify its public key by signing a challenge, but it provides invalid signature.

###### Step 1:
The test establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the profile server in form of *StartConversationResponse*:
  
  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key, but the first byte of the signature is XORed with 0x12 to make the signature invalid.
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`


Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_SIGNATURE`







#### PS02011 - Verify Identity - Invalid Challenge

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  
###### Inputs:
  * Server's IP address
  * Server's clNonCustomer

##### Description 

The test establishes a conversation with the profile server and tries to verify its public key by signing a challenge, but it provides invalid challenge.

###### Step 1:
The test establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the profile server in form of *StartConversationResponse*:
  
  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`, but the first byte of the challenge is XORed with 0x12 to make the challenge invalid
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`


Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "challenge"`








#### PS02012 - Verify Identity - Bad Conversation Status

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test sends verify identity request to the profile server without starting the conversation first.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *VerifyIdentityRequest*:

  * `Message.id := 1`
  * `VerifyIdentityRequest.challenge` is uninitialized
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:
Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_BAD_CONVERSATION_STATUS`








#### PS02013 - Parallel Verify Identity Requests

##### Prerequisites/Inputs
###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test verifies its identity and then it verifies its identity again in a second parallel connection. Then it verifies that the first connection is still active by sending a ping.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response.

###### Step 2:
With the first connection left open, the test establishes a new TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response.

###### Step 3:

Using the first connection the test attempts to send *PingRequest*:

  * `Message.id := 3`
  * `SingleRequest.version := [1,0,0]`
  * `PingRequest.payload = "test"`
  
and reads the response.


##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *VerifyIdentityResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *VerifyIdentityResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

###### Step 3:

Server replies with *PingResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`
  * `PingResponse.payload == "test"`










#### PS02014 - Check-In - Bad Role

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's clNonCustomer port != clCustomer port

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test sends check-in request to the clNonCustomer port, but *CheckInRequest* requires clCustomer port to be used.

###### Step 1:

The test connects to the primary port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity's 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
 
and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response.


##### Acceptance Criteria

###### Step 1:

Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *Response*:
  
  * `Message.id == 2`
  * `Response.status == ERROR_BAD_ROLE`








#### PS02015 - Get Identity Information - Uninitialized

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test establishes a hosting agreement with the profile server and attempts to query its details, which should fail as the new profile is not initialized yet.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract` is uninitialized
  
and reads the response. The test it sends *GetIdentityInformationRequest*:

  * `Message.id := 3`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId` is set to SHA256 of test's identity public key
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := false`
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *Response*:

  * `Message.id == 3`
  * `Response.status == ERROR_UNINITIALIZED`








#### PS02016 - Get Identity Information - Unknown Identity

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test queries details about identity that is not hosted on the profile server.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *GetIdentityInformationRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId := SHA256("test")`
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := false`
  
and reads the response. 
  
##### Acceptance Criteria


###### Step 1:
Server replies with *Response*:

  * `Message.id == 1`
  * `Response.status == ERROR_NOT_FOUND`










#### PS02017 - Verify Identity, Update Profile - Bad Role

##### Prerequisites/Inputs
###### Prerequisites:
  * Server's clNonCustomer port != clCustomer port

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test verifies its identity on clNonCustomer port. Then it attempts to update its profile, which requires clCustomer port and Authenticated status.


###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`


Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract` is uninitialized
  
and reads the response. Then it sends *VerifyIdentityRequest*:

  * `Message.id := 3`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 4`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 0`
  * `UpdateProfileRequest.longitude := 0`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response.


##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *VerifyIdentityResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server replies with *Response*:

  * `Message.id == 4`
  * `Response.status == ERROR_BAD_ROLE`









#### PS02018 - Call Identity Application Service - Unauthorized 1

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test sends *CallIdentityApplicationServiceRequest* to the profile server without starting the conversation first.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 1`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := SHA256("test")`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:
Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_UNAUTHORIZED`







#### PS02019 - Call Identity Application Service - Unauthorized 2

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test sends *CallIdentityApplicationServiceRequest* to the profile server without verifying its identity firts.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response. Then it sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 2`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := SHA256("test")`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *Response*:
  
  * `Message.id == 2`
  * `Response.status == ERROR_UNAUTHORIZED`








#### PS02020 - Call Identity Application Service - Invalid Id

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer

##### Description 

The test tries to call identity that is not hosted on the profile server.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := SHA256("test")`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *VerifyIdentityResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *Response*:
  
  * `Message.id == 3`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "identityNetworkId"`







#### PS02021 - Call Identity Application Service - Uninitialized

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer

##### Description 

The test tries to call identity which profile has not been initialized yet.

###### Step 1:

The test creates a first identity and establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`


Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract` is uninitialized
  
and reads the response and then closes the connection.


###### Step 2:
The test creates a second identity and using it it establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`
  
and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId` is set to network ID of the first identity
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`
  
and reads the response.

  
##### Acceptance Criteria

###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *VerifyIdentityResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *Response*:
  
  * `Message.id == 3`
  * `Response.status == ERROR_UNINITIALIZED`











#### PS02022 - Start Conversation - Invalid Challenge

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test starts the conversation with the profile server but it sends invalid client challenge in the requests.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity's 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 4 byte random challenge
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:
Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "clientChallenge"`








#### PS02023 - Profile Stats - No Profile Initialization

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test creates 10 new identities and establishes hosting agreements for all of them, but does not initialize their profiles. Then it asks the profile server for profile statistics.


###### Step 1:

The test creates 8 identities with following identity types:

  * 2x "Type A"
  * 3x "Type B"
  * 1x "Type Alpha"
  * 1x "Type A B"
  * 1x "Type Beta"

and then with each identity it connects to clNonCustomer port and establishes a hosting agreement.

The test establishes a new TLS connection to clNonCustomer and sends *ProfileStatsRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`

and reads the response.


###### Step 2:

The test creates 2 more identities with following identity types:

  * 1x `Type A B`
  * 1x `Type C`

and then with each identity it connects to clNonCustomer port and establishes a hosting agreement. 

Then it reuses the previous connection used for sending *ProfileStatsRequest* and sends *ProfileStatsRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`

and reads the response.


  
##### Acceptance Criteria

###### Step 1:

Test successfully establishes the hosting agreements.

Server replies with *ProfileStatsResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ProfileStatsResponse.stats.Count == 0`
  * `ProfileStatsResponse.stats is empty`


###### Step 2:

Test successfully establishes the hosting agreements.

Server replies with *ProfileStatsResponse*:
  
  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `ProfileStatsResponse.stats.Count == 0`
  * `ProfileStatsResponse.stats is empty`






#### PS02024 - Profile Stats - No Stats

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test asks the profile server for profile statistics when profile server has an empty database.


###### Step 1:

The test establishes a new TLS connection to clNonCustomer and sends *ProfileStatsRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`

and reads the response.


  
##### Acceptance Criteria

###### Step 1:

Server replies with *ProfileStatsResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ProfileStatsResponse.stats.Count == 0`






#### PS02025 - Profile Search - Bad Conversation Status

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test sends *ProfileSearchRequest* request to the profile server without starting the conversation first.

###### Step 1:

The test connects to the primary port of the profile server and sends *ProfileSearchRequest*:

  * `Message.id := 1`
  * `ProfileSearchRequest.includeHostedOnly := false`
  * `ProfileSearchRequest.includeThumbnailImages := true`
  * `ProfileSearchRequest.maxResponseRecordCount := 100`
  * `ProfileSearchRequest.maxTotalRecordCount := 1000`
  * `ProfileSearchRequest.type := ""`
  * `ProfileSearchRequest.name := ""`
  * `ProfileSearchRequest.latitude := NO_LOCATION`
  * `ProfileSearchRequest.longitude := NO_LOCATION`
  * `ProfileSearchRequest.radius := 0`
  * `ProfileSearchRequest.extraData := ""`

and reads the response.


##### Acceptance Criteria

###### Step 1:

Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_BAD_CONVERSATION_STATUS`





#### PS02026 - Profile Search Part - Bad Conversation Status

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test sends *ProfileSearchPartRequest* request to the profile server without starting the conversation first.

###### Step 1:

The test connects to the primary port of the profile server and sends *ProfileSearchPartRequest*:

  * `Message.id := 1`
  * `ProfileSearchPartRequest.recordIndex := 0`
  * `ProfileSearchPartRequest.recordCount := 10`
 
and reads the response.


##### Acceptance Criteria

###### Step 1:

Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_BAD_CONVERSATION_STATUS`





#### PS02027 - Start Conversation - Invalid Public Key

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test starts the conversation with the profile server but it uses invalid public key.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey := []`
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge
  
and reads the response. Then it sends *StartConversationRequest*:

  * `Message.id := 2`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to array of 130x 0x40 
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:

Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "publicKey"`


Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "publicKey"`



