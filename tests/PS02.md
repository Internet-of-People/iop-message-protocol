### PS02xxx - Client Non-Customer Port Functionality Tests

#### PS02001 - Client Non-Customer Port Ping

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 
The test sends a ping request to the profile server and expects to receive a ping response.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *PingRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `PingRequest.payload := "Hello"`

and reads the response.

##### Acceptance Criteria

###### Step 1:

Server replies with *PingResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `PingResponse.payload == "Hello"`
  * `PingResponse.clock` does not differ more than 10 minutes from the test's machine clock.









#### PS02002 - Invalid Role Request - List Roles

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test requests a list of profile server's roles on its clNonCustomer port, but *ListRolesRequest* request requires the primary port to be used.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *ListRolesRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  
and reads the response.


##### Acceptance Criteria

###### Step 1:

Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_BAD_ROLE`







#### PS02003 - Start Conversation

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test starts conversation with the profile server.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response
  
##### Acceptance Criteria

###### Step 1:
Server replies with *StartConversationResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.version == [1,0,0]`
  * `StartConversationResponse.publicKey.Length == 32`
  * `StartConversationResponse.challenge.Length == 32`
  * `StartConversationResponse.clientChallenge == $ClientChallenge`









#### PS02004 - Start Conversation - Unsupported Version

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test starts the conversation with the profile server but no version of the protocol is supported by both sides.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[255,255,255], [255,255,254]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:
Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_UNSUPPORTED`







#### PS02005 - Register Hosting Request

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test identity establishes a hosting agreement with the profile server. Note that the profile server contract plan is empty at this stage.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`

and reads the response.

  
##### Acceptance Criteria

###### Step 1:
Server replies with *StartConversationResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.version == [1,0,0]`
  * `StartConversationResponse.publicKey.Length == 32`
  * `StartConversationResponse.challenge.Length == 32`
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `RegisterHostingResponse.contract` is same as `RegisterHostingRequest.contract` the client sent
  * `ConversationResponse.signature` is a valid signature of `RegisterHostingResponse.contract`








#### PS02006 - Register Hosting Request - Bad Conversation Status

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test sends *RegisterHostingRequest* to the profile server without starting the conversation first.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *RegisterHostingRequest*:

  * `Message.id := 1`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:
Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_BAD_CONVERSATION_STATUS`







#### PS02007 - Register Hosting Request - Quota Exceeded

##### Prerequisites/Inputs

###### Prerequisites:
  * Server is configured to host 1 identity at maximum.
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test identity #1 establishes a hosting agreement with the profile server. Then the test tries to establish a hosting agreement for its identity #2, which should fail due to the profile server's quota.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity #1 public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity #1 public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`
  
and reads the response.
  
###### Step 2:
The test then closes the connection and creates a new TLS connection to the clNonCustomer port and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity #2 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity #2 public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`

and reads the response.
  
##### Acceptance Criteria


###### Step 1:

Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`


Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `RegisterHostingResponse.contract` is same as `RegisterHostingRequest.contract` the client sent
  * `ConversationResponse.signature` is a valid signature of `RegisterHostingResponse.contract`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_QUOTA_EXCEEDED`












#### PS02008 - Register Hosting Request - Already Exists

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test establishes a hosting agreement with the profile server. Then it tries to establish a new agreement with the same identity, which should fail.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`

and reads the response.
 
###### Step 2:
The test then closes the connection and creates a new TLS connection to the clNonCustomer port and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`

and reads the response.

##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `RegisterHostingResponse.contract` is same as `RegisterHostingRequest.contract` the client sent
  * `ConversationResponse.signature` is a valid signature of `RegisterHostingResponse.contract`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`
                                                                  
Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_ALREADY_EXISTS`








#### PS02009 - Verify Identity

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test establishes a conversation with the profile server and verifies its public key by signing a challenge.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *VerifyIdentityResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`








#### PS02010 - Verify Identity - Invalid Signature

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test establishes a conversation with the profile server and tries to verify its public key by signing a challenge, but it provides invalid signature.


###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the profile server in form of *StartConversationResponse*:
  
  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key, but the first byte of the signature is XORed with 0x12 to make the signature invalid.
  
and reads the response and closes the connection.


###### Step 2:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the profile server in form of *StartConversationResponse*:
  
  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature := [1,2,3]`
  
and reads the response and closes the connection.


###### Step 3:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the profile server in form of *StartConversationResponse*:
  
  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to array of 200 bytes 0x12
  
and reads the response and closes the connection.

  
##### Acceptance Criteria


###### Step 1:

Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`


Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_SIGNATURE`


###### Step 2:

Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`


Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_SIGNATURE`


###### Step 3:

Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`


Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_SIGNATURE`







#### PS02011 - Verify Identity - Invalid Challenge

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  
###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test establishes a conversation with the profile server and tries to verify its public key by signing a challenge, but it provides invalid challenge.


###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the profile server in form of *StartConversationResponse*:
  
  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`, but the first byte of the challenge is XORed with 0x12 to make the challenge invalid
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response and closes the connection.



###### Step 2:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the profile server in form of *StartConversationResponse*:
  
  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := [1,2,3]`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response and closes the connection.



###### Step 3:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the profile server in form of *StartConversationResponse*:
  
  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge` set to array of 60 bytes 0x12
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response and closes the connection.

  
##### Acceptance Criteria


###### Step 1:

Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`


Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "challenge"`


###### Step 2:

Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`


Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "challenge"`


###### Step 3:

Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`


Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "challenge"`








#### PS02012 - Verify Identity - Bad Conversation Status

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test sends verify identity request to the profile server without starting the conversation first.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *VerifyIdentityRequest*:

  * `Message.id := 1`
  * `VerifyIdentityRequest.challenge` is uninitialized
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:
Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_BAD_CONVERSATION_STATUS`








#### PS02013 - Parallel Verify Identity Requests

##### Prerequisites/Inputs
###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test verifies its identity and then it verifies its identity again in a second parallel connection. Then it verifies that the first connection is still active by sending a ping.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response.

###### Step 2:
With the first connection left open, the test establishes a new TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response.

###### Step 3:

Using the first connection the test attempts to send *PingRequest*:

  * `Message.id := 3`
  * `SingleRequest.version := [1,0,0]`
  * `PingRequest.payload = "test"`
  
and reads the response.


##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *VerifyIdentityResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *VerifyIdentityResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

###### Step 3:

Server replies with *PingResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`
  * `PingResponse.payload == "test"`










#### PS02014 - Check-In - Bad Role

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's clNonCustomer port != clCustomer port

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test sends check-in request to the clNonCustomer port, but *CheckInRequest* requires clCustomer port to be used.

###### Step 1:

The test connects to the primary port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
 
and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response.


##### Acceptance Criteria

###### Step 1:

Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *Response*:
  
  * `Message.id == 2`
  * `Response.status == ERROR_BAD_ROLE`








#### PS02015 - Get Identity Information - Uninitialized

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test establishes a hosting agreement with the profile server and attempts to query its details, which should fail as the new profile is not initialized yet.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`
  
and reads the response. The test it sends *GetProfileInformationRequest*:

  * `Message.id := 3`
  * `SingleRequest.version := [1,0,0]`
  * `GetProfileInformationRequest.identityNetworkId` is set to SHA256 of test's identity public key
  * `GetProfileInformationRequest.includeProfileImage := false`
  * `GetProfileInformationRequest.includeThumbnailImage := false`
  * `GetProfileInformationRequest.includeApplicationServices := false`
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `RegisterHostingResponse.contract` is same as `RegisterHostingRequest.contract` the client sent
  * `ConversationResponse.signature` is a valid signature of `RegisterHostingResponse.contract`

Server replies with *Response*:

  * `Message.id == 3`
  * `Response.status == ERROR_UNINITIALIZED`








#### PS02016 - Get Identity Information - Unknown Identity

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test queries details about identity that is not hosted on the profile server.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *GetProfileInformationRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `GetProfileInformationRequest.identityNetworkId := SHA256("test")`
  * `GetProfileInformationRequest.includeProfileImage := false`
  * `GetProfileInformationRequest.includeThumbnailImage := false`
  * `GetProfileInformationRequest.includeApplicationServices := false`
  
and reads the response. 
  
##### Acceptance Criteria


###### Step 1:
Server replies with *Response*:

  * `Message.id == 1`
  * `Response.status == ERROR_NOT_FOUND`










#### PS02017 - Verify Identity, Update Profile - Bad Role

##### Prerequisites/Inputs
###### Prerequisites:
  * Server's clNonCustomer port != clCustomer port

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test verifies its identity on clNonCustomer port. Then it attempts to update its profile, which requires clCustomer port and Authenticated status.


###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`


Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`
  
and reads the response. Then it sends *VerifyIdentityRequest*:

  * `Message.id := 3`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 4`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Identity"`
  * `UpdateProfileRequest.profile.latitude := 0`
  * `UpdateProfileRequest.profile.longitude := 0`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response.


##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `RegisterHostingResponse.contract` is same as `RegisterHostingRequest.contract` the client sent
  * `ConversationResponse.signature` is a valid signature of `RegisterHostingResponse.contract`

Server replies with *VerifyIdentityResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server replies with *Response*:

  * `Message.id == 4`
  * `Response.status == ERROR_BAD_ROLE`









#### PS02018 - Call Identity Application Service - Unauthorized 1

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test sends *CallIdentityApplicationServiceRequest* to the profile server without starting the conversation first.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 1`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := SHA256("test")`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:
Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_UNAUTHORIZED`







#### PS02019 - Call Identity Application Service - Unauthorized 2

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test sends *CallIdentityApplicationServiceRequest* to the profile server without verifying its identity firts.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response. Then it sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 2`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := SHA256("test")`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *Response*:
  
  * `Message.id == 2`
  * `Response.status == ERROR_UNAUTHORIZED`








#### PS02020 - Call Identity Application Service - Invalid Id

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test tries to call identity that is not hosted on the profile server.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := SHA256("test")`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *VerifyIdentityResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *Response*:
  
  * `Message.id == 3`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "identityNetworkId"`







#### PS02021 - Call Identity Application Service - Uninitialized

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test tries to call identity which profile has not been initialized yet.

###### Step 1:

The test creates a first identity and establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`


Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`
  
and reads the response and then closes the connection.


###### Step 2:
The test creates a second identity and using it it establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`
  
and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId` is set to network ID of the first identity
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`
  
and reads the response.

  
##### Acceptance Criteria

###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `RegisterHostingResponse.contract` is same as `RegisterHostingRequest.contract` the client sent
  * `ConversationResponse.signature` is a valid signature of `RegisterHostingResponse.contract`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *VerifyIdentityResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *Response*:
  
  * `Message.id == 3`
  * `Response.status == ERROR_UNINITIALIZED`











#### PS02022 - Start Conversation - Invalid Challenge

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test starts the conversation with the profile server but it sends invalid client challenge in the requests.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 4 byte random challenge
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:
Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "clientChallenge"`








#### PS02023 - Profile Stats - No Profile Initialization

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test creates 10 new identities and establishes hosting agreements for all of them, but does not initialize their profiles. Then it asks the profile server for profile statistics.


###### Step 1:

The test creates 8 identities with following identity types:

  * 2x "Type A"
  * 3x "Type B"
  * 1x "Type Alpha"
  * 1x "Type A B"
  * 1x "Type Beta"

and then with each identity it connects to clNonCustomer port and establishes a hosting agreement.

The test establishes a new TLS connection to clNonCustomer and sends *ProfileStatsRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`

and reads the response.


###### Step 2:

The test creates 2 more identities with following identity types:

  * 1x `Type A B`
  * 1x `Type C`

and then with each identity it connects to clNonCustomer port and establishes a hosting agreement. 

Then it reuses the previous connection used for sending *ProfileStatsRequest* and sends *ProfileStatsRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`

and reads the response.


  
##### Acceptance Criteria

###### Step 1:

Test successfully establishes the hosting agreements.

Server replies with *ProfileStatsResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ProfileStatsResponse.stats.Count == 0`
  * `ProfileStatsResponse.stats is empty`


###### Step 2:

Test successfully establishes the hosting agreements.

Server replies with *ProfileStatsResponse*:
  
  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `ProfileStatsResponse.stats.Count == 0`
  * `ProfileStatsResponse.stats is empty`






#### PS02024 - Profile Stats - No Stats

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test asks the profile server for profile statistics when profile server has an empty database.


###### Step 1:

The test establishes a new TLS connection to clNonCustomer and sends *ProfileStatsRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`

and reads the response.


  
##### Acceptance Criteria

###### Step 1:

Server replies with *ProfileStatsResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ProfileStatsResponse.stats.Count == 0`






#### PS02025 - Start Conversation - Invalid Public Key

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test starts the conversation with the profile server but it uses invalid public key.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey := []`
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge
  
and reads the response. Then it sends *StartConversationRequest*:

  * `Message.id := 2`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to array of 130x 0x40 
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:

Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "publicKey"`


Server replies with *Response*:
  
  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "publicKey"`





#### PS02026 - Register Hosting Request - Invalid Requests

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port

##### Description 

The test identity sends a series of invalid *RegisterHostingRequest* requests to the profile server.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response. 


###### Step 2:

Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is otherwise valid signature of `RegisterHostingRequest.contract` with first byte XORed with 0x12

and reads the response. 


###### Step 3:

Then it sends *RegisterHostingRequest*:

  * `Message.id := 3`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature := [1]`

and reads the response. 


###### Step 4:

Then it sends *RegisterHostingRequest*:

  * `Message.id := 4`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` set to an array of 300 bytes 0x12.

and reads the response. 


###### Step 5:

Then it sends *RegisterHostingRequest*:

  * `Message.id := 5`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key with first byte XORed with 0x12
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`

and reads the response. 


###### Step 6:

Then it sends *RegisterHostingRequest*:

  * `Message.id := 6`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey := [1]`
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`

and reads the response. 


###### Step 7:

Then it sends *RegisterHostingRequest*:

  * `Message.id := 7`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to an array of 300 bytes 0x12
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`

and reads the response. 


###### Step 8:

Then it sends *RegisterHostingRequest*:

  * `Message.id := 8`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key 
  * `RegisterHostingRequest.contract.startTime := 1234567890123456789`
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`

and reads the response. 


###### Step 9:

Then it sends *RegisterHostingRequest*:

  * `Message.id := 9`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key 
  * `RegisterHostingRequest.contract.startTime` is set to timestamp that is 2 hours in the past
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`

and reads the response. 


###### Step 10:

Then it sends *RegisterHostingRequest*:

  * `Message.id := 10`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key 
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := ""`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`

and reads the response. 


###### Step 11:

Then it sends *RegisterHostingRequest*:

  * `Message.id := 11`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key 
  * `RegisterHostingRequest.contract.startTime` is set to string containing 100x 'a'
  * `RegisterHostingRequest.contract.identityType := ""`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`

and reads the response. 


###### Step 12:

Then it sends *RegisterHostingRequest*:

  * `Message.id := 12`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key 
  * `RegisterHostingRequest.contract.startTime` is set to string containing 50x 'ɐ' (UTF8 code 0xc990), which consumes 2 bytes per character
  * `RegisterHostingRequest.contract.identityType := ""`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`

and reads the response.



  
##### Acceptance Criteria

###### Step 1:

Server replies with *StartConversationResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.version == [1,0,0]`
  * `StartConversationResponse.publicKey.Length == 32`
  * `StartConversationResponse.challenge.Length == 32`
  * `StartConversationResponse.clientChallenge == $ClientChallenge`


###### Step 2:

Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_SIGNATURE`


###### Step 3:

Server replies with *Response*:

  * `Message.id == 3`
  * `Response.status == ERROR_INVALID_SIGNATURE`


###### Step 4:

Server replies with *Response*:

  * `Message.id == 4`
  * `Response.status == ERROR_INVALID_SIGNATURE`


###### Step 5:

Server replies with *Response*:

  * `Message.id == 5`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "contract.identityPublicKey"`


###### Step 6:

Server replies with *Response*:

  * `Message.id == 6`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "contract.identityPublicKey"`


###### Step 7:

Server replies with *Response*:

  * `Message.id == 7`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "contract.identityPublicKey"`


###### Step 8:

Server replies with *Response*:

  * `Message.id == 8`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "contract.startTime"`


###### Step 9:

Server replies with *Response*:

  * `Message.id == 9`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "contract.startTime"`


###### Step 10:

Server replies with *Response*:

  * `Message.id == 10`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "contract.identityType"`


###### Step 11:

Server replies with *Response*:

  * `Message.id == 11`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "contract.identityType"`


###### Step 12:

Server replies with *Response*:

  * `Message.id == 12`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "contract.identityType"`



