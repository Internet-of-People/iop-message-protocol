### PS08xxx - Neighborhood Related Functionality Tests

#### PS08001 - Neighborhood Related Calls - Unauthorized

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's srNeighbor port

##### Description 

The test sends *StartNeighborhoodInitializationRequest*, *FinishNeighborhoodInitializationRequest*, *NeighborhoodSharedProfileUpdateRequest*,
*StopNeighborhoodUpdatesRequest* to the profile server without verifying its identity first.


###### Step 1:

The test connects to the srNeighbor port of the profile server and sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 1`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 1`
 
and reads the response. Then it sends *FinishNeighborhoodInitializationRequest*:

  * `Message.id := 2`

and reads the response. Then it sends *NeighborhoodSharedProfileUpdateRequest*:

  * `Message.id := 3`
  * `NeighborhoodSharedProfileUpdateRequest.items = []`

and reads the response. Then it sends *StopNeighborhoodUpdatesRequest*:

  * `Message.id := 4`

and reads the response.


##### Acceptance Criteria

###### Step 1:

Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_UNAUTHORIZED`

Server replies with *Response*:
  
  * `Message.id == 2`
  * `Response.status == ERROR_UNAUTHORIZED`

Server replies with *Response*:
  
  * `Message.id == 3`
  * `Response.status == ERROR_UNAUTHORIZED`

Server replies with *Response*:
  
  * `Message.id == 4`
  * `Response.status == ERROR_UNAUTHORIZED`








#### PS08002 - Neighborhood Initialization Process - No Profiles

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test starts the neighborhood initialization process with the profile server, which does not host any profiles.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port and connects 
to profile server's srNeighbor port and verifies its identity. 


###### Step 2:

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 1`
 
and reads the response. Then it waits for *FinishNeighborhoodInitializationRequest* message:

  * `$Id := Message.Id`

and replies with *FinishNeighborhoodInitializationResponse*:

  * `Message.id := $Id`



##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully verifies its identity.


###### Step 2:

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends *FinishNeighborhoodInitializationRequest*.
  









#### PS08003 - Neighborhood Initialization Process - Small Set

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "images/PS08003.jpg" file exists and contains JPEG image with size less than 20 kb

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test starts the neighborhood initialization process with a profile server, which hosts a small number of profiles.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test creates a primary identity which it uses to simulate another profile server and then 
it creates the following test identities, establishes hosting agreements with the profile server for them, 
and initializes their profiles:

  * $profileInfo1 is `version := [1,0,0], type := "Profile Type A", name := "Shanghai 1",   image := "images/PS08003.jpg", location := (31.23, 121.47),  extraData = null`
  * $profileInfo2 is `version := [1,0,0], type := "Profile Type A", name := "Mumbai 1",     image := "images/PS08003.jpg", location := (18.96, 72.82),   extraData = "t=running,Cycling,ice hockey,water polo"`
  * $profileInfo3 is `version := [1,0,0], type := "Profile Type A", name := "Karachi",      image := null,                 location := (24.86, 67.01),   extraData = "l=Karachi,PK;a=iop://185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969;t=traveling,cycling,running"`
  * $profileInfo4 is `version := [1,0,0], type := "Profile Type B", name := "Buenos Aires", image := "images/PS08003.jpg", location := (-34.61, -58.37), extraData = null`
  * $profileInfo5 is `version := [1,0,0], type := "Profile Type B", name := "Shanghai 2",   image := null,                 location := (31.231, 121.47), extraData = "running"`
  * $profileInfo6 is `version := [1,0,0], type := "Profile Type C", name := "Mumbai 2",     image := "images/PS08003.jpg", location := (18.961, 72.82),  extraData = "MTg1ZjhkYjMyMjcxZmUyNWY1NjFhNmZjOTM4YjJlMjY0MzA2ZWMzMDRlZGE1MTgwMDdkMTc2NDgyNjM4MTk2OQ=="`
  * $profileInfo7 is `version := [1,0,0], type := "Profile Type C", name := "Mumbai 3",     image := null,                 location := (18.961, 72.82),  extraData = "t=running;l=Mumbai,IN"`


###### Step 2:

The test connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 1`
 
and reads the response. Then it waits for *NeighborhoodSharedProfileUpdateRequest* message:

  * `$Id1 := Message.Id`

and replies with *NeighborhoodSharedProfileUpdateResponse*:

  * `Message.id := $Id1`

Then it waits for *FinishNeighborhoodInitializationRequest* message:

  * `$Id2 := Message.Id`

and replies with *FinishNeighborhoodInitializationResponse*:

  * `Message.id := $Id2`



##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes hosting agreements for its test identities.
Then the test successfully initializes all test profiles. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends *NeighborhoodSharedProfileUpdateRequest*:

  * `NeighborhoodSharedProfileUpdateRequest.items == 
    (
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage != empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage != empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage != empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage != empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
    )`

Server sends *FinishNeighborhoodInitializationRequest*.
  

















#### PS08004 - Neighborhood Initialization Process - Large Set

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "images/PS08004.jpg" file exists and contains JPEG image with size less than 20 kb

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test starts the neighborhood initialization process with a profile server, which hosts a large number of profiles.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test creates a primary identity which it uses to simulate another profile server and then 
it creates 1000 test identities, establishes hosting agreements with the profile server for them, 
and initializes their profiles.


###### Step 2:

The test connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 1`
 
and reads the response. Then it waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives information about all the test identities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message.



##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes hosting agreements for its test identities.
Then the test successfully initializes all test profiles. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about all test identities.

Server sends *FinishNeighborhoodInitializationRequest*.


  







#### PS08005 - Neighborhood Updates

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "images/PS08005.jpg" file exists and contains JPEG image with size less than 20 kb
  * "images/PS08005b.png" file exists and contains PNG image with size less than 5 kb
  * "ps.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Base port for simulated profile server


##### Description 

The test simulates a profile server instance and establishes a neighborhood relationship with the target profile server 
by invoking the neighborhood initialization process. The sets up identities on the target server and manipulates them 
in order to receive neighborhood updates from it. Then the test requests the profile server to stop sending updates 
and verifies that no more updates are sent. Finally, the test invokes the neighborhood initialization process again 
but does not complete it and verifies that no updates are coming.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test creates a primary identity which it uses to simulate another profile server and then 
it creates 50 test identities, establishes hosting agreements with the profile server for them, 
and initializes their profiles.

The test then creates a server, on which it simulates part of the profile server behavior.
The simulated profile server uses the base port ($BasePort) as its primary port and $BasePort+1 as its srNeighbor port.


###### Step 2:

The test connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := $BasePort + 1`
 
and reads the response. Then it waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives information about all the test identities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message.


###### Step 3:

The test creates 15 more identities, establishes hosting agreements with the profile server for them 
and initializes their profiles. Then it waits 20 seconds.


###### Step 4:

The test selects 15 existing identities and cancels their hosting agreements with the profile server. 
Then it waits 20 seconds.


###### Step 5:

The test selects 25 existing identities and changes their profile information on the profile server. 
Then it waits 20 seconds.


###### Step 6:

The test connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StopNeighborhoodUpdatesRequest*:

  * `Message.id := 3`

and reads the response.


###### Step 7:

The test creates 5 more identities, establishes hosting agreements with the profile server for them 
and initializes their profiles. 

The test selects 5 existing identities and cancels their hosting agreements with the profile server.

The test selects 5 existing identities and changes their profile on the profile server.

Then it waits 20 seconds.


###### Step 8:

The test connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := $BasePort + 1`
 
and reads the response. 


###### Step 9:

The test creates 5 more identities, establishes hosting agreements with the profile server for them 
and initializes their profiles. 


###### Step 10:

The test waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives information about all the test identities.


###### Step 11:

The test creates 5 more identities, establishes hosting agreements with the profile server for them 
and initializes their profiles. 


###### Step 12:

The test terminates the neighborhood initialization process by closing the connection.


###### Step 13:

The test creates 5 more identities, establishes hosting agreements with the profile server for them 
and initializes their profiles. 

Then it waits 20 seconds.




##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes hosting agreements for its test identities.
Then the test successfully initializes all test profiles. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about all test identities.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 3:

The test successfully establishes hosting agreements for the new test identities.
The test successfully initializes all new profiles. 

The simulated profile server receives neighborhood updates in form of *NeighborhoodSharedProfileUpdateRequest* 
for all the newly hosted profiles on the target profile server.


###### Step 4:

The test successfully cancels the hosting agreements of the selected identities.

The simulated profile server receives neighborhood updates in form of *NeighborhoodSharedProfileUpdateRequest* 
for all the cancelled profiles on the target profile server.


###### Step 5:

The test successfully changes the profile information of the selected identities.

The simulated profile server receives neighborhood updates in form of *NeighborhoodSharedProfileUpdateRequest* 
for all the updated profiles on the target profile server.


###### Step 6:

Server replies with *StopNeighborhoodUpdatesResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


###### Step 7:

The test successfully establishes hosting agreements for the new test identities.
The test successfully initializes all new profiles. 

The test successfully cancels the hosting agreements of the selected identities.

The test successfully changes the profile of the selected identities.

The simulated profile server does not receive any updates.


###### Step 8:

The the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


###### Step 9:

The test successfully establishes hosting agreements for the new test identities.
Then the test successfully initializes all new profiles. 


###### Step 10:

Server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about all test identities.


###### Step 11:

The test successfully establishes hosting agreements for the new test identities.
Then the test successfully initializes all new profiles. 


###### Step 12:

Nothing to check.

###### Step 13:

The test successfully establishes hosting agreements for the new test identities.
Then the test successfully initializes all new profiles. 

The simulated profile server does not receive any updates.







#### PS08006 - Neighborhood Initialization Process - Rejected

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "images/PS08006.jpg" file exists and contains JPEG image with size less than 20 kb
  * max_follower_servers_count set to 1 in the configuration file

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test simulates a profile server instance and establishes a neighborhood relationship with the target profile server 
by invoking the neighborhood initialization process. It then simulates another profile server instance and tries to establish 
a neighborhood relationship with the target profile server, but this should fail as the target server only accepts 1 neighbor.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test creates a primary identity which it uses to simulate another profile server and then 
it creates 10 test identities, establishes hosting agreements with the profile server for them, 
and initializes their profiles.


###### Step 2:

The test connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 1`
 
and reads the response. Then it waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives information about all the test identities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message. Then it closes the connection.


###### Step 3:

With another identity, the test connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 2`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 2`
 
and reads the response. 



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes hosting agreements for its test identities.
Then the test successfully initializes all test profiles. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about all test identities.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 3:

Then the test successfully verifies its identity.

Server replies with *Response*:
  
  * `Message.id == 3`
  * `Response.status == ERROR_REJECTED`








#### PS08007 - Neighborhood Initialization Process - Already Exists

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "images/PS08007.jpg" file exists and contains JPEG image with size less than 20 kb

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test simulates a profile server instance and establishes a neighborhood relationship with the target profile server 
by invoking the neighborhood initialization process. The test then tries to start the neighborhood initialization process 
again, which should fail.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test creates a primary identity which it uses to simulate another profile server and then 
it creates 10 test identities, establishes hosting agreements with the profile server for them, 
and initializes their profiles.


###### Step 2:

The test connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 1`
 
and reads the response. Then it waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives information about all the test identities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message. Then it closes the connection.


###### Step 3:

The test connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 2`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 2`
 
and reads the response. 



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes hosting agreements for its test identities.
Then the test successfully initializes all test profiles. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about all test identities.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 3:

Then the test successfully verifies its identity.

Server replies with *Response*:
  
  * `Message.id == 3`
  * `Response.status == ERROR_ALREADY_EXISTS`








#### PS08008 - Neighborhood Initialization Process - Busy

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "images/PS08008.jpg" file exists and contains JPEG image with size less than 20 kb
  * neighborhood_initialization_parallelism set to 1 in the configuration file

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test simulates a profile server instance and establishes a neighborhood relationship with the target profile server 
by invoking the neighborhood initialization process, but not completing it. It then simulates another profile server instance 
and tries to establish a neighborhood relationship with the target profile server, but this should fail as the target 
server only allows 1 unfinished neighborhood initialization process at the time. The test then finishes the first initialization 
process and then retries the second one, which should succeed.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test creates a primary identity which it uses to simulate another profile server and then 
it creates 10 test identities, establishes hosting agreements with the profile server for them, 
and initializes their profiles.


###### Step 2:

Using the first identity, the test connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 1`
 
and reads the response. 


###### Step 3:

Using the second identity, the test connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 2`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 2`
 
and reads the response. 


###### Step 4:

Using the first identity, the test waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives information about all the test identities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message. Then it closes the connection.


###### Step 5:

Using the second identity, the test connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 2`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 2`
 
and reads the response. Then it waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives information about all the test identities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message. Then it closes the connection.


##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes hosting agreements for its test identities.
Then the test successfully initializes all test profiles. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


###### Step 3:

Then the test successfully verifies its identity.

Server replies with *Response*:
  
  * `Message.id == 3`
  * `Response.status == ERROR_BUSY`


###### Step 4:

Server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about all test identities.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 5:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about all test identities.

Server sends *FinishNeighborhoodInitializationRequest*.













#### PS08009 - Neighborhood Initialization Process - Invalid Ports

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test attempts to initiate neighborhood initialization processes with invalid values.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 0`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 1`
 
and reads the response. Then it sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 4`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 0`
 
and reads the response. Then it sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 5`
  * `StartNeighborhoodInitializationRequest.primaryPort := 100000`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 1`
 
and reads the response. Then it sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 6`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 100000`
 
and reads the response. 



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 

Then the test successfully verifies its identity.

Server replies with *Response*:
  
  * `Message.id == 3`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "primaryPort"`


Server replies with *Response*:
  
  * `Message.id == 4`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "srNeighborPort"`


Server replies with *Response*:
  
  * `Message.id == 5`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "primaryPort"`


Server replies with *Response*:
  
  * `Message.id == 6`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "srNeighborPort"`







#### PS08010 - Neighborhood Initialization Process - Interrupted

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "images/PS08010.jpg" file exists and contains JPEG image with size less than 20 kb
  * neighborhood_initialization_parallelism set to 1 in the configuration file

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test simulates a profile server instance and establishes a neighborhood relationship with the target profile server 
by invoking the neighborhood initialization process, but it fails to complete it and disconnects in the middle of the session.
Then it tries again and this time the process should complete. The setting of neighborhood_initialization_parallelism to 1 
should not affect the result and the server should not block the second attempt since the client disconnected and thus terminated
the first attempt.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test creates a primary identity which it uses to simulate another profile server and then 
it creates 600 test identities, establishes hosting agreements with the profile server for them, 
and initializes their profiles.


###### Step 2:

The test then connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 1`
 
and reads the response. Then it waits for the first *NeighborhoodSharedProfileUpdateRequest* message, 
to which it replies *NeighborhoodSharedProfileUpdateResponse* message, and then it waits for the second 
*NeighborhoodSharedProfileUpdateRequest* message and disconnects.


###### Step 3:

The test then connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 1`
 
and reads the response. Then it waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives information about all the test identities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message. Then it closes the connection.



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes hosting agreements for its test identities.
Then the test successfully initializes all test profiles. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends two *NeighborhoodSharedProfileUpdateRequest* messages with information about some of the test identities.


###### Step 3:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about all test identities.

Server sends *FinishNeighborhoodInitializationRequest*.











#### PS08011 - Neighborhood Initialization Process - Updates Before Initialization Completes

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "images/PS08011.jpg" file exists and contains JPEG image with size less than 20 kb
  * "ps.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Base port for simulated profile server


##### Description 

The test simulates a profile server instance and establishes a neighborhood relationship with the target profile server 
by invoking the neighborhood initialization process. Before it completes the process, it creates new identities. 
This should result in update messages being sent after the initialization is finished.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test creates a primary identity which it uses to simulate another profile server and then 
it creates 10 test identities, establishes hosting agreements with the profile server for them, 
and initializes their profiles.

The test then creates a server, on which it simulates part of the profile server behavior.
The simulated profile server uses the base port ($BasePort) as its primary port and $BasePort+1 as its srNeighbor port.

###### Step 2:

The test then connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := $BasePort + 1`
 
and reads the response. 


###### Step 3:

The test creates 5 more identities, establishes hosting agreements with the profile server for them 
and initializes their profiles. 


###### Step 4:

The test waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives information about all the test identities.


###### Step 5:

The test creates 5 more identities, establishes hosting agreements with the profile server for them 
and initializes their profiles. 


###### Step 6:

The test waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message. 


###### Step 7:

The test creates 5 more identities, establishes hosting agreements with the profile server for them 
and initializes their profiles. 

Then it waits 20 seconds.


##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes hosting agreements for its test identities.
Then the test successfully initializes all test profiles. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


###### Step 3:

The test successfully establishes hosting agreements for the new test identities.
Then the test successfully initializes all new profiles. 


###### Step 4:

The server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about hosted profiles.


###### Step 5:

The test successfully establishes hosting agreements for the new test identities.
Then the test successfully initializes all new profiles. 


###### Step 6:

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 7:

The test successfully establishes hosting agreements for the new test identities.
Then the test successfully initializes all new profiles. 

The simulated profile server received neighborhood updates in form of *NeighborhoodSharedProfileUpdateRequest* 
for all the new profiles registered on the target profile server. And together with the profiles received 
during the neighborhood initialization process, the test received information about all the test identities.













#### PS08012 - Neighborhood Initialization Process - Different Server Neighbor Port

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "images/PS08012.jpg" file exists and contains JPEG image with size less than 20 kb
  * "ps.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Base port for simulated profile server


##### Description 

The test simulates a profile server instance and establishes a neighborhood relationship with the target profile server 
by invoking the neighborhood initialization process. However, it claims different (invalid) srNeighbor port being used 
during the initialization process. This will cause problem to the target profile server when it attempts 
to deliver the neighborhood updates to the simulated server and it will have to fallback to the primary port 
to get information about the real srNeighbor port in use.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test creates a primary identity which it uses to simulate another profile server and then 
it creates 10 test identities, establishes hosting agreements with the profile server for them, 
and initializes their profiles.

The test then creates a server, on which it simulates part of the profile server behavior.
The simulated profile server uses the base port ($BasePort) as its primary port and $BasePort+1 as its srNeighbor port.

###### Step 2:

The test then connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 1`
 
and reads the response. Then it waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives information about all the test identities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message.


###### Step 3:

The test creates 5 more identities, establishes hosting agreements with the profile server for them 
and initializes their profiles. 

Then it waits up to 12 minutes while waiting for updates from the profile server.


##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes hosting agreements for its test identities.
Then the test successfully initializes all test profiles. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


Server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about hosted profiles.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 3:

The test successfully establishes hosting agreements for the new test identities.
Then the test successfully initializes all new profiles. 

The simulated profile server received neighborhood updates in form of *NeighborhoodSharedProfileUpdateRequest* 
for all the new profiles registered on the target profile server. 














#### PS08013 - Neighborhood Initialization Process - Bad Role Server Neighbor Port

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "images/PS08013.jpg" file exists and contains JPEG image with size less than 20 kb
  * "ps.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Base port for simulated profile server


##### Description 

The test does exactly the same as in PS08012 except that the claimed srNeighbor port in use is actually its clNonCustomer port.
which it runs on port $BasePort + 2, and therefore the profile server will get ERROR_BAD_ROLE statuses on its neighborhood related requests.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test creates a primary identity which it uses to simulate another profile server and then 
it creates 10 test identities, establishes hosting agreements with the profile server for them, 
and initializes their profiles.

The test then creates a server, on which it simulates part of the profile server behavior.
The simulated profile server uses the base port ($BasePort) as its primary port, $BasePort+1 as its srNeighbor port,
and $BasePort+2 as its clNonCustomer port.

###### Step 2:

The test then connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := $BasePort + 2`
 
and reads the response. Then it waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives information about all the test identities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message.


###### Step 3:

The test creates 5 more identities, establishes hosting agreements with the profile server for them 
and initializes their profiles. 

Then it waits up to 12 minutes while waiting for updates from the profile server.


##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes hosting agreements for its test identities.
Then the test successfully initializes all test profiles. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


Server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about hosted profiles.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 3:

The test successfully establishes hosting agreements for the new test identities.
Then the test successfully initializes all new profiles. 

The simulated profile server received neighborhood updates in form of *NeighborhoodSharedProfileUpdateRequest* 
for all the new profiles registered on the target profile server. 














#### PS08014 - Neighborhood Initialization Process - Timeout

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "images/PS08014.jpg" file exists and contains JPEG image with size less than 20 kb
  * neighborhood_initialization_parallelism set to 1 in the configuration file

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test simulates a profile server instance and establishes a neighborhood relationship with the target profile server 
by invoking the neighborhood initialization process. However, in the middle of the process it stops replying to update 
requests, which should cause the session to time out and be terminated. Then the test attempts again and completes 
the process successfullly.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test creates a primary identity which it uses to simulate another profile server and then 
it creates 10 test identities, establishes hosting agreements with the profile server for them, 
and initializes their profiles.

###### Step 2:

The test then connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 1`
 
and reads the response. Then it waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives information about all the test identities.

Then it waits for *FinishNeighborhoodInitializationRequest* and then waits 450 seconds. Then it 
replies with corresponding *FinishNeighborhoodInitializationResponse* message and closes the connection.


###### Step 3:

The test then connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 1`
 
and reads the response. Then it waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives information about all the test identities.

Then it waits for *FinishNeighborhoodInitializationRequest* and and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message and closes the connection.


##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes hosting agreements for its test identities.
Then the test successfully initializes all test profiles. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


Server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about hosted profiles.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 3:

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


Server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about hosted profiles.

Server sends *FinishNeighborhoodInitializationRequest*.












#### PS08015 - Neighborhood Initialization Process - Parallel Processing

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "images/PS08015.jpg" file exists and contains JPEG image with size less than 20 kb

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test attempts to initiate three parallel neighborhood initialization processes with three different identities.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test creates a primary identity which it uses to simulate another profile server and then 
it creates 10 test identities, establishes hosting agreements with the profile server for them, 
and initializes their profiles.

###### Step 2:

With the first identity, the test connects to profile server's srNeighbor port and verifies its identity. 

Then it sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 1`
 
and reads the response. 


###### Step 3:

With the second identity, the test then connects to profile server's srNeighbor port and verifies its identity. 

Then it sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 1`
 
and reads the response. 

Then it waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives information about all the test identities.


###### Step 4:

With the third identity, the test then connects to profile server's srNeighbor port and verifies its identity. 

Then it sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := 1`
 
and reads the response. 


###### Step 5:

With the first identity, it waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives information about all the test identities.

Then it waits for *FinishNeighborhoodInitializationRequest* and and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message and closes the connection.


###### Step 6:

With the third identity, it waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives information about all the test identities.

Then it waits for *FinishNeighborhoodInitializationRequest* and and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message and closes the connection.


###### Step 7:

With the second identity, it waits for *FinishNeighborhoodInitializationRequest* and and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message and closes the connection.



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes hosting agreements for its test identities.
Then the test successfully initializes all test profiles. 


###### Step 2:

Then the test successfully verifies its first identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


###### Step 3:

Then the test successfully verifies its second identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about hosted profiles.


###### Step 4:

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


###### Step 5:

Server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about hosted profiles.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 6:

Server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about hosted profiles.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 7:

Server sends *FinishNeighborhoodInitializationRequest*.







#### PS08016 - Neighborhood Updates - Rejected

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "images/PS08016.jpg" file exists and contains JPEG image with size less than 20 kb
  * "ps.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Base port for simulated profile server


##### Description 

The test simulates a profile server instance and establishes a neighborhood relationship with the target profile server 
by invoking the neighborhood initialization process. The sets up identities on the target server and manipulates them 
in order to receive neighborhood updates from it. At one point, the test rejects the update and then sets up more identities 
to verify that no more update will arrive.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test creates a primary identity which it uses to simulate another profile server and then 
it creates 10 test identities, establishes hosting agreements with the profile server for them, 
and initializes their profiles.

The test then creates a server, on which it simulates part of the profile server behavior.
The simulated profile server uses the base port ($BasePort) as its primary port and $BasePort+1 as its srNeighbor port.


###### Step 2:

The test connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := $BasePort + 1`
 
and reads the response. Then it waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives information about all the test identities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message.


###### Step 3:

The test creates 5 more identities, establishes hosting agreements with the profile server for them 
and initializes their profiles. Then it waits 20 seconds.


###### Step 4:

The test creates 1 more identity and waits 20 seconds for the related update to come, to which it replies with ERROR_REJECTED.


###### Step 5:

The test creates 5 more identities, establishes hosting agreements with the profile server for them 
and initializes their profiles. Then it waits 20 seconds.



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes hosting agreements for its test identities.
Then the test successfully initializes all test profiles. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about all test identities.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 3:

The test successfully establishes hosting agreements for the new test identities.
The test successfully initializes all new profiles. 

The simulated profile server receives neighborhood updates in form of *NeighborhoodSharedProfileUpdateRequest* 
for all the newly hosted profiles on the target profile server.


###### Step 4:

The test successfully establishes a hosting agreement for the new test identity.
The test successfully initializes its profile. 


###### Step 5:

The test successfully establishes hosting agreements for the new test identities.
The test successfully initializes all new profiles. 

The simulated profile server does not receive any updates.









#### PS08017 - Neighborhood Requests - No Initialization

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port


##### Description 

The test sends *FinishNeighborhoodInitializationRequest*, *NeighborhoodSharedProfileUpdateRequest*, and *StopNeighborhoodUpdatesRequest* 
to the profile server without starting the network initialization process.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test connects to profile server's srNeighbor port and verifies its identity. 

The test sends *FinishNeighborhoodInitializationRequest*:

  * `Message.id := 3`

and reads the response. The test sends *NeighborhoodSharedProfileUpdateRequest*:

  * `Message.id := 4`
  * `NeighborhoodSharedProfileUpdateRequest.items := null`

and reads the response. The test sends *StopNeighborhoodUpdatesRequest*:

  * `Message.id := 5`

and reads the response.




##### Acceptance Criteria

###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 

Then the test successfully verifies its identity.

Server replies with *Response*:
  
  * `Message.id == 3`
  * `Response.status == ERROR_REJECTED`

Server replies with *Response*:
  
  * `Message.id == 4`
  * `Response.status == ERROR_REJECTED`

Server replies with *Response*:
  
  * `Message.id == 5`
  * `Response.status == ERROR_NOT_FOUND`










#### PS08018 - New Neighbor - Empty Database

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "ps.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Base port for simulated profile server
  * Port for simulated Location Based Network server


##### Description 

The test simulates a profile server instance and a location based network server. The location server informs the real 
target profile server that a new neighbor (the simulated profile server) was added to its neighborhood. The target 
profile server should contact the simulated profile server and invoke the neighborhood initialization process.
The simulated profile server will immediately finish the process as it simulates empty database.


###### Step 1:

The test creates a server, on which it simulates part of the profile server behavior. The simulated profile server uses 
the base port ($BasePort) as its primary port and $BasePort+1 as its srNeighbor port.

The test then simulates the location server and let's the target profile server to perform the LOC initialization 
with the simulated location server. 


###### Step 2:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test then sends *FinishNeighborhoodInitializationRequest* to the target profile server over the simulated profile 
server's connection and waits for *FinishNeighborhoodInitializationResponse*.



##### Acceptance Criteria



###### Step 1:

The test successfully starts simulated profile server and simulated LOC server. 
The target profile server successfully connects to the simulated LOC server and initializes the LOC session.


###### Step 2:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *FinishNeighborhoodInitializationResponse*.











#### PS08019 - New Neighbor - Small Set

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "ps.pfx" file exists and contains a self-signed TLS certificate, not protected by password
  * "images/PS08019.png" file exists and contains PNG image with size less than 5 kb

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Base port for simulated profile server
  * Port for simulated Location Based Network server


##### Description 

The test simulates a profile server instance and a location based network server. The location server informs the real 
target profile server that a new neighbor (the simulated profile server) was added to its neighborhood. The target 
profile server should contact the simulated profile server and invoke the neighborhood initialization process.
The simulated profile server will send a small number of profiles to the target server. The test then verifies 
that the target profile server includes the shared profiles in its search queries.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test creates identities with following profiles:

  * $profileInfo1 is `version := [1,0,0], type := "Profile Type A", name := "Shanghai 1",   image := "images/PS08019.png", location := (31.23, 121.47),  extraData = null`
  * $profileInfo2 is `version := [1,0,0], type := "Profile Type A", name := "Mumbai 1",     image := "images/PS08019.png", location := (18.96, 72.82),   extraData = "t=running,Cycling,ice hockey,water polo"`
  * $profileInfo3 is `version := [1,0,0], type := "Profile Type A", name := "Karachi",      image := null,                 location := (24.86, 67.01),   extraData = "l=Karachi,PK;a=iop://185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969;t=traveling,cycling,running"`
  * $profileInfo4 is `version := [1,0,0], type := "Profile Type B", name := "Buenos Aires", image := "images/PS08019.png", location := (-34.61, -58.37), extraData = null`
  * $profileInfo5 is `version := [1,0,0], type := "Profile Type B", name := "Shanghai 2",   image := null,                 location := (31.231, 121.47), extraData = "running"`
  * $profileInfo6 is `version := [1,0,0], type := "Profile Type C", name := "Mumbai 2",     image := "images/PS08019.png", location := (18.961, 72.82),  extraData = "MTg1ZjhkYjMyMjcxZmUyNWY1NjFhNmZjOTM4YjJlMjY0MzA2ZWMzMDRlZGE1MTgwMDdkMTc2NDgyNjM4MTk2OQ=="`
  * $profileInfo7 is `version := [1,0,0], type := "Profile Type C", name := "Mumbai 3",     image := null,                 location := (18.961, 72.82),  extraData = "t=running;l=Mumbai,IN"`


The test creates a server, on which it simulates part of the profile server behavior. The simulated profile server uses 
the base port ($BasePort) as its primary port and $BasePort+1 as its srNeighbor port.

The test then simulates the location server and let's the target profile server to perform the LOC initialization 
with the simulated location server. 


###### Step 2:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

  * `NeighborhoodSharedProfileUpdateRequest.items := 
    [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
    ]`

to the target profile server over the simulated profile server's connection and waits for *NeighborhoodSharedProfileUpdateResponse*.

The test then sends *FinishNeighborhoodInitializationRequest* to the target profile server over the simulated profile 
server's connection and waits for *FinishNeighborhoodInitializationResponse*.


###### Step 3:

The test connects to clNonCustomer port of the target profile server and starts conversation, 
then it sends *ProfileSearchRequest* to find all test profiles:

  * `Message.id := 2`
  * `ProfileSearchRequest.includeHostedOnly := false`
  * `ProfileSearchRequest.includeThumbnailImages := true`
  * `ProfileSearchRequest.maxResponseRecordCount := 100`
  * `ProfileSearchRequest.maxTotalRecordCount := 100`
  * `ProfileSearchRequest.type := ""`
  * `ProfileSearchRequest.name := ""`
  * `ProfileSearchRequest.latitude := NO_LOCATION`
  * `ProfileSearchRequest.longitude := NO_LOCATION`
  * `ProfileSearchRequest.radius := 0`
  * `ProfileSearchRequest.extraData := ""`

and reads the response.




##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
The test successfully starts simulated profile server and simulated LOC server. 
The target profile server successfully connects to the simulated LOC server and initializes the LOC session.


###### Step 2:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *NeighborhoodSharedProfileUpdateResponse*.

The target profile server sends the corresponding *FinishNeighborhoodInitializationResponse*.


###### Step 3:

The test successfully starts the conversation and the target profile server sends *ProfileSearchResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `ProfileSearchResponse.totalRecordCount == 7`
  * `ProfileSearchResponse.maxResponseRecordCount == 100`
  * `ProfileSearchResponse.profiles.Count == 7`
  * `ProfileSearchResponse.coveredServers == (ID of target profile server, $SimPsId := ID of simulated profile server)`
  * `ProfileSearchResponse.profiles == 
    (
      {isHosted == false, hostingServerNetworkId == $SimPsId; type, name, latitude, longitude, extraData match $profileInfo1; image is identity 1 image},
      {isHosted == false, hostingServerNetworkId == $SimPsId; type, name, latitude, longitude, extraData match $profileInfo2; image is identity 2 image},
      {isHosted == false, hostingServerNetworkId == $SimPsId; type, name, latitude, longitude, extraData match $profileInfo3; image == empty},
      {isHosted == false, hostingServerNetworkId == $SimPsId; type, name, latitude, longitude, extraData match $profileInfo4; image is identity 4 image},
      {isHosted == false, hostingServerNetworkId == $SimPsId; type, name, latitude, longitude, extraData match $profileInfo5; image == empty},
      {isHosted == false, hostingServerNetworkId == $SimPsId; type, name, latitude, longitude, extraData match $profileInfo6; image is identity 6 image},
      {isHosted == false, hostingServerNetworkId == $SimPsId; type, name, latitude, longitude, extraData match $profileInfo7; image == empty},
    )`









#### PS08020 - New Neighbor - Large Set

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "ps.pfx" file exists and contains a self-signed TLS certificate, not protected by password
  * "images/PS08020.png" file exists and contains PNG image with size less than 5 kb

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Base port for simulated profile server
  * Port for simulated Location Based Network server


##### Description 

The test simulates a profile server instance and a location based network server. The location server informs the real 
target profile server that a new neighbor (the simulated profile server) was added to its neighborhood. The target 
profile server should contact the simulated profile server and invoke the neighborhood initialization process.
The simulated profile server will send a large number of profiles to the target server. The test then verifies 
that the target profile server includes the shared profiles in its search queries.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test generates positive integers R1, R2, and R3:

  * `20,000 < R2 < 150,000`
  * `5,000 < R1 < 0.8 * R2`
  * `1.50 * R2 < R3 < 500,000`

The test generates 20 GPS locations, first 15 locations are generated as follows:

  * Location 1 is within R2 range of (0.0, 0.0),
  * location 2 is within R2 range of (89.9, 0.0),
  * location 3 is within R2 range of (-89.9, 0.0),
  * location 4 is within R2 range of (40.0, 0.0),
  * location 5 is within R2 range of (0.0, 179.9),
  * location 6 is within R2 range of (89.9, 179.9),
  * location 7 is within R2 range of (-89.9, 179.9),
  * location 8 is within R2 range of (40.0, 179.9),
  * location 9 is within R2 range of (0.0, -179.9),
  * location 10 is within R2 range of (89.9, -179.9),
  * location 11 is within R2 range of (-89.9, -179.9),
  * location 12 is within R2 range of (40.0, -179.9),
  * location 13 is within R2 range of (0.0, 50.0),
  * location 14 is within R2 range of (89.9, 50.0),
  * location 15 is within R2 range of (-89.9, 50.0).

the remaining 5 locations are random GPS locations.

For each of 20 locations, the test generates profiles of 10 identities that are all located randomly within 
R1 range of the location, 10 identities within R2 range and 10 identities within R3 range.


The test creates a server, on which it simulates part of the profile server behavior. The simulated profile server uses 
the base port ($BasePort) as its primary port and $BasePort+1 as its srNeighbor port.

The test then simulates the location server and let's the target profile server to perform the LOC initialization 
with the simulated location server. 


###### Step 2:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends a series of *NeighborhoodSharedProfileUpdateRequest* messages to share all the generated profiles 
with the target profile server and waits for corresponding *NeighborhoodSharedProfileUpdateResponse*.

The test then sends *FinishNeighborhoodInitializationRequest* to the target profile server over the simulated profile 
server's connection and waits for *FinishNeighborhoodInitializationResponse* messages.


###### Step 3:

The test connects to clNonCustomer port of the target profile server and starts conversation, 

The test performs search queries using *ProfileSearchRequest*. For each of the 20 locations, it searches for profiles 
located within R1, R2 and R3 and a random number (new for each query) within the range of 1,000,000 to 10,000,000.
The tests verifies that the search results match the expected results.



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
The test successfully starts simulated profile server and simulated LOC server. 
The target profile server successfully connects to the simulated LOC server and initializes the LOC session.


###### Step 2:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *NeighborhoodSharedProfileUpdateResponse*.

The target profile server sends the corresponding *FinishNeighborhoodInitializationResponse*.


###### Step 3:

The profile server's results for each search query match locally computed expected results. 








#### PS08021 - New Neighbor - Too Many Profiles

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "ps.pfx" file exists and contains a self-signed TLS certificate, not protected by password
  * "images/PS08021.png" file exists and contains PNG image with size less than 5 kb

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Base port for simulated profile server
  * Port for simulated Location Based Network server


##### Description 

The test simulates a profile server instance and a location based network server. The location server informs the real 
target profile server that a new neighbor (the simulated profile server) was added to its neighborhood. The target 
profile server should contact the simulated profile server and invoke the neighborhood initialization process.

The simulated profile server sends more than a maximum number (20,000) of profiles to the target server, 
so the initialization process should fail. The test then verifies that the target profile server does not include any 
of the shared profiles in its search queries.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test generates 20,500 identities.

The test creates a server, on which it simulates part of the profile server behavior. The simulated profile server uses 
the base port ($BasePort) as its primary port and $BasePort+1 as its srNeighbor port.

The test then simulates the location server and let's the target profile server to perform the LOC initialization 
with the simulated location server. 


###### Step 2:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends a series of *NeighborhoodSharedProfileUpdateRequest* messages to share all the generated profiles 
with the target profile server and waits for corresponding *NeighborhoodSharedProfileUpdateResponse* messages.


###### Step 3:

The test connects to clNonCustomer port of the target profile server and starts conversation, 

The test performs a search queries using *ProfileSearchRequest*:

  * `Message.id := 2`
  * `ProfileSearchRequest.includeHostedOnly := false`
  * `ProfileSearchRequest.includeThumbnailImages := true`
  * `ProfileSearchRequest.maxResponseRecordCount := 100`
  * `ProfileSearchRequest.maxTotalRecordCount := 100`
  * `ProfileSearchRequest.type := ""`
  * `ProfileSearchRequest.name := ""`
  * `ProfileSearchRequest.latitude := NO_LOCATION`
  * `ProfileSearchRequest.longitude := NO_LOCATION`
  * `ProfileSearchRequest.radius := 0`
  * `ProfileSearchRequest.extraData := ""`

and reads the response.



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
The test successfully starts simulated profile server and simulated LOC server. 
The target profile server successfully connects to the simulated LOC server and initializes the LOC session.


###### Step 2:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *NeighborhoodSharedProfileUpdateResponse*.

The target profile server sends *Response*:
  
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "$x.add"`, where $x is the index of the 20,001st update item within its update batch.

###### Step 3:

The test successfully starts the conversation.

The target profile server replies *ProfileSearchResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `ProfileSearchResponse.totalRecordCount == 0`
  * `ProfileSearchResponse.maxResponseRecordCount == 100`
  * `ProfileSearchResponse.profiles.Count == 0`











#### PS08022 - New Neighbor - Too Many Profiles - Update

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "ps.pfx" file exists and contains a self-signed TLS certificate, not protected by password
  * "images/PS08022.png" file exists and contains PNG image with size less than 5 kb

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Base port for simulated profile server
  * Port for simulated Location Based Network server


##### Description 

The test simulates a profile server instance and a location based network server. The location server informs the real 
target profile server that a new neighbor (the simulated profile server) was added to its neighborhood. The target 
profile server should contact the simulated profile server and invoke the neighborhood initialization process.

The simulated profile server sends close to a maximum number (20,000) of profiles to the target server 
and then once the initialization process finishes, it sends a neighborhood update that will exceed the limit. 
The test then verifies that the target profile server does not include any of the profiles that would exceed the limit 
in its search queries. Then the test sends more update messages to test the behavior of the profile server 
when the number of shared profiles is close to the limit.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test generates 20,050 identities. Identities number 19,991 to 20,050 will have profile type set to "last".

The test creates a server, on which it simulates part of the profile server behavior. The simulated profile server uses 
the base port ($BasePort) as its primary port and $BasePort+1 as its srNeighbor port.

The test then simulates the location server and let's the target profile server to perform the LOC initialization 
with the simulated location server. 


###### Step 2:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends a series of *NeighborhoodSharedProfileUpdateRequest* messages to share the first 19,990 of the generated 
profiles with the target profile server and waits for corresponding *NeighborhoodSharedProfileUpdateResponse* messages.

The test then sends *FinishNeighborhoodInitializationRequest* to the target profile server over the simulated profile 
server's connection and waits for *FinishNeighborhoodInitializationResponse* messages.


###### Step 3:

The test connects to the srNeighbor port of the target profile server, verifies its identity, and sends 
*NeighborhoodSharedProfileUpdateRequest* message to add the remaining 60 profiles and reads the response.


###### Step 4:

The test performs a search queries using *ProfileSearchRequest*:

  * `Message.id := 2`
  * `ProfileSearchRequest.includeHostedOnly := false`
  * `ProfileSearchRequest.includeThumbnailImages := true`
  * `ProfileSearchRequest.maxResponseRecordCount := 100`
  * `ProfileSearchRequest.maxTotalRecordCount := 100`
  * `ProfileSearchRequest.type := "last"`
  * `ProfileSearchRequest.name := ""`
  * `ProfileSearchRequest.latitude := NO_LOCATION`
  * `ProfileSearchRequest.longitude := NO_LOCATION`
  * `ProfileSearchRequest.radius := 0`
  * `ProfileSearchRequest.extraData := ""`

and reads the response.



###### Step 5:

The test selects 140 profiles and connects to the srNeighbor port of the target profile server, verifies its identity,
and sends *NeighborhoodSharedProfileUpdateRequest* message to delete the selected profiles and reads the response.

Then the test generates 160 new profiles (with profile type set to "last") and sends *NeighborhoodSharedProfileUpdateRequest* 
message to add them to the target profile server.


###### Step 6:

The test performs a search queries using *ProfileSearchRequest*:

  * `Message.id := 2`
  * `ProfileSearchRequest.includeHostedOnly := false`
  * `ProfileSearchRequest.includeThumbnailImages := false`
  * `ProfileSearchRequest.maxResponseRecordCount := 1000`
  * `ProfileSearchRequest.maxTotalRecordCount := 1000`
  * `ProfileSearchRequest.type := "last"`
  * `ProfileSearchRequest.name := ""`
  * `ProfileSearchRequest.latitude := NO_LOCATION`
  * `ProfileSearchRequest.longitude := NO_LOCATION`
  * `ProfileSearchRequest.radius := 0`
  * `ProfileSearchRequest.extraData := ""`

and reads the response.


###### Step 7:

The test selects 40 existing profiles, which are to be deleted, and 40 profiles, which are to be changed,
and generates 40 new profiles (with profile type set to "last"), which are to be added.

The test connects to the srNeighbor port of the target profile server, verifies its identity,
and sends *NeighborhoodSharedProfileUpdateRequest* message to announce all changes, putting the deleted 
profiles first and reads the response.


###### Step 8:

The test performs a search queries using *ProfileSearchRequest*:

  * `Message.id := 2`
  * `ProfileSearchRequest.includeHostedOnly := false`
  * `ProfileSearchRequest.includeThumbnailImages := false`
  * `ProfileSearchRequest.maxResponseRecordCount := 1000`
  * `ProfileSearchRequest.maxTotalRecordCount := 1000`
  * `ProfileSearchRequest.type := "last"`
  * `ProfileSearchRequest.name := ""`
  * `ProfileSearchRequest.latitude := NO_LOCATION`
  * `ProfileSearchRequest.longitude := NO_LOCATION`
  * `ProfileSearchRequest.radius := 0`
  * `ProfileSearchRequest.extraData := ""`

and reads the response.



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
The test successfully starts simulated profile server and simulated LOC server. 
The target profile server successfully connects to the simulated LOC server and initializes the LOC session.


###### Step 2:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *NeighborhoodSharedProfileUpdateResponse*.

The target profile server sends the corresponding *FinishNeighborhoodInitializationResponse*.


###### Step 3:

The test successfullly verifies its identity.

The target profile server replies *Response*:
  
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "10.add"`


###### Step 4:

The target profile server replies with *ProfileSearchResponse* that contains only identities numbers 19,991 to 20,000.


###### Step 5:

The test successfullly verifies its identity.

The target profile server replies *Response*:
  
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "140.add"`


###### Step 6:

The target profile server replies with *ProfileSearchResponse* that does not contain the profiles exceeding the limits.


###### Step 7:

The test successfullly verifies its identity.

The target profile server replies with the corresponding *NeighborhoodSharedProfileUpdateResponse*:

  * `Response.status == STATUS_OK`


###### Step 8:

The target profile server replies with *ProfileSearchResponse* that contains all profiles retrieved in Step 6 plus 
the newly created profiles.
















#### PS08023 - New Neighbor - Invalid Requests

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "ps.pfx" file exists and contains a self-signed TLS certificate, not protected by password
  * "images/PS08023.png" file exists and contains PNG image with size less than 5 kb

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Base port for simulated profile server
  * Port for simulated Location Based Network server


##### Description 

The test simulates a profile server instance and a location based network server. The location server informs the real 
target profile server that a new neighbor (the simulated profile server) was added to its neighborhood. The target 
profile server should contact the simulated profile server and invoke the neighborhood initialization process.

The simulated profile server sends update requests, with one invalid update item to test error handling on the target 
profile server. The initialization process should fail and the simulated profile server tries again with another type 
of invalid update item.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test creates identities with following profiles:

  * $profileInfo1 is `version := [1,0,0], type := "Profile Type A", name := "Shanghai 1",   image := "images/PS08023.png", location := (31.23, 121.47),  extraData = null`
  * $profileInfo2 is `version := [1,0,0], type := "Profile Type A", name := "Mumbai 1",     image := "images/PS08023.png", location := (18.96, 72.82),   extraData = "t=running,Cycling,ice hockey,water polo"`
  * $profileInfo3 is `version := [1,0,0], type := "Profile Type A", name := "Karachi",      image := null,                 location := (24.86, 67.01),   extraData = "l=Karachi,PK;a=iop://185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969;t=traveling,cycling,running"`
  * $profileInfo4 is `version := [1,0,0], type := "Profile Type B", name := "Buenos Aires", image := "images/PS08023.png", location := (-34.61, -58.37), extraData = null`
  * $profileInfo5 is `version := [1,0,0], type := "Profile Type B", name := "Shanghai 2",   image := null,                 location := (31.231, 121.47), extraData = "running"`
  * $profileInfo6 is `version := [1,0,0], type := "Profile Type C", name := "Mumbai 2",     image := "images/PS08023.png", location := (18.961, 72.82),  extraData = "MTg1ZjhkYjMyMjcxZmUyNWY1NjFhNmZjOTM4YjJlMjY0MzA2ZWMzMDRlZGE1MTgwMDdkMTc2NDgyNjM4MTk2OQ=="`
  * $profileInfo7 is `version := [1,0,0], type := "Profile Type C", name := "Mumbai 3",     image := null,                 location := (18.961, 72.82),  extraData = "t=running;l=Mumbai,IN"`


The test creates a server, on which it simulates part of the profile server behavior. The simulated profile server uses 
the base port ($BasePort) as its primary port and $BasePort+1 as its srNeighbor port.

The test then simulates the location server and let's the target profile server to perform the LOC initialization 
with the simulated location server. 


###### Step 2:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = add, add {version := [1,0]; type, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is no longer in its neighborhood.


###### Step 3:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = add, add {version := [0,0,0]; type, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is no longer in its neighborhood.


###### Step 4:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey consists of 300 'a' characters, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is no longer in its neighborhood.



###### Step 5:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 1, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is no longer in its neighborhood.


###### Step 6:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = add, add {name is string of 70 'a' characters; version, type, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is no longer in its neighborhood.


###### Step 7:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = add, add {name is string of 50 'ɐ' characters (UTF8 code 0xc990), which consume 2 bytes per character; version, type, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is no longer in its neighborhood.



###### Step 8:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = add, add {type is string of 70 'a' characters; version, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is no longer in its neighborhood.


###### Step 9:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = add, add {type is string of 50 'ɐ' characters (UTF8 code 0xc990), which consume 2 bytes per character; version, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is no longer in its neighborhood.


###### Step 10:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = add, add {type := ""; version, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is no longer in its neighborhood.



###### Step 11:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == true, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is no longer in its neighborhood.



###### Step 12:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == true, thumbnailImage := [0,1,2] }},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is no longer in its neighborhood.



###### Step 13:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = add, add {latitude := 987654321; version, type, name, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImagee == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is no longer in its neighborhood.


###### Step 14:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = add, add {longitude := 987654321; version, type, name, latitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is no longer in its neighborhood.


###### Step 15:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = add, add {extraData is string of 270 'a' characters; version, type, name, latitude, longitude match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is no longer in its neighborhood.


###### Step 16:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = add, add {extraData is string of 150 'ɐ' characters (UTF8 code 0xc990), which consume 2 bytes per character; version, type, name, latitude, longitude match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is no longer in its neighborhood.


###### Step 17:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = change, change {identityNetworkId is ID of identity 1; setName := true; name := "a"}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is no longer in its neighborhood.


###### Step 18:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = delete, delete {identityNetworkId is ID of identity 1}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is no longer in its neighborhood.


###### Step 19:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = add, add {name := ""; version, type, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is no longer in its neighborhood.





##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
The test successfully starts simulated profile server and simulated LOC server. 
The target profile server successfully connects to the simulated LOC server and initializes the LOC session.


###### Step 2:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.version"`

Simulated LOC server successfully sends notification message about removing the simulated profile server from the target profile server's neighborhood.


###### Step 3:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.version"`

Simulated LOC server successfully sends notification message about removing the simulated profile server from the target profile server's neighborhood.


###### Step 4:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.identityPublicKey"`

Simulated LOC server successfully sends notification message about removing the simulated profile server from the target profile server's neighborhood.


###### Step 5:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.identityPublicKey"`

Simulated LOC server successfully sends notification message about removing the simulated profile server from the target profile server's neighborhood.


###### Step 6:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.name"`

Simulated LOC server successfully sends notification message about removing the simulated profile server from the target profile server's neighborhood.


###### Step 7:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.name"`

Simulated LOC server successfully sends notification message about removing the simulated profile server from the target profile server's neighborhood.


###### Step 8:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.type"`

Simulated LOC server successfully sends notification message about removing the simulated profile server from the target profile server's neighborhood.


###### Step 9:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.type"`

Simulated LOC server successfully sends notification message about removing the simulated profile server from the target profile server's neighborhood.


###### Step 10:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.type"`

Simulated LOC server successfully sends notification message about removing the simulated profile server from the target profile server's neighborhood.


###### Step 11:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.thumbnailImage"`

Simulated LOC server successfully sends notification message about removing the simulated profile server from the target profile server's neighborhood.


###### Step 12:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.thumbnailImage"`

Simulated LOC server successfully sends notification message about removing the simulated profile server from the target profile server's neighborhood.


###### Step 13:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.latitude"`

Simulated LOC server successfully sends notification message about removing the simulated profile server from the target profile server's neighborhood.


###### Step 14:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.longitude"`

Simulated LOC server successfully sends notification message about removing the simulated profile server from the target profile server's neighborhood.


###### Step 15:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.extraData"`

Simulated LOC server successfully sends notification message about removing the simulated profile server from the target profile server's neighborhood.


###### Step 16:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.extraData"`

Simulated LOC server successfully sends notification message about removing the simulated profile server from the target profile server's neighborhood.


###### Step 17:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.actionType"`

Simulated LOC server successfully sends notification message about removing the simulated profile server from the target profile server's neighborhood.


###### Step 18:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.actionType"`

Simulated LOC server successfully sends notification message about removing the simulated profile server from the target profile server's neighborhood.


###### Step 19:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.name"`

Simulated LOC server successfully sends notification message about removing the simulated profile server from the target profile server's neighborhood.










#### PS08024 - Neighborhood Update - Invalid Requests

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "ps.pfx" file exists and contains a self-signed TLS certificate, not protected by password
  * "images/PS08024.png" file exists and contains PNG image with size less than 5 kb

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Base port for simulated profile server
  * Port for simulated Location Based Network server


##### Description 

The test simulates a profile server instance and a location based network server. The location server informs the real 
target profile server that a new neighbor (the simulated profile server) was added to its neighborhood. The target 
profile server should contact the simulated profile server and invoke the neighborhood initialization process.

The simulated profile server successfully performs the neighborhood initialization process with the target profile server 
and then it sends a series of update requests, each with one invalid update item to test error handling on the target 
profile server. 


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test creates identities with following profiles:

  * $profileInfo1 is `version := [1,0,0], type := "Profile Type A", name := "Shanghai 1",   image := "images/PS08024.png", location := (31.23, 121.47),  extraData = null`
  * $profileInfo2 is `version := [1,0,0], type := "Profile Type A", name := "Mumbai 1",     image := "images/PS08024.png", location := (18.96, 72.82),   extraData = "t=running,Cycling,ice hockey,water polo"`
  * $profileInfo3 is `version := [1,0,0], type := "Profile Type A", name := "Karachi",      image := null,                 location := (24.86, 67.01),   extraData = "l=Karachi,PK;a=iop://185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969;t=traveling,cycling,running"`
  * $profileInfo4 is `version := [1,0,0], type := "Profile Type B", name := "Buenos Aires", image := "images/PS08024.png", location := (-34.61, -58.37), extraData = null`
  * $profileInfo5 is `version := [1,0,0], type := "Profile Type B", name := "Shanghai 2",   image := null,                 location := (31.231, 121.47), extraData = "running"`
  * $profileInfo6 is `version := [1,0,0], type := "Profile Type C", name := "Mumbai 2",     image := "images/PS08024.png", location := (18.961, 72.82),  extraData = "MTg1ZjhkYjMyMjcxZmUyNWY1NjFhNmZjOTM4YjJlMjY0MzA2ZWMzMDRlZGE1MTgwMDdkMTc2NDgyNjM4MTk2OQ=="`
  * $profileInfo7 is `version := [1,0,0], type := "Profile Type C", name := "Mumbai 3",     image := null,                 location := (18.961, 72.82),  extraData = "t=running;l=Mumbai,IN"`


The test creates a server, on which it simulates part of the profile server behavior. The simulated profile server uses 
the base port ($BasePort) as its primary port and $BasePort+1 as its srNeighbor port.

The test then simulates the location server and let's the target profile server to perform the LOC initialization 
with the simulated location server. 


###### Step 2:

Then test's location server sends a notification message to the profile server with the information that the simulated 
profile server is a new neighbor in its neighborhood.

The simulated profile server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo1; identityPublicKey is public key of test identity 1, setThumbnailImage == true, thumbnailImage is identity 1 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo2; identityPublicKey is public key of test identity 2, setThumbnailImage == true, thumbnailImage is identity 2 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo6; identityPublicKey is public key of test identity 6, setThumbnailImage == true, thumbnailImage is identity 6 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo7; identityPublicKey is public key of test identity 7, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. Then the test sends *FinishNeighborhoodInitializationRequest* and reads the response.


###### Step 3:

The test connects to srNeighbor port of the target profile server, verifies its identity, and sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {version := [1,0]; type, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. 


###### Step 4:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {version := [0,0,0]; type, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. 


###### Step 5:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey consists of 300 'a' characters, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. 


###### Step 6:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 1, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. 


###### Step 7:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {name is string of 70 'a' characters; version, type, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.


###### Step 8:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {name is string of 50 'ɐ' characters (UTF8 code 0xc990), which consume 2 bytes per character; version, type, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. 



###### Step 9:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {type is string of 70 'a' characters; version, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. 


###### Step 10:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {type is string of 50 'ɐ' characters (UTF8 code 0xc990), which consume 2 bytes per character; version, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.


###### Step 11:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {type := ""; version, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.



###### Step 12:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == true, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.



###### Step 13:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == true, thumbnailImage := [0,1,2] }},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.



###### Step 14:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {latitude := 987654321; version, type, name, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImagee == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.


###### Step 15:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {longitude := 987654321; version, type, name, latitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.


###### Step 16:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {extraData is string of 270 'a' characters; version, type, name, latitude, longitude match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.


###### Step 17:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {extraData is string of 150 'ɐ' characters (UTF8 code 0xc990), which consume 2 bytes per character; version, type, name, latitude, longitude match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.


###### Step 18:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = change, change {identityNetworkId is network ID of identity 1; setName, setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.


###### Step 19:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = change, change {identityNetworkId := [0, 1, 2]; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.


###### Step 20:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 1; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = delete, delete {identityNetworkId is network ID of identity 1}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.


###### Step 21:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = change, change {identityNetworkId is network ID of identity 3; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.


###### Step 22:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 3; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.



###### Step 23:

The test connects to srNeighbor port of the target profile server, verifies its identity, and sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = change, change {identityNetworkId is network ID of identity 1; setVersion := true; version := [1,0]; setName, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. 


###### Step 24:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = change, change {identityNetworkId is network ID of identity 1; setVersion := true; version := [0,0,0]; setName, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. 


###### Step 25:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = change, change {identityNetworkId is network ID of identity 1; setName := true; name is string of 70 'a' characters; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.


###### Step 26:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = change, change {identityNetworkId is network ID of identity 1; setName := true; name is string of 50 'ɐ' characters (UTF8 code 0xc990), which consume 2 bytes per character; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response. 



###### Step 27:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = change, change {identityNetworkId is network ID of identity 1; setThumbnailImage := true; thumbnailImage is 6000 bytes 0x40; setName, setVersion, setLocation, setExtraData := false}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.



###### Step 28:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = change, change {identityNetworkId is network ID of identity 1; setThumbnailImage := true; thumbnailImage := [0,1,2]; setName, setVersion, setLocation, setExtraData := false}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.



###### Step 29:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = change, change {identityNetworkId is network ID of identity 1; setLocation := true; latitude := 987654321; longitude := 0; setName, setVersion, setThumbnailImage, setExtraData := false}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.


###### Step 30:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = change, change {identityNetworkId is network ID of identity 1; setLocation := true; latitude := 0; longitude := 987654321; setName, setVersion, setThumbnailImage, setExtraData := false}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.


###### Step 31:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = change, change {identityNetworkId is network ID of identity 1; setExtraData := true; extraData is string of 270 'a' characters; setName, setVersion, setThumbnailImage, setLocation := false}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.


###### Step 32:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = change, change {identityNetworkId is network ID of identity 1; setExtraData := true; extraData is string of 150 'ɐ' characters (UTF8 code 0xc990), which consume 2 bytes per character; setName, setVersion, setThumbnailImage, setLocation := false}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.


###### Step 33:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = delete, delete {identityNetworkId := [0,1,2]}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.


###### Step 34:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {name := ""; version, type, latitude, longitude, extraData match $profileInfo3; identityPublicKey is public key of test identity 3, setThumbnailImage == false, thumbnailImage == empty}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.


###### Step 35:

The test sends *NeighborhoodSharedProfileUpdateRequest*:

 * `NeighborhoodSharedProfileUpdateRequest.items := 
   [
      {ActionType = change, change {identityNetworkId is network ID of identity 2; setName := true; name := "X"; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = change, change {identityNetworkId is network ID of identity 1; setName := true; name := ""; setVersion, setLocation, setExtraData, setThumbnailImage := false}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo4; identityPublicKey is public key of test identity 4, setThumbnailImage == true, thumbnailImage is identity 4 image}},
      {ActionType = add, add {version, type, name, latitude, longitude, extraData match $profileInfo5; identityPublicKey is public key of test identity 5, setThumbnailImage == false, thumbnailImage == empty}},
   ]`

and reads the response.



##### Acceptance Criteria

###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
The test successfully starts simulated profile server and simulated LOC server. 
The target profile server successfully connects to the simulated LOC server and initializes the LOC session.


###### Step 2:

Simulated LOC server successfully sends notification message to the profile server.

The target profile server sends *StartNeighborhoodInitializationRequest*.

The target profile server sends the corresponding *NeighborhoodSharedProfileUpdateResponse*:

  * `Response.status == STATUS_OK`

The target profile server sends *FinishNeighborhoodInitializationRequest*:

  * `Response.status == STATUS_OK`


###### Step 3:

The target profile server sends *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.version"`


###### Step 4:

The target profile server sends *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.version"`


###### Step 5:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.identityPublicKey"`


###### Step 6:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.identityPublicKey"`


###### Step 7:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.name"`


###### Step 8:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.name"`


###### Step 9:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.type"`


###### Step 10:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.type"`


###### Step 11:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.type"`


###### Step 12:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.thumbnailImage"`


###### Step 13:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.thumbnailImage"`


###### Step 14:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.latitude"`


###### Step 15:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.longitude"`


###### Step 16:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.extraData"`


###### Step 17:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.extraData"`


###### Step 18:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.set*"`


###### Step 19:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.identityNetworkId"`


###### Step 20:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.delete.identityNetworkId"`


###### Step 21:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.identityNetworkId"`


###### Step 22:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.identityNetworkId"`


###### Step 23:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.version"`


###### Step 24:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.version"`


###### Step 25:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.name"`


###### Step 26:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.name"`


###### Step 27:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.thumbnailImage"`


###### Step 28:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.thumbnailImage"`


###### Step 29:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.latitude"`


###### Step 30:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.longitude"`


###### Step 31:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.extraData"`


###### Step 32:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.extraData"`


###### Step 33:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.delete.identityNetworkId"`


###### Step 34:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.name"`


###### Step 35:

The target profile server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.name"`








#### PS08025 - Neighborhood Initialization Process - Fails and Updates Before Retring

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "images/PS08025.jpg" file exists and contains JPEG image with size less than 20 kb
  * "ps.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Base port for simulated profile server


##### Description 

The test simulates a profile server instance and establishes a neighborhood relationship with the target profile server 
by invoking the neighborhood initialization process. Before it completes the process, it creates new identities. 
The initialization process then fails to complete and the test tries it again. Then the test creates more identities. 
The test's simulated profile server must receive all profiles from the target server.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test creates a primary identity which it uses to simulate another profile server and then 
it creates 10 test identities, establishes hosting agreements with the profile server for them, 
and initializes their profiles.

The test then creates a server, on which it simulates part of the profile server behavior.
The simulated profile server uses the base port ($BasePort) as its primary port and $BasePort+1 as its srNeighbor port.


###### Step 2:

The test then connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := $BasePort + 1`
 
and reads the response. 


###### Step 3:

The test creates 5 more identities, establishes hosting agreements with the profile server for them 
and initializes their profiles. 


###### Step 4:

The test waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives *FinishNeighborhoodInitializationRequest*.

###### Step 5:

The test creates 5 more identities, establishes hosting agreements with the profile server for them 
and initializes their profiles. 


###### Step 6:

The test disconnects and waits 20 seconds.


###### Step 7:

The test creates 5 more identities, establishes hosting agreements with the profile server for them 
and initializes their profiles. 

Test waits 20 seconds and checks that no updates have been received on its simulated profile server.


###### Step 8:

The test then connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := $BasePort + 1`
 
and reads the response. 

The test waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives *FinishNeighborhoodInitializationResponse*, to which the test replies with corresponding 
*FinishNeighborhoodInitializationResponse* message.


###### Step 9:

The test creates 5 more identities, establishes hosting agreements with the profile server for them 
and initializes their profiles. 

Then it waits 20 seconds.


###### Step 10:

The test waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages.



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes hosting agreements for its test identities.
Then the test successfully initializes all test profiles. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


###### Step 3:

The test successfully establishes hosting agreements for the new test identities.
Then the test successfully initializes all new profiles. 


###### Step 4:

The server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about hosted profiles.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 5:

The test successfully establishes hosting agreements for the new test identities.
Then the test successfully initializes all new profiles. 


###### Step 6:

Nothing to check.


###### Step 7:

The test successfully establishes hosting agreements for the new test identities.
Then the test successfully initializes all new profiles. 


###### Step 8:

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

The server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about hosted profiles.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 9:

The test successfully establishes hosting agreements for the new test identities.
Then the test successfully initializes all new profiles. 


###### Step 10:

The simulated profile server received neighborhood updates in form of *NeighborhoodSharedProfileUpdateRequest* 
and together with the initialization process it received information about all the test identities.









#### PS08026 - Neighborhood Initialization Process - Already Exists 2

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "images/PS08026.jpg" file exists and contains JPEG image with size less than 20 kb
  * "ps.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Base port for simulated profile server


##### Description 

The test simulates a profile server instance and establishes a neighborhood relationship with the target profile server 
by invoking the neighborhood initialization process. Before it completes the process, it creates new identities 
and creates a second connection to the target profile server and invokes a second neighborhood initialization process. 

The initialization process then fails to complete and the test tries it again. Then the test creates more identities. 
The test's simulated profile server must receive all profiles from the target server.


###### Step 1:

The test obtains a list of service ports from the profile server's primary port.

The test creates a primary identity which it uses to simulate another profile server and then 
it creates 10 test identities, establishes hosting agreements with the profile server for them, 
and initializes their profiles.

The test then creates a server, on which it simulates part of the profile server behavior.
The simulated profile server uses the base port ($BasePort) as its primary port and $BasePort+1 as its srNeighbor port.


###### Step 2:

The test then connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := $BasePort + 1`
 
and reads the response. 

The test waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages, up until 
the test receives *FinishNeighborhoodInitializationRequest*.


###### Step 3:

The test creates 5 more identities, establishes hosting agreements with the profile server for them 
and initializes their profiles. 


###### Step 4:

With its second client but the same identity, the test connects to profile server's srNeighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.srNeighborPort := $BasePort + 1`
 
and reads the response and closes the connection.


###### Step 5:

Using the first client the test sends *FinishNeighborhoodInitializationResponse* message.

The test disconnects and waits 20 seconds.


###### Step 6:

Using the first client the test waits for a series of *NeighborhoodSharedProfileUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedProfileUpdateResponse* messages.

The test checks the identities received by its first client.



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the profile server provides its services. 
Then the test successfully establishes hosting agreements for its test identities.
Then the test successfully initializes all test profiles. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

The server sends a series of *NeighborhoodSharedProfileUpdateRequest* messages with information about hosted profiles.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 3:

The test successfully establishes hosting agreements for the new test identities.
Then the test successfully initializes all new profiles. 


###### Step 4:

Then the test successfully verifies its identity.

The target profile server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

The target profile server replies with *Response*:
  
  * `Message.id == 4`
  * `Response.status == ERROR_ALREADY_EXISTS`


###### Step 5:

Nothing to check.


###### Step 6:

The target profile server sends *NeighborhoodSharedProfileUpdateRequest* with updates containing information about the newly created profiles.

The simulated profile server received neighborhood updates in form of *NeighborhoodSharedProfileUpdateRequest* 
and together with the initialization process it received information about all the test identities.








