### HN02xxx - Node Client Non-Customer Port Functionality Tests

#### HN02001 - Client Non-Customer Port Ping

##### Prerequisites/Inputs

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 
The test sends a ping request to the node and expects to receive a ping response.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the node and sends *PingRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `PingRequest.payload := "Hello"`

and reads the response.

##### Acceptance Criteria

###### Step 1:

Node replies with *PingResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `PingResponse.payload == "Hello"`
  * `PingResponse.clock` does not differ more than 10 minutes from the test's machine clock.









#### HN02002 - Invalid Role Request - List Roles

##### Prerequisites/Inputs

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test requests a list of node's roles on its clNonCustomer port, but *ListRolesRequest* request requires the primary port to be used.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the node and sends *ListRolesRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  
and reads the response.


##### Acceptance Criteria

###### Step 1:
Node replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_BAD_ROLE`







#### HN02003 - Start Conversation

##### Prerequisites/Inputs

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test starts conversation with the node.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity's 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response
  
##### Acceptance Criteria

###### Step 1:
Node replies with *StartConversationResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.version == [1,0,0]`
  * `StartConversationResponse.publicKey.Length == 32`
  * `StartConversationResponse.challenge.Length == 32`
  * `StartConversationResponse.clientChallenge == $ClientChallenge`












#### HN02004 - Start Conversation - Unsupported Version

##### Prerequisites/Inputs

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test starts the conversation with the node but no version of the protocol is supported by both sides.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[255,255,255], [255,255,254]]`
  * `StartConversationRequest.publicKey` set to the test identity's 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:
Node replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_UNSUPPORTED`







#### HN02005 - Home Node Request

##### Prerequisites/Inputs

###### Prerequisites:
  * Node's database is empty.

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test identity establishes a home node agreement with the node. Note that the home node contract is empty at this stage.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity's 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *HomeNodeRequestRequest*:

  * `Message.id := 2`
  * `HomeNodeRequestRequest.contract` is uninitialized

and reads the response.

  
##### Acceptance Criteria

###### Step 1:
Node replies with *StartConversationResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.version == [1,0,0]`
  * `StartConversationResponse.publicKey.Length == 32`
  * `StartConversationResponse.challenge.Length == 32`
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Node replies with *HomeNodeRequestResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`








#### HN02006 - Home Node Request - Bad Conversation Status

##### Prerequisites/Inputs

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test sends *HomeNodeRequestRequest* to the node without starting the conversation first.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *HomeNodeRequestRequest*:

  * `Message.id := 1`
  * `HomeNodeRequestRequest.contract` is uninitialized
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:
Node replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_BAD_CONVERSATION_STATUS`







#### HN02007 - Home Node Request - Quota Exceeded

##### Prerequisites/Inputs

###### Prerequisites:
  * Node is configured to host 1 identity at maximum.
  * Node's database is empty.

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test identity #1 establishes a home node agreement with the node. Then the test tries to establish a home node agreement for its identity #2, which should fail due to the node's quota.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity #1 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *HomeNodeRequestRequest*:

  * `Message.id := 2`
  * `HomeNodeRequestRequest.contract` is uninitialized
  
and reads the response.
  
###### Step 2:
The test then closes the connection and creates a new TLS connection to the clNonCustomer port and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity #2 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response. Then it sends *HomeNodeRequestRequest*:

  * `Message.id := 2`
  * `HomeNodeRequestRequest.contract` is uninitialized

and reads the response.
  
##### Acceptance Criteria


###### Step 1:

Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`


Node replies with *HomeNodeRequestResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Node replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_QUOTA_EXCEEDED`












#### HN02008 - Home Node Request - Already Exists

##### Prerequisites/Inputs

###### Prerequisites:
  * Node's database is empty.

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test establishes a home node agreement with the node. Then it tries to establish a new agreement with the same identity, which should fail.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *HomeNodeRequestRequest*:

  * `Message.id := 2`
  * `HomeNodeRequestRequest.contract` is uninitialized

and reads the response.
 
###### Step 2:
The test then closes the connection and creates a new TLS connection to the clNonCustomer port and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response. Then it sends *HomeNodeRequestRequest*:

  * `Message.id := 2`
  * `HomeNodeRequestRequest.contract` is uninitialized

and reads the response.

##### Acceptance Criteria


###### Step 1:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Node replies with *HomeNodeRequestResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`
                                                                  
Node replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_ALREADY_EXISTS`








#### HN02009 - Verify Identity

##### Prerequisites/Inputs

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer

##### Description 

The test establishes a conversation with the node and verifies its public key by signing a challenge.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Node replies with *VerifyIdentityResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`








#### HN02010 - Verify Identity - Invalid Signature

##### Prerequisites/Inputs

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer

##### Description 

The test establishes a conversation with the node and tries to verify its public key by signing a challenge, but it provides invalid signature.

###### Step 1:
The test establishes a TLS connection to the clCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the node in form of *StartConversationResponse*:
  
  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key, but the first byte of the signature is XORed with 0x12 to make the signature invalid.
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`


Node replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_SIGNATURE`







#### HN02011 - Verify Identity - Invalid Challenge

##### Prerequisites/Inputs

###### Prerequisites:
  * Node's database is empty.
  
###### Inputs:
  * Node's IP address
  * Node's clNonCustomer

##### Description 

The test establishes a conversation with the node and tries to verify its public key by signing a challenge, but it provides invalid challenge.

###### Step 1:
The test establishes a TLS connection to the clCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the node in form of *StartConversationResponse*:
  
  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`, but the first byte of the challenge is XORed with 0x12 to make the challenge invalid
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`


Node replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "challenge"`








#### HN02012 - Verify Identity - Bad Conversation Status

##### Prerequisites/Inputs

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test sends verify identity request to the node without starting the conversation first.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *VerifyIdentityRequest*:

  * `Message.id := 1`
  * `VerifyIdentityRequest.challenge` is uninitialized
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:
Node replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_BAD_CONVERSATION_STATUS`








#### HN02013 - Parallel Verify Identity Requests

##### Prerequisites/Inputs
###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test verifies its identity and then it verifies its identity again in a second parallel connection. Then it verifies that the first connection is still active by sending a ping.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response.

###### Step 2:
With the first connection left open, the test establishes a new TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response.

###### Step 3:

Using the first connection the test attempts to send *PingRequest*:

  * `Message.id := 3`
  * `SingleRequest.version := [1,0,0]`
  * `PingRequest.payload = "test"`
  
and reads the response.


##### Acceptance Criteria


###### Step 1:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Node replies with *VerifyIdentityResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Node replies with *VerifyIdentityResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

###### Step 3:

Node replies with *PingResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`
  * `PingResponse.payload == "test"`










#### HN02014 - Check-In - Bad Role

##### Prerequisites/Inputs

###### Prerequisites:
  * Node's clNonCustomer port != clCustomer port

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test sends check-in request to the clNonCustomer port, but *CheckInRequest* requires clCustomer port to be used.

###### Step 1:

The test connects to the primary port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity's 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
 
and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response.


##### Acceptance Criteria

###### Step 1:

Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Node replies with *Response*:
  
  * `Message.id == 2`
  * `Response.status == ERROR_BAD_ROLE`








#### HN02015 - Get Identity Information - Uninitialized

##### Prerequisites/Inputs

###### Prerequisites:
  * Node's database is empty.

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test establishes a home node agreement with the node and attempts to query its details, which should fail as the new profile is not initialized yet.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *HomeNodeRequestRequest*:

  * `Message.id := 2`
  * `HomeNodeRequestRequest.contract` is uninitialized
  
and reads the response. The test it sends *GetIdentityInformationRequest*:

  * `Message.id := 3`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId` is set to SHA256 of test's identity public key
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := false`
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Node replies with *HomeNodeRequestResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Node replies with *Response*:

  * `Message.id == 3`
  * `Response.status == ERROR_UNINITIALIZED`








#### HN02016 - Get Identity Information - Unknown Identity

##### Prerequisites/Inputs

###### Prerequisites:
  * Node's database is empty.

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test queries details about identity that is not hosted on the node.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *GetIdentityInformationRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId := SHA256("test")`
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := false`
  
and reads the response. 
  
##### Acceptance Criteria


###### Step 1:
Node replies with *Response*:

  * `Message.id == 1`
  * `Response.status == ERROR_NOT_FOUND`










#### HN02017 - Verify Identity, Update Profile - Bad Role

##### Prerequisites/Inputs
###### Prerequisites:
  * Node's clNonCustomer port != clCustomer port

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test verifies its identity on clNonCustomer port. Then it attempts to update its profile, which requires clCustomer port and Authenticated status.


###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`


Then it sends *HomeNodeRequestRequest*:

  * `Message.id := 2`
  * `HomeNodeRequestRequest.contract` is uninitialized
  
and reads the response. Then it sends *VerifyIdentityRequest*:

  * `Message.id := 3`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 4`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 0`
  * `UpdateProfileRequest.longitude := 0`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response.


##### Acceptance Criteria


###### Step 1:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Node replies with *HomeNodeRequestResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Node replies with *VerifyIdentityResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Node replies with *Response*:

  * `Message.id == 4`
  * `Response.status == ERROR_BAD_ROLE`









#### HN02018 - Call Identity Application Service - Unauthorized 1

##### Prerequisites/Inputs

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test sends *CallIdentityApplicationServiceRequest* to the node without starting the conversation first.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 1`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := SHA256("test")`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:
Node replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_UNAUTHORIZED`







#### HN02019 - Call Identity Application Service - Unauthorized 2

##### Prerequisites/Inputs

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test sends *CallIdentityApplicationServiceRequest* to the node without verifying its identity firts.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response. Then it sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 2`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := SHA256("test")`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Node replies with *Response*:
  
  * `Message.id == 2`
  * `Response.status == ERROR_UNAUTHORIZED`








#### HN02020 - Call Identity Application Service - Invalid Id

##### Prerequisites/Inputs

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer

##### Description 

The test tries to call identity that is not hosted on the node.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId := SHA256("test")`
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Node replies with *VerifyIdentityResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Node replies with *Response*:
  
  * `Message.id == 3`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "identityNetworkId"`







#### HN02021 - Call Identity Application Service - Uninitialized

##### Prerequisites/Inputs

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer

##### Description 

The test tries to call identity which profile has not been initialized yet.

###### Step 1:

The test creates a first identity and establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`


Then it sends *HomeNodeRequestRequest*:

  * `Message.id := 2`
  * `HomeNodeRequestRequest.contract` is uninitialized
  
and reads the response and then closes the connection.


###### Step 2:
The test creates a second identity and using it it establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`
  
and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *CallIdentityApplicationServiceRequest*:

  * `Message.id := 3`
  * `CallIdentityApplicationServiceRequest.identityNetworkId` is set to network ID of the first identity
  * `CallIdentityApplicationServiceRequest.serviceName := "Test Service"`
  
and reads the response.

  
##### Acceptance Criteria

###### Step 1:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Node replies with *HomeNodeRequestResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Node replies with *VerifyIdentityResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Node replies with *Response*:
  
  * `Message.id == 3`
  * `Response.status == ERROR_UNINITIALIZED`











#### HN02022 - Start Conversation - Invalid Challenge

##### Prerequisites/Inputs

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test starts the conversation with the node but it sends invalid client challenge in the requests.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity's 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 4 byte random challenge
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:
Node replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "clientChallenge"`








#### HN02023 - Profile Stats

##### Prerequisites/Inputs

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test creates 10 new identities and establishes home node contracts for all of them. Then it asks the node for profile statistics.


###### Step 1:

The test creates 8 identities with following identity types:

  * 2x "Type A"
  * 3x "Type B"
  * 1x "Type Alpha"
  * 1x "Type A B"
  * 1x "Type Beta"

and then with each identity it connects to clNonCustomer port and establishes a home node contract. 

The test establishes a new TLS connection to clNonCustomer and sends *ProfileStatsRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`

and reads the response.


###### Step 2:

The test creates 2 more identities with following identity types:

  * 1x `Type A B`
  * 1x `Type C`

and then with each identity it connects to clNonCustomer port and establishes a home node contract. 

Then it reuses the previous connection used for sending *ProfileStatsRequest* and sends *ProfileStatsRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`

and reads the response.


  
##### Acceptance Criteria

###### Step 1:

Test successfully establishes the home node contracts.

Node replies with *ProfileStatsResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ProfileStatsResponse.stats.Count == 5`
  * `ProfileStatsResponse.stats == 
    (
      {identityType == "Type A", count == 2},
      {identityType == "Type B", count == 3},
      {identityType == "Type Alpha", count == 1},
      {identityType == "Type A B", count == 1},
      {identityType == "Type Beta", count == 1}
    )`


###### Step 2:

Test successfully establishes the home node contracts.

Node replies with *ProfileStatsResponse*:
  
  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `ProfileStatsResponse.stats.Count == 6`
  * `ProfileStatsResponse.stats == 
    (
      {identityType == "Type A", count == 2},
      {identityType == "Type B", count == 3},
      {identityType == "Type Alpha", count == 1},
      {identityType == "Type A B", count == 2},
      {identityType == "Type Beta", count == 1}
      {identityType == "Type C", count == 1},
    )`






#### HN02024 - Profile Stats - No Stats

##### Prerequisites/Inputs

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test asks the node for profile statistics when node has an empty database.


###### Step 1:

The test establishes a new TLS connection to clNonCustomer and sends *ProfileStatsRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`

and reads the response.


  
##### Acceptance Criteria

###### Step 1:

Node replies with *ProfileStatsResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ProfileStatsResponse.stats.Count == 0`






#### HN02025 - Profile Search - Bad Conversation Status

##### Prerequisites/Inputs

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test sends *ProfileSearchRequest* request to the node without starting the conversation first.

###### Step 1:

The test connects to the primary port of the node and sends *ProfileSearchRequest*:

  * `Message.id := 1`
  * `ProfileSearchRequest.includeHostedOnly := false`
  * `ProfileSearchRequest.includeThumbnailImages := true`
  * `ProfileSearchRequest.maxResponseRecordCount := 100`
  * `ProfileSearchRequest.maxTotalRecordCount := 1000`
  * `ProfileSearchRequest.type := ""`
  * `ProfileSearchRequest.name := ""`
  * `ProfileSearchRequest.latitude := NO_LOCATION`
  * `ProfileSearchRequest.longitude := NO_LOCATION`
  * `ProfileSearchRequest.radius := 0`
  * `ProfileSearchRequest.extraData := ""`

and reads the response.


##### Acceptance Criteria

###### Step 1:

Node replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_BAD_CONVERSATION_STATUS`





#### HN02026 - Profile Search Part - Bad Conversation Status

##### Prerequisites/Inputs

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test sends *ProfileSearchPartRequest* request to the node without starting the conversation first.

###### Step 1:

The test connects to the primary port of the node and sends *ProfileSearchPartRequest*:

  * `Message.id := 1`
  * `ProfileSearchPartRequest.recordIndex := 0`
  * `ProfileSearchPartRequest.recordCount := 10`
 
and reads the response.


##### Acceptance Criteria

###### Step 1:

Node replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_BAD_CONVERSATION_STATUS`





#### HN02027 - Start Conversation - Invalid Public Key

##### Prerequisites/Inputs

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port

##### Description 

The test starts the conversation with the node but it uses invalid public key.

###### Step 1:

The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey := []`
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge
  
and reads the response. Then it sends *StartConversationRequest*:

  * `Message.id := 2`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to array of 130x 0x40 
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge
  
and reads the response.
  
##### Acceptance Criteria

###### Step 1:

Node replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "publicKey"`


Node replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "publicKey"`



