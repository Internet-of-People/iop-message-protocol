### PS04xxx - Combined Client Customer and Non-Customer Port Functionality Tests

#### PS04001 - Check-In - Different Customer and Non-Customer Ports

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * Server's clNonCustomer port != clCustomer port

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test establishes a hosting agreement with the profile server. Then it performs the check-in process.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `RegisterHostingResponse.contract` is same as `RegisterHostingRequest.contract` the client sent
  * `ConversationResponse.signature` is a valid signature of `RegisterHostingResponse.contract`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`







#### PS04002 - Check-In - Same Customer and Non-Customer Ports

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * Server's clNonCustomer port == clCustomer port

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer/clCustomer port

##### Description 

The test establishes a hosting agreement with the profile server and continues with the check-in process on the same port.

###### Step 1:
The test establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`
  
and reads the response. The test it sends *CheckInRequest*:

  * `Message.id := 3`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `RegisterHostingResponse.contract` is same as `RegisterHostingRequest.contract` the client sent
  * `ConversationResponse.signature` is a valid signature of `RegisterHostingResponse.contract`

Server replies with *CheckInResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`








#### PS04003 - Check-In - Invalid Signature

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test establishes a hosting agreement with the profile server. Then it performs the check-in process but it uses invalid signature.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key, but the first byte of the signature is XORed with 0x12 to make the signature invalid.
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `RegisterHostingResponse.contract` is same as `RegisterHostingRequest.contract` the client sent
  * `ConversationResponse.signature` is a valid signature of `RegisterHostingResponse.contract`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_SIGNATURE`








#### PS04004 - Check-In - Invalid Challenge

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test establishes a hosting agreement with the profile server. Then it performs the check-in process but it uses invalid challenge.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`, but the first byte of the challenge is XORed with 0x12 to make the challenge invalid
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `RegisterHostingResponse.contract` is same as `RegisterHostingRequest.contract` the client sent
  * `ConversationResponse.signature` is a valid signature of `RegisterHostingResponse.contract`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "challenge"`












#### PS04005 - Cancel Hosting Agreement, Register Again and Check-In

##### Prerequisites/Inputs
###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test cancels hosting agreement for its hosted identity. It then attempts to check-in the identity, which should fail because it is no longer hosted on the profile server. Then it establishes a new hosting agreement and then it checks-in.

###### Step 1:
The test establishes a hosting agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *CancelHostingAgreementRequest*:

  * `Message.id := 3`
  * `CancelHostingAgreementRequest.redirectToNewProfileServer := false`
  * `CancelHostingAgreementRequest.newProfileServerNetworkId` is uninitialized

and reads the response.


###### Step 3:
The test closes the connection and establishes a new TLS connection to the clCustomer port and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response and closes the connection. 

###### Step 4:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge3 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`

and reads the response.



###### Step 5:
The test closes the connection and establishes a new TLS connection to the clCustomer port and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge4 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. 

  
##### Acceptance Criteria


###### Step 1:
The test successfully establishes a hosting agreement for its identity.

###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *CancelHostingAgreementResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`
  
  
###### Step 3:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_NOT_FOUND`

###### Step 4:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge3
  * `StartConversationResponse.clientChallenge == $ClientChallenge3`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `RegisterHostingResponse.contract` is same as `RegisterHostingRequest.contract` the client sent
  * `ConversationResponse.signature` is a valid signature of `RegisterHostingResponse.contract`
  
###### Step 5:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge4
  * `StartConversationResponse.clientChallenge == $ClientChallenge4`

Server replies with *CheckInRequest*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`









#### PS04006 - Register Hosting, Update Profile, Get Profile Information 

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "images/ProfileImage1.jpg" file exists and contains JPEG image with size less than 20 kb, `$ProfileImageData := contents of this file`
  * "images/ThumbnailImage1.jpg" file exists and contains JPEG image with size less than 5 kb, `$ThumbnailImageData := contents of this file`

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test establishes a hosting agreement with the profile server. Then it checks-in and initializes its profile. Then it queries its profile. Then it updates it again and queries it once more.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key; `$PublicKey := StartConversationRequest.publicKey`
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey := $PublicKey`
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 3`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Identity"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *GetProfileInformationRequest*:

  * `Message.id := 4`
  * `SingleRequest.version := [1,0,0]`
  * `GetProfileInformationRequest.identityNetworkId` is set to SHA256 of test's identity public key
  * `GetProfileInformationRequest.includeProfileImage := false`
  * `GetProfileInformationRequest.includeThumbnailImage := false`
  * `GetProfileInformationRequest.includeApplicationServices := false`


and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 5`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Identity Renamed"`
  * `UpdateProfileRequest.profile.latitude := -1`
  * `UpdateProfileRequest.profile.longitude := -2`
  * `UpdateProfileRequest.profile.extraData := "a=b"`
  * `UpdateProfileRequest.profile.profileImageHash := SHA256($ProfileImageData)`
  * `UpdateProfileRequest.profile.thumbnailImageHash := SHA256($ThumbnailImageData)`
  * `UpdateProfileRequest.profileImage := $ProfileImageData`
  * `UpdateProfileRequest.thumbnailImage := $ThumbnailImageData`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *GetProfileInformationRequest*:

  * `Message.id := 6`
  * `SingleRequest.version := [1,0,0]`
  * `GetProfileInformationRequest.identityNetworkId` is set to SHA256 of test's identity public key
  * `GetProfileInformationRequest.includeProfileImage := true`
  * `GetProfileInformationRequest.includeThumbnailImage := true`
  * `GetProfileInformationRequest.includeApplicationServices := false`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 7`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Identity Renamed"`
  * `UpdateProfileRequest.profile.latitude := -1`
  * `UpdateProfileRequest.profile.longitude := -2`
  * `UpdateProfileRequest.profile.extraData := "a=b"`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := SHA256($ThumbnailImageData)`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := $ThumbnailImageData`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *GetProfileInformationRequest*:

  * `Message.id := 8`
  * `SingleRequest.version := [1,0,0]`
  * `GetProfileInformationRequest.identityNetworkId` is set to SHA256 of test's identity public key
  * `GetProfileInformationRequest.includeProfileImage := true`
  * `GetProfileInformationRequest.includeThumbnailImage := true`
  * `GetProfileInformationRequest.includeApplicationServices := false`



  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `RegisterHostingResponse.contract` is same as `RegisterHostingRequest.contract` the client sent
  * `ConversationResponse.signature` is a valid signature of `RegisterHostingResponse.contract`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *UpdateProfileResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server replies with *GetProfileInformationResponse*:

  * `Message.id == 4`
  * `Response.status == STATUS_OK`
  * `GetProfileInformationResponse.isHosted == true`
  * `GetProfileInformationResponse.isOnline == true`
  * `GetProfileInformationResponse.signedProfile.profile.version == [1,0,0]`
  * `GetProfileInformationResponse.signedProfile.profile.publicKey == $PublicKey`
  * `GetProfileInformationResponse.signedProfile.profile.type == "Test Type"`
  * `GetProfileInformationResponse.signedProfile.profile.name == "Test Identity"`
  * `GetProfileInformationResponse.signedProfile.profile.latitude == 1`
  * `GetProfileInformationResponse.signedProfile.profile.longitude == 2`
  * `GetProfileInformationResponse.signedProfile.profile.extraData == ""`
  * `GetProfileInformationResponse.signedProfile.profile.profileImageHash == []`
  * `GetProfileInformationResponse.signedProfile.profile.thumbnailImageHash == []`
  * `GetProfileInformationResponse.signedProfile.signature` is a valid signature of `GetProfileInformationResponse.signedProfile.profile`
  * `GetProfileInformationResponse.profileImage == []`
  * `GetProfileInformationResponse.thumbnailImage == []`

Server replies with *UpdateProfileResponse*:

  * `Message.id == 5`
  * `Response.status == STATUS_OK`

Server replies with *GetProfileInformationResponse*:

  * `Message.id == 6`
  * `Response.status == STATUS_OK`
  * `GetProfileInformationResponse.isHosted == true`
  * `GetProfileInformationResponse.isOnline == true`
  * `GetProfileInformationResponse.signedProfile.profile.version == [1,0,0]`
  * `GetProfileInformationResponse.signedProfile.profile.publicKey == $PublicKey`
  * `GetProfileInformationResponse.signedProfile.profile.type == "Test Type"`
  * `GetProfileInformationResponse.signedProfile.profile.name == "Test Identity Renamed"`
  * `GetProfileInformationResponse.signedProfile.profile.latitude == -1`
  * `GetProfileInformationResponse.signedProfile.profile.longitude == -2`
  * `GetProfileInformationResponse.signedProfile.profile.extraData == "a=b"`
  * `GetProfileInformationResponse.signedProfile.profile.profileImageHash == SHA256($ProfileImageData)`
  * `GetProfileInformationResponse.signedProfile.profile.thumbnailImageHash == SHA256($ThumbnailImageData)`
  * `GetProfileInformationResponse.signedProfile.signature` is a valid signature of `GetProfileInformationResponse.signedProfile.profile`
  * `GetProfileInformationResponse.profileImage == $ProfileImageData`
  * `GetProfileInformationResponse.thumbnailImage == $ThumbnailImageData`

Server replies with *UpdateProfileResponse*:

  * `Message.id == 7`
  * `Response.status == STATUS_OK`

Server replies with *GetProfileInformationResponse*:

  * `Message.id == 8`
  * `Response.status == STATUS_OK`
  * `GetProfileInformationResponse.isHosted == true`
  * `GetProfileInformationResponse.isOnline == true`
  * `GetProfileInformationResponse.signedProfile.profile.version == [1,0,0]`
  * `GetProfileInformationResponse.signedProfile.profile.publicKey == $PublicKey`
  * `GetProfileInformationResponse.signedProfile.profile.type == "Test Type"`
  * `GetProfileInformationResponse.signedProfile.profile.name == "Test Identity Renamed"`
  * `GetProfileInformationResponse.signedProfile.profile.latitude == -1`
  * `GetProfileInformationResponse.signedProfile.profile.longitude == -2`
  * `GetProfileInformationResponse.signedProfile.profile.extraData == "a=b"`
  * `GetProfileInformationResponse.signedProfile.profile.profileImageHash == []`
  * `GetProfileInformationResponse.signedProfile.profile.thumbnailImageHash == []`
  * `GetProfileInformationResponse.signedProfile.signature` is a valid signature of `GetProfileInformationResponse.signedProfile.profile`
  * `GetProfileInformationResponse.profileImage == []`
  * `GetProfileInformationResponse.thumbnailImage == []`
















#### PS04007 - Update Profile - Invalid Initialization and Invalid Values

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "images/ProfileImage1.jpg" file exists and contains JPEG image with size less than 20 kb, `$ProfileImageData := contents of this file`
  * "images/ThumbnailImage1.jpg" file exists and contains JPEG image with size less than 5 kb, `$ThumbnailImageData := contents of this file`
  * "images/TooBigImage1.jpg" file exists and contains JPEG image with size greater than 20 kb, `$TooBigImageData := contents of this file`
  * "images/NotImage1.jpg" file exists and contains a single byte 0x41, `$NotImageData := contents of this file`

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test establishes a hosting agreement with the profile server. Then it checks-in and attempts to repeatedly update its profile, but always fails to fill in all required fields for the profile initialization. Then it tries to update the profile with invalid values. Then it initializes the profile correctly and it attempts to send empty update request.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key; `$PublicKey := StartConversationRequest.publicKey`
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey := $PublicKey`
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 3`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is an otherwise valid signature of `UpdateProfileRequest.profile` with first byte XORed with 0x12 

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 4`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature := [1,2,3]`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 5`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is initialized to array of 300 bytes 0x12

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 6`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := true`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`


and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 7`
  * `UpdateProfileRequest.profile.version := [0,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 8`
  * `UpdateProfileRequest.profile.version := [255,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 9`
  * `UpdateProfileRequest.profile.version := [1,2]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 10`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey := [1,2,3]`
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 11`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key with first byte XORed with 0x12
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 12`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Different Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 13`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type` is set to string containing 100x 'a'
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 14`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := ""`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 15`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name` is set to string containing 100x 'a'
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 16`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name` is set to string containing 50x 'ɐ' (UTF8 code 0xc990), which consumes 2 bytes per character
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 17`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := -90,000,001`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 18`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 180,000,001`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 19`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := -90,000,001`
  * `UpdateProfileRequest.profile.longitude := 180,000,001`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 20`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData` is set to string containing 300x 'a'
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 21`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData` is set to string containing 150x 'ɐ' (UTF8 code 0xc990), which consumes 2 bytes per character
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 22`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := [1]`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 23`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash` set to byte array with 35x bytes 0x12
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 24`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := [1]`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 25`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []` 
  * `UpdateProfileRequest.profile.thumbnailImageHash` set to byte array with 35x bytes 0x12
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 26`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := SHA256("test")`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := $ProfileImageData`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 27`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := SHA256($TooBigImageData)`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := $TooBigImageData`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 28`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := SHA256($NotImageData)`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := $NotImageData`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 29`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := SHA256("test")`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := $ThumbnailImageData`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 30`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := SHA256($TooBigImageData)`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := $TooBigImageData`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 31`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := SHA256($NotImageData)`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := $NotImageData`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `RegisterHostingResponse.contract` is same as `RegisterHostingRequest.contract` the client sent
  * `ConversationResponse.signature` is a valid signature of `RegisterHostingResponse.contract`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *Response*:

  * `Message.id == 3`
  * `Response.status == ERROR_INVALID_SIGNATURE`

Server replies with *Response*:

  * `Message.id == 4`
  * `Response.status == ERROR_INVALID_SIGNATURE`

Server replies with *Response*:

  * `Message.id == 5`
  * `Response.status == ERROR_INVALID_SIGNATURE`

Server replies with *Response*:

  * `Message.id == 6`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "noPropagation"`

Server replies with *Response*:

  * `Message.id == 7`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profile.version"`

Server replies with *Response*:

  * `Message.id == 8`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profile.version"`

Server replies with *Response*:

  * `Message.id == 9`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profile.version"`

Server replies with *Response*:

  * `Message.id == 10`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profile.publicKey"`

Server replies with *Response*:

  * `Message.id == 11`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profile.publicKey"`

Server replies with *Response*:

  * `Message.id == 12`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profile.type"`

Server replies with *Response*:

  * `Message.id == 13`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profile.type"`

Server replies with *Response*:

  * `Message.id == 14`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profile.name"`

Server replies with *Response*:

  * `Message.id == 15`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profile.name"`

Server replies with *Response*:

  * `Message.id == 16`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profile.name"`

Server replies with *Response*:

  * `Message.id == 17`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profile.latitude"`

Server replies with *Response*:

  * `Message.id == 18`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profile.longitude"`

Server replies with *Response*:

  * `Message.id == 19`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profile.latitude"` OR `Response.details == "profile.longitude"`

Server replies with *Response*:

  * `Message.id == 20`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profile.extraData"`

Server replies with *Response*:

  * `Message.id == 21`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profile.extraData"`

Server replies with *Response*:

  * `Message.id == 22`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profile.profileImageHash"`

Server replies with *Response*:

  * `Message.id == 23`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profile.profileImageHash"`

Server replies with *Response*:

  * `Message.id == 24`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profile.thumbnailImageHash"`

Server replies with *Response*:

  * `Message.id == 25`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profile.thumbnailImageHash"`

Server replies with *Response*:

  * `Message.id == 26`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profileImage"`

Server replies with *Response*:

  * `Message.id == 27`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profileImage"`

Server replies with *Response*:

  * `Message.id == 28`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "profileImage"`

Server replies with *Response*:

  * `Message.id == 29`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "thumbnailImage"`

Server replies with *Response*:

  * `Message.id == 30`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "thumbnailImage"`

Server replies with *Response*:

  * `Message.id == 31`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "thumbnailImage"`









#### PS04008 - Verify Identity, Update Profile - Unauthorized

##### Prerequisites/Inputs
###### Prerequisites:
  * Server's database is empty.
  * Server's clNonCustomer port == clCustomer port

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer/clCustomer port

##### Description 

The test verifies its identity on clNonCustomer/clCustomer port. Then it attempts to update its profile, which requires Authenticated status.


###### Step 1:
The test establishes a hosting agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 3`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response.


##### Acceptance Criteria


###### Step 1:
The test successfully establishes a hosting agreement for its identity.

###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *VerifyIdentityResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *Response*:

  * `Message.id == 3`
  * `Response.status == ERROR_UNAUTHORIZED`









#### PS04009 - Cancel Hosting Agreement - Redirection

##### Prerequisites/Inputs
###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test cancels hosting agreement for its hosted identity and sets up a redirect to a new profile server. It then verifies that this redirect has been installed.

###### Step 1:
The test establishes a hosting agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *CancelHostingAgreementRequest*:

  * `Message.id := 3`
  * `CancelHostingAgreementRequest.redirectToNewProfileServer := true`
  * `CancelHostingAgreementRequest.newProfileServerNetworkId := SHA256("test")`

and reads the response. Then it sends *GetProfileInformationRequest*:

  * `Message.id := 4`
  * `SingleRequest.version := [1,0,0]`
  * `GetProfileInformationRequest.identityNetworkId` is set to SHA256 of test's identity public key
  * `GetProfileInformationRequest.includeProfileImage = false`
  * `GetProfileInformationRequest.includeThumbnailImage = false`
  * `GetProfileInformationRequest.includeApplicationServices = false`


##### Acceptance Criteria


###### Step 1:
The test successfully establishes a hosting agreement for its identity.

###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *CancelHostingAgreementResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`
  
Server replies with *GetProfileInformationResponse*:

  * `Message.id == 4`
  * `Response.status == STATUS_OK`
  * `GetProfileInformationResponse.isHosted == false`
  * `GetProfileInformationResponse.isTargetProfileServerKnown == true`
  * `GetProfileInformationResponse.targetProfileServerNetworkId == SHA256("test")`






#### PS04010 - Cancel Hosting Agreement - Invalid New Profile Server Id

##### Prerequisites/Inputs
###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test cancels hosting agreement for its hosted identity and sets up a redirect to a new profile server, but provides invalid new profile server network identifier.

###### Step 1:
The test establishes a hosting agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *CancelHostingAgreementRequest*:

  * `Message.id := 3`
  * `CancelHostingAgreementRequest.redirectToNewProfileServer := true`
  * `CancelHostingAgreementRequest.newProfileServerNetworkId := "test"`

and reads the response.


##### Acceptance Criteria


###### Step 1:
The test successfully establishes a hosting agreement for its identity.

###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *Response*:

  * `Message.id == 3`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "newProfileServerNetworkId"`








#### PS04011 - Parallel Check-Ins

##### Prerequisites/Inputs
###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test checks-in its identity and then it checks it in again in a second parallel connection. This should disconnect the first connection.

###### Step 1:
The test establishes a hosting agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. 

###### Step 3:
With the first connection left open, the test establishes a new TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. 

###### Step 4:

Using the first connection the test attempts to send *PingRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `PingRequest.payload = "test"`

and reads the response. 



##### Acceptance Criteria


###### Step 1:
The test successfully establishes a hosting agreement for its identity.

###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 3:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

###### Step 4:

The first connection should be disconnected and it should not be possible to send the request.













#### PS04012 - Update Profile - Unauthorized

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test asks to update its profile without performing a check-in process first. 

###### Step 1:
The test establishes a hosting agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`

and reads the response.

Then it sends *UpdateProfileRequest*:

  * `Message.id := 2`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Name"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. 

  
##### Acceptance Criteria


###### Step 1:
The test successfully establishes a hosting agreement for its identity.

###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_UNAUTHORIZED`












#### PS04013 - Application Service Add, Remove, Query

##### Prerequisites/Inputs
###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test checks-in its identity and then it adds/deletes/queries its application services. Some of the requests are valid and some are invalid.
Then the test creates a second identity and queries application services of the first one while the first one is offline.


###### Step 1:

The test establishes a hosting agreement using clNonCustomer port and then it closes the connection.


###### Step 2:

The test establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key; `$PublicKey := StartConversationRequest.publicKey`
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 3`
  * `UpdateProfileRequest.profile.version := [1,0,0]`
  * `UpdateProfileRequest.profile.publicKey` set to the test identity public key
  * `UpdateProfileRequest.profile.type := "Test Type"`
  * `UpdateProfileRequest.profile.name := "Test Identity"`
  * `UpdateProfileRequest.profile.latitude := 1`
  * `UpdateProfileRequest.profile.longitude := 2`
  * `UpdateProfileRequest.profile.extraData := ""`
  * `UpdateProfileRequest.profile.profileImageHash := []`
  * `UpdateProfileRequest.profile.thumbnailImageHash := []`
  * `UpdateProfileRequest.profileImage := []`
  * `UpdateProfileRequest.thumbnailImage := []`
  * `UpdateProfileRequest.noPropagation := false`
  * `ConversationRequest.signature` is a valid signature of `UpdateProfileRequest.profile`

and reads the response. Then it sends *ApplicationServiceAddRequest*:

  * `Message.id := 4`
  * `ApplicationServiceAddRequest.serviceNames := ["a","b","c","d","a"]`

and reads the response. Then it sends *GetProfileInformationRequest*:

  * `Message.id := 5`
  * `SingleRequest.version := [1,0,0]`
  * `GetProfileInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetProfileInformationRequest.includeProfileImage := false`
  * `GetProfileInformationRequest.includeThumbnailImage := false`
  * `GetProfileInformationRequest.includeApplicationServices := true`

and reads the response. Then it sends *ApplicationServiceAddRequest*:

  * `Message.id := 6`
  * `ApplicationServiceAddRequest.serviceNames := ["c","d","a","e"]`

and reads the response. Then it sends *GetProfileInformationRequest*:

  * `Message.id := 7`
  * `SingleRequest.version := [1,0,0]`
  * `GetProfileInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetProfileInformationRequest.includeProfileImage := false`
  * `GetProfileInformationRequest.includeThumbnailImage := false`
  * `GetProfileInformationRequest.includeApplicationServices := true`

and reads the response. Then it sends *ApplicationServiceRemoveRequest*:

  * `Message.id := 8`
  * `ApplicationServiceRemoveRequest.serviceName := "a"`

and reads the response. Then it sends *GetProfileInformationRequest*:

  * `Message.id := 9`
  * `SingleRequest.version := [1,0,0]`
  * `GetProfileInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetProfileInformationRequest.includeProfileImage := false`
  * `GetProfileInformationRequest.includeThumbnailImage := false`
  * `GetProfileInformationRequest.includeApplicationServices := true`

and reads the response. Then it sends *ApplicationServiceRemoveRequest*:

  * `Message.id := 10`
  * `ApplicationServiceRemoveRequest.serviceName := "a"`

and reads the response. Then it sends *GetProfileInformationRequest*:

  * `Message.id := 11`
  * `SingleRequest.version := [1,0,0]`
  * `GetProfileInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetProfileInformationRequest.includeProfileImage := false`
  * `GetProfileInformationRequest.includeThumbnailImage := false`
  * `GetProfileInformationRequest.includeApplicationServices := true`

and reads the response. Then it sends *ApplicationServiceAddRequest*:

  * `Message.id := 12`
  * `ApplicationServiceAddRequest.serviceNames := ["d","1234567890-1234567890-1234567890-1234567890","a","e"]`

and reads the response. Then it sends *GetProfileInformationRequest*:

  * `Message.id := 13`
  * `SingleRequest.version := [1,0,0]`
  * `GetProfileInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetProfileInformationRequest.includeProfileImage := false`
  * `GetProfileInformationRequest.includeThumbnailImage := false`
  * `GetProfileInformationRequest.includeApplicationServices := true`

and reads the response. Then it sends *ApplicationServiceAddRequest*:

  * `Message.id := 14`
  * `ApplicationServiceAddRequest.serviceNames := ["a1","a2","a3","a4","a5","a6","a7","a8","a9","a10"]`

and reads the response. Then it sends *ApplicationServiceAddRequest*:

  * `Message.id := 15`
  * `ApplicationServiceAddRequest.serviceNames := ["b1","b2","b3","b4","b5","b6","b7","b8","b9","b10"]`

and reads the response. Then it sends *GetProfileInformationRequest*:

  * `Message.id := 16`
  * `SingleRequest.version := [1,0,0]`
  * `GetProfileInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetProfileInformationRequest.includeProfileImage := false`
  * `GetProfileInformationRequest.includeThumbnailImage := false`
  * `GetProfileInformationRequest.includeApplicationServices := true`

and reads the response. Then it sends *ApplicationServiceAddRequest*:

  * `Message.id := 17`
  * `ApplicationServiceAddRequest.serviceNames := ["c1","c2","c3","c4","c5","c6","c7","c8","c9","c10","d1","d2","d3","d4","d5","d6","d7","d8","d9","d10","e1","e2","e3","e4","e5","e6","e7","e8","e9","e10"]`

and reads the response. Then it sends *GetProfileInformationRequest*:

  * `Message.id := 18`
  * `SingleRequest.version := [1,0,0]`
  * `GetProfileInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetProfileInformationRequest.includeProfileImage := false`
  * `GetProfileInformationRequest.includeThumbnailImage := false`
  * `GetProfileInformationRequest.includeApplicationServices := true`

and reads the response and disconnects.



###### Step 3:

Using a second identity, the test connects to clNonCustomer port and then it sends *GetProfileInformationRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `GetProfileInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetProfileInformationRequest.includeProfileImage := false`
  * `GetProfileInformationRequest.includeThumbnailImage := false`
  * `GetProfileInformationRequest.includeApplicationServices := true`

and reads the response.


                                      

##### Acceptance Criteria


###### Step 1:
The test successfully establishes a hosting agreement for its identity.

###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *UpdateProfileResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceAddResponse*:

  * `Message.id == 4`
  * `Response.status == STATUS_OK`

Server replies with *GetProfileInformationResponse*:

  * `Message.id == 5`
  * `Response.status == STATUS_OK`
  * `GetProfileInformationResponse.isHosted == true`
  * `GetProfileInformationResponse.isOnline == true`
  * `GetProfileInformationResponse.signedProfile.profile.version == [1,0,0]`
  * `GetProfileInformationResponse.signedProfile.profile.publicKey == $PublicKey`
  * `GetProfileInformationResponse.signedProfile.profile.type == "Test Type"`
  * `GetProfileInformationResponse.signedProfile.profile.name == "Test Identity"`
  * `GetProfileInformationResponse.signedProfile.profile.latitude == 0`
  * `GetProfileInformationResponse.signedProfile.profile.longitude == 0`
  * `GetProfileInformationResponse.signedProfile.profile.extraData == ""`
  * `GetProfileInformationResponse.signedProfile.profile.profileImageHash == []`
  * `GetProfileInformationResponse.signedProfile.profile.thumbnailImageHash == []`
  * `GetProfileInformationResponse.signedProfile.signature` is a valid signature of `GetProfileInformationResponse.signedProfile.profile`
  * `GetProfileInformationResponse.profileImage == []`
  * `GetProfileInformationResponse.thumbnailImage == []`
  * `GetProfileInformationResponse.applicationServices == ("a","b","c","d")`

Server replies with *ApplicationServiceAddResponse*:

  * `Message.id == 6`
  * `Response.status == STATUS_OK`

Server replies with *GetProfileInformationResponse*:

  * `Message.id == 7`
  * `Response.status == STATUS_OK`
  * `GetProfileInformationResponse.isHosted == true`
  * `GetProfileInformationResponse.isOnline == true`
  * `GetProfileInformationResponse.signedProfile.profile.version == [1,0,0]`
  * `GetProfileInformationResponse.signedProfile.profile.publicKey == $PublicKey`
  * `GetProfileInformationResponse.signedProfile.profile.type == "Test Type"`
  * `GetProfileInformationResponse.signedProfile.profile.name == "Test Identity"`
  * `GetProfileInformationResponse.signedProfile.profile.latitude == 0`
  * `GetProfileInformationResponse.signedProfile.profile.longitude == 0`
  * `GetProfileInformationResponse.signedProfile.profile.extraData == ""`
  * `GetProfileInformationResponse.signedProfile.profile.profileImageHash == []`
  * `GetProfileInformationResponse.signedProfile.profile.thumbnailImageHash == []`
  * `GetProfileInformationResponse.signedProfile.signature` is a valid signature of `GetProfileInformationResponse.signedProfile.profile`
  * `GetProfileInformationResponse.profileImage == []`
  * `GetProfileInformationResponse.thumbnailImage == []`
  * `GetProfileInformationResponse.applicationServices == ("a","b","c","d","e")`

Server replies with *ApplicationServiceRemoveResponse*:

  * `Message.id == 8`
  * `Response.status == STATUS_OK`

Server replies with *GetProfileInformationResponse*:

  * `Message.id == 9`
  * `Response.status == STATUS_OK`
  * `GetProfileInformationResponse.isHosted == true`
  * `GetProfileInformationResponse.isOnline == true`
  * `GetProfileInformationResponse.signedProfile.profile.version == [1,0,0]`
  * `GetProfileInformationResponse.signedProfile.profile.publicKey == $PublicKey`
  * `GetProfileInformationResponse.signedProfile.profile.type == "Test Type"`
  * `GetProfileInformationResponse.signedProfile.profile.name == "Test Identity"`
  * `GetProfileInformationResponse.signedProfile.profile.latitude == 0`
  * `GetProfileInformationResponse.signedProfile.profile.longitude == 0`
  * `GetProfileInformationResponse.signedProfile.profile.extraData == ""`
  * `GetProfileInformationResponse.signedProfile.profile.profileImageHash == []`
  * `GetProfileInformationResponse.signedProfile.profile.thumbnailImageHash == []`
  * `GetProfileInformationResponse.signedProfile.signature` is a valid signature of `GetProfileInformationResponse.signedProfile.profile`
  * `GetProfileInformationResponse.profileImage == []`
  * `GetProfileInformationResponse.thumbnailImage == []`
  * `GetProfileInformationResponse.applicationServices == ("b","c","d","e")`

Server replies with *Response*:

  * `Message.id == 10`
  * `Response.status == ERROR_NOT_FOUND`

Server replies with *GetProfileInformationResponse*:

  * `Message.id == 11`
  * `Response.status == STATUS_OK`
  * `GetProfileInformationResponse.isHosted == true`
  * `GetProfileInformationResponse.isOnline == true`
  * `GetProfileInformationResponse.signedProfile.profile.version == [1,0,0]`
  * `GetProfileInformationResponse.signedProfile.profile.publicKey == $PublicKey`
  * `GetProfileInformationResponse.signedProfile.profile.type == "Test Type"`
  * `GetProfileInformationResponse.signedProfile.profile.name == "Test Identity"`
  * `GetProfileInformationResponse.signedProfile.profile.latitude == 0`
  * `GetProfileInformationResponse.signedProfile.profile.longitude == 0`
  * `GetProfileInformationResponse.signedProfile.profile.extraData == ""`
  * `GetProfileInformationResponse.signedProfile.profile.profileImageHash == []`
  * `GetProfileInformationResponse.signedProfile.profile.thumbnailImageHash == []`
  * `GetProfileInformationResponse.signedProfile.signature` is a valid signature of `GetProfileInformationResponse.signedProfile.profile`
  * `GetProfileInformationResponse.profileImage == []`
  * `GetProfileInformationResponse.thumbnailImage == []`
  * `GetProfileInformationResponse.applicationServices == ("b","c","d","e")`

Server replies with *Response*:

  * `Message.id == 12`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "serviceNames[1]"`

Server replies with *GetProfileInformationResponse*:

  * `Message.id == 13`
  * `Response.status == STATUS_OK`
  * `GetProfileInformationResponse.isHosted == true`
  * `GetProfileInformationResponse.isOnline == true`
  * `GetProfileInformationResponse.signedProfile.profile.version == [1,0,0]`
  * `GetProfileInformationResponse.signedProfile.profile.publicKey == $PublicKey`
  * `GetProfileInformationResponse.signedProfile.profile.type == "Test Type"`
  * `GetProfileInformationResponse.signedProfile.profile.name == "Test Identity"`
  * `GetProfileInformationResponse.signedProfile.profile.latitude == 0`
  * `GetProfileInformationResponse.signedProfile.profile.longitude == 0`
  * `GetProfileInformationResponse.signedProfile.profile.extraData == ""`
  * `GetProfileInformationResponse.signedProfile.profile.profileImageHash == []`
  * `GetProfileInformationResponse.signedProfile.profile.thumbnailImageHash == []`
  * `GetProfileInformationResponse.signedProfile.signature` is a valid signature of `GetProfileInformationResponse.signedProfile.profile`
  * `GetProfileInformationResponse.profileImage == []`
  * `GetProfileInformationResponse.thumbnailImage == []`
  * `GetProfileInformationResponse.applicationServices == ("b","c","d","e")`

Server replies with *ApplicationServiceAddResponse*:

  * `Message.id == 14`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceAddResponse*:

  * `Message.id == 15`
  * `Response.status == STATUS_OK`

Server replies with *GetProfileInformationResponse*:

  * `Message.id == 16`
  * `Response.status == STATUS_OK`
  * `GetProfileInformationResponse.isHosted == true`
  * `GetProfileInformationResponse.isOnline == true`
  * `GetProfileInformationResponse.signedProfile.profile.version == [1,0,0]`
  * `GetProfileInformationResponse.signedProfile.profile.publicKey == $PublicKey`
  * `GetProfileInformationResponse.signedProfile.profile.type == "Test Type"`
  * `GetProfileInformationResponse.signedProfile.profile.name == "Test Identity"`
  * `GetProfileInformationResponse.signedProfile.profile.latitude == 0`
  * `GetProfileInformationResponse.signedProfile.profile.longitude == 0`
  * `GetProfileInformationResponse.signedProfile.profile.extraData == ""`
  * `GetProfileInformationResponse.signedProfile.profile.profileImageHash == []`
  * `GetProfileInformationResponse.signedProfile.profile.thumbnailImageHash == []`
  * `GetProfileInformationResponse.signedProfile.signature` is a valid signature of `GetProfileInformationResponse.signedProfile.profile`
  * `GetProfileInformationResponse.profileImage == []`
  * `GetProfileInformationResponse.thumbnailImage == []`
  * `GetProfileInformationResponse.applicationServices == ("b","c","d","e","a1","a2","a3","a4","a5","a6","a7","a8","a9","a10","b1","b2","b3","b4","b5","b6","b7","b8","b9","b10")`

Server replies with *Response*:

  * `Message.id == 17`
  * `Response.status == ERROR_QUOTA_EXCEEDED`

Server replies with *GetProfileInformationResponse*:

  * `Message.id == 18`
  * `Response.status == STATUS_OK`
  * `GetProfileInformationResponse.isHosted == true`
  * `GetProfileInformationResponse.isOnline == true`
  * `GetProfileInformationResponse.signedProfile.profile.version == [1,0,0]`
  * `GetProfileInformationResponse.signedProfile.profile.publicKey == $PublicKey`
  * `GetProfileInformationResponse.signedProfile.profile.type == "Test Type"`
  * `GetProfileInformationResponse.signedProfile.profile.name == "Test Identity"`
  * `GetProfileInformationResponse.signedProfile.profile.latitude == 0`
  * `GetProfileInformationResponse.signedProfile.profile.longitude == 0`
  * `GetProfileInformationResponse.signedProfile.profile.extraData == ""`
  * `GetProfileInformationResponse.signedProfile.profile.profileImageHash == []`
  * `GetProfileInformationResponse.signedProfile.profile.thumbnailImageHash == []`
  * `GetProfileInformationResponse.signedProfile.signature` is a valid signature of `GetProfileInformationResponse.signedProfile.profile`
  * `GetProfileInformationResponse.profileImage == []`
  * `GetProfileInformationResponse.thumbnailImage == []`
  * `GetProfileInformationResponse.applicationServices == ("b","c","d","e","a1","a2","a3","a4","a5","a6","a7","a8","a9","a10","b1","b2","b3","b4","b5","b6","b7","b8","b9","b10")`


###### Step 3:

Server replies with *GetProfileInformationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `GetProfileInformationResponse.isHosted == true`
  * `GetProfileInformationResponse.isOnline == false`
  * `GetProfileInformationResponse.signedProfile.profile.version == [1,0,0]`
  * `GetProfileInformationResponse.signedProfile.profile.publicKey == $PublicKey`
  * `GetProfileInformationResponse.signedProfile.profile.type == "Test Type"`
  * `GetProfileInformationResponse.signedProfile.profile.name == "Test Identity"`
  * `GetProfileInformationResponse.signedProfile.profile.latitude == 0`
  * `GetProfileInformationResponse.signedProfile.profile.longitude == 0`
  * `GetProfileInformationResponse.signedProfile.profile.extraData == ""`
  * `GetProfileInformationResponse.signedProfile.profile.profileImageHash == []`
  * `GetProfileInformationResponse.signedProfile.profile.thumbnailImageHash == []`
  * `GetProfileInformationResponse.signedProfile.signature` is a valid signature of `GetProfileInformationResponse.signedProfile.profile`
  * `GetProfileInformationResponse.profileImage == []`
  * `GetProfileInformationResponse.thumbnailImage == []`
  * `GetProfileInformationResponse.applicationServices == []`






#### PS04014 - Check-In - Invalid Signature 2

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test establishes a hosting agreement with the profile server. Then it performs the check-in process but it uses invalid signature.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key, but only the first 32 bytes of the signature are used to make the signature invalid.
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `RegisterHostingResponse.contract` is same as `RegisterHostingRequest.contract` the client sent
  * `ConversationResponse.signature` is a valid signature of `RegisterHostingResponse.contract`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_SIGNATURE`








#### PS04015 - Check-In - Invalid Challenge 2

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test establishes a hosting agreement with the profile server. Then it performs the check-in process but it uses invalid challenge.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract.planId` is empty array
  * `RegisterHostingRequest.contract.identityPublicKey` set to the test identity public key
  * `RegisterHostingRequest.contract.startTime` is set to current timestamp
  * `RegisterHostingRequest.contract.identityType := "Test Type"`
  * `ConversationRequest.signature` is a valid signature of `RegisterHostingRequest.contract`
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge` is set to first 16 bytes of $Challenge
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `RegisterHostingResponse.contract` is same as `RegisterHostingRequest.contract` the client sent
  * `ConversationResponse.signature` is a valid signature of `RegisterHostingResponse.contract`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "challenge"`





#### PS04016 - Profile Stats

##### Prerequisites/Inputs

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test creates 11 new identities and establishes hosting agreements for all of them and then it checks them in and initializes their profile,
except for one identity. Then it asks the profile server for profile statistics.


###### Step 1:

The test creates 9 identities with following identity types:

  * 2x "Type A"
  * 3x "Type B"
  * 1x "Type Alpha"
  * 1x "Type A B"
  * 1x "Type Beta"
  * 1x "Type Omega"

and then with each identity it connects to clNonCustomer port and establishes a hosting agreement.
Then the tests checks in each identity and initializes its profile, except for identity "Type Omega".

The test establishes a new TLS connection to clNonCustomer and sends *ProfileStatsRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`

and reads the response.


###### Step 2:

The test creates 2 more identities with following identity types:

  * 1x `Type A B`
  * 1x `Type C`

and then with each identity it connects to clNonCustomer port and establishes a hosting agreement. 

Then it reuses the previous connection used for sending *ProfileStatsRequest* and sends *ProfileStatsRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`

and reads the response.


  
##### Acceptance Criteria

###### Step 1:

Test successfully establishes the hosting agreements and initializes profiles of the identities.

Server replies with *ProfileStatsResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ProfileStatsResponse.stats.Count == 5`
  * `ProfileStatsResponse.stats == 
    (
      {identityType == "Type A", count == 2},
      {identityType == "Type B", count == 3},
      {identityType == "Type Alpha", count == 1},
      {identityType == "Type A B", count == 1},
      {identityType == "Type Beta", count == 1}
    )`


###### Step 2:

Test successfully establishes the hosting agreements and initializes profiles of the identities.

Server replies with *ProfileStatsResponse*:
  
  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  * `ProfileStatsResponse.stats.Count == 6`
  * `ProfileStatsResponse.stats == 
    (
      {identityType == "Type A", count == 2},
      {identityType == "Type B", count == 3},
      {identityType == "Type Alpha", count == 1},
      {identityType == "Type A B", count == 2},
      {identityType == "Type Beta", count == 1}
      {identityType == "Type C", count == 1},
    )`
