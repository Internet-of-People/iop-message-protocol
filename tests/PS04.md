### PS04xxx - Combined Client Customer and Non-Customer Port Functionality Tests

#### PS04001 - Check-In - Different Customer and Non-Customer Ports

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * Server's clNonCustomer port != clCustomer port

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test establishes a hosting agreement with the profile server. Then it performs the check-in process.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract` is uninitialized
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`







#### PS04002 - Check-In - Same Customer and Non-Customer Ports

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * Server's clNonCustomer port == clCustomer port

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer/clCustomer port

##### Description 

The test establishes a hosting agreement with the profile server and continues with the check-in process on the same port.

###### Step 1:
The test establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract` is uninitialized
  
and reads the response. The test it sends *CheckInRequest*:

  * `Message.id := 3`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *CheckInResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`








#### PS04003 - Check-In - Invalid Signature

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test establishes a hosting agreement with the profile server. Then it performs the check-in process but it uses invalid signature.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract` is uninitialized
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key, but the first byte of the signature is XORed with 0x12 to make the signature invalid.
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_SIGNATURE`








#### PS04004 - Check-In - Invalid Challenge

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test establishes a hosting agreement with the profile server. Then it performs the check-in process but it uses invalid challenge.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract` is uninitialized
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`, but the first byte of the challenge is XORed with 0x12 to make the challenge invalid
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "challenge"`












#### PS04005 - Cancel Hosting Agreement, Register Again and Check-In

##### Prerequisites/Inputs
###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test cancels hosting agreement for its hosted identity. It then attempts to check-in the identity, which should fail because it is no longer hosted on the profile server. Then it establishes a new hosting agreement and then it checks-in.

###### Step 1:
The test establishes a hosting agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *CancelHostingAgreementRequest*:

  * `Message.id := 3`
  * `CancelHostingAgreementRequest.redirectToNewProfileServer := false`
  * `CancelHostingAgreementRequest.newProfileServerNetworkId` is uninitialized

and reads the response.


###### Step 3:
The test closes the connection and establishes a new TLS connection to the clCustomer port and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response and closes the connection. 

###### Step 4:

The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity's 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge3 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract` is uninitialized

and reads the response.



###### Step 5:
The test closes the connection and establishes a new TLS connection to the clCustomer port and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge4 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. 

  
##### Acceptance Criteria


###### Step 1:
The test successfully establishes a hosting agreement for its identity.

###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *CancelHostingAgreementResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`
  
  
###### Step 3:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_NOT_FOUND`

###### Step 4:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge3
  * `StartConversationResponse.clientChallenge == $ClientChallenge3`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  
###### Step 5:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge4
  * `StartConversationResponse.clientChallenge == $ClientChallenge4`

Server replies with *CheckInRequest*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`









#### PS04006 - Register Hosting, Update Profile, Get Identity Information 

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "images/PS04006.jpg" file exists and contains JPEG image with size less than 20 kb

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test establishes a hosting agreement with the profile server. Then it checks-in and initializes its profile. Then it queries its profile. Then it updates it again and queries it once more.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key; `$PublicKey := StartConversationRequest.publicKey`
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract` is uninitialized
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey := $PublicKey`
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 3`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 4`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId` is set to SHA256 of test's identity public key
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := false`


and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 5`
  * `UpdateProfileRequest.setVersion := false`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := true`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := true`
  * `UpdateProfileRequest.version` is unintialized
  * `UpdateProfileRequest.name := "Test Identity Renamed"`
  * `UpdateProfileRequest.image` is initialized with data loaded from "images/PS04006.jpg" file. `$ImageData := UpdateProfileRequest.image`
  * `UpdateProfileRequest.latitude := -1`
  * `UpdateProfileRequest.longitude := -2`
  * `UpdateProfileRequest.extraData := "a=b"` 

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 6`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId` is set to SHA256 of test's identity public key
  * `GetIdentityInformationRequest.includeProfileImage := true`
  * `GetIdentityInformationRequest.includeThumbnailImage := true`
  * `GetIdentityInformationRequest.includeApplicationServices := false`

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 7`
  * `UpdateProfileRequest.setVersion := false`
  * `UpdateProfileRequest.setName := false`
  * `UpdateProfileRequest.setImage := true`
  * `UpdateProfileRequest.setLocation := false`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version` is unintialized
  * `UpdateProfileRequest.name` is unintialized
  * `UpdateProfileRequest.image := []`
  * `UpdateProfileRequest.latitude` is unintialized
  * `UpdateProfileRequest.longitude` is unintialized
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 8`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId` is set to SHA256 of test's identity public key
  * `GetIdentityInformationRequest.includeProfileImage := true`
  * `GetIdentityInformationRequest.includeThumbnailImage := true`
  * `GetIdentityInformationRequest.includeApplicationServices := false`



  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *UpdateProfileResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server replies with *GetIdentityInformationResponse*:

  * `Message.id == 4`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == true`
  * `GetIdentityInformationResponse.version == [1,0,0]`
  * `GetIdentityInformationResponse.isOnline == true`
  * `GetIdentityInformationResponse.identityPublicKey == $PublicKey`
  * `GetIdentityInformationResponse.name == "Test Identity"`
  * `GetIdentityInformationResponse.extraData == ""`
  * `GetIdentityInformationResponse.latitude == 1`
  * `GetIdentityInformationResponse.longitude == 2`

Server replies with *UpdateProfileResponse*:

  * `Message.id == 5`
  * `Response.status == STATUS_OK`

Server replies with *GetIdentityInformationResponse*:

  * `Message.id == 6`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == true`
  * `GetIdentityInformationResponse.version == [1,0,0]`
  * `GetIdentityInformationResponse.isOnline == true`
  * `GetIdentityInformationResponse.identityPublicKey == $PublicKey`
  * `GetIdentityInformationResponse.name == "Test Identity Renamed"`
  * `GetIdentityInformationResponse.extraData == "a=b"`
  * `GetIdentityInformationResponse.latitude == -1`
  * `GetIdentityInformationResponse.longitude == -2`
  * `GetIdentityInformationResponse.profileImage == $ImageData`
  * `GetIdentityInformationResponse.thumbnailImage` is non empty

Server replies with *UpdateProfileResponse*:

  * `Message.id == 7`
  * `Response.status == STATUS_OK`

Server replies with *GetIdentityInformationResponse*:

  * `Message.id == 8`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == true`
  * `GetIdentityInformationResponse.version == [1,0,0]`
  * `GetIdentityInformationResponse.isOnline == true`
  * `GetIdentityInformationResponse.identityPublicKey == $PublicKey`
  * `GetIdentityInformationResponse.name == "Test Identity Renamed"`
  * `GetIdentityInformationResponse.extraData == "a=b"`
  * `GetIdentityInformationResponse.latitude == -1`
  * `GetIdentityInformationResponse.longitude == -2`
  * `GetIdentityInformationResponse.profileImage` is empty
  * `GetIdentityInformationResponse.thumbnailImage` is empty
















#### PS04007 - Update Profile - Invalid Initialization and Invalid Values

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "images/PS04007-too-big.jpg" file exists and contains JPEG image with size greater than 20 kb
  * "images/PS04007-not-image.jpg" file exists and contains a single byte 0x41

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test establishes a hosting agreement with the profile server. Then it checks-in and attempts to repeatedly update its profile, but always fails to fill in all required fields for the profile initialization. Then it tries to update the profile with invalid values. Then it initializes the profile correctly and it attempts to send empty update request.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key; `$PublicKey := StartConversationRequest.publicKey`
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract` is uninitialized
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey := $PublicKey`
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 3`
  * `UpdateProfileRequest.setVersion := false`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version` is unintialized
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 4`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := false`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name` is unintialized
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 5`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := false`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude` is unintialized
  * `UpdateProfileRequest.longitude` is unintialized
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 6`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [0,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 7`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [255,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 8`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := ""`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 9`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name` is set to string containing 100x 'a'
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 10`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name` is set to string containing 50x 'ɐ' (UTF8 code 0xc990), which consumes 2 bytes per character
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 11`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := true`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is initialized with image data loaded from "images/PS04007-too-big.jpg" file
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 12`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := true`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is initialized with image data loaded from "images/PS04007-not-image.jpg" file
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 13`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := true`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is uninitialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is set to string containing 300x 'a'

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 14`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := true`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is uninitialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is set to string containing 150x 'ɐ' (UTF8 code 0xc990), which consumes 2 bytes per character

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 15`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is uninitialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is uninitialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 16`
  * `UpdateProfileRequest.setVersion := false`
  * `UpdateProfileRequest.setName := false`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := false`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version` is uninitialized
  * `UpdateProfileRequest.name` is uninitialized
  * `UpdateProfileRequest.image` is uninitialized
  * `UpdateProfileRequest.latitude` is unintialized
  * `UpdateProfileRequest.longitude` is unintialized
  * `UpdateProfileRequest.extraData` is uninitialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 17`
  * `UpdateProfileRequest.setVersion := false`
  * `UpdateProfileRequest.setName := false`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version` is uninitialized
  * `UpdateProfileRequest.name` is uninitialized
  * `UpdateProfileRequest.image` is uninitialized
  * `UpdateProfileRequest.latitude := -90,000,001`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is uninitialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 18`
  * `UpdateProfileRequest.setVersion := false`
  * `UpdateProfileRequest.setName := false`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version` is uninitialized
  * `UpdateProfileRequest.name` is uninitialized
  * `UpdateProfileRequest.image` is uninitialized
  * `UpdateProfileRequest.latitude := 0`
  * `UpdateProfileRequest.longitude := 180,000,001`
  * `UpdateProfileRequest.extraData` is uninitialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 19`
  * `UpdateProfileRequest.setVersion := false`
  * `UpdateProfileRequest.setName := false`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version` is uninitialized
  * `UpdateProfileRequest.name` is uninitialized
  * `UpdateProfileRequest.image` is uninitialized
  * `UpdateProfileRequest.latitude := -90,000,001`
  * `UpdateProfileRequest.longitude := 180,000,001`
  * `UpdateProfileRequest.extraData` is uninitialized

and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *Response*:

  * `Message.id == 3`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "setVersion"`

Server replies with *Response*:

  * `Message.id == 4`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "setName"`

Server replies with *Response*:

  * `Message.id == 5`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "setLocation"`

Server replies with *Response*:

  * `Message.id == 6`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "version"`

Server replies with *Response*:

  * `Message.id == 7`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "version"`

Server replies with *Response*:

  * `Message.id == 8`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "name"`

Server replies with *Response*:

  * `Message.id == 9`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "name"`

Server replies with *Response*:

  * `Message.id == 10`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "name"`

Server replies with *Response*:

  * `Message.id == 11`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "image"`

Server replies with *Response*:

  * `Message.id == 12`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "image"`

Server replies with *Response*:

  * `Message.id == 13`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "extraData"`

Server replies with *Response*:

  * `Message.id == 14`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "extraData"`

Server replies with *UpdateProfileResponse*:

  * `Message.id == 15`
  * `Response.status == STATUS_OK`

Server replies with *Response*:

  * `Message.id == 16`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "set*"`

Server replies with *Response*:

  * `Message.id == 17`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "latitude"`

Server replies with *Response*:

  * `Message.id == 18`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "longitude"`

Server replies with *Response*:

  * `Message.id == 19`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "latitude"`









#### PS04008 - Verify Identity, Update Profile - Unauthorized

##### Prerequisites/Inputs
###### Prerequisites:
  * Server's database is empty.
  * Server's clNonCustomer port == clCustomer port

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer/clCustomer port

##### Description 

The test verifies its identity on clNonCustomer/clCustomer port. Then it attempts to update its profile, which requires Authenticated status.


###### Step 1:
The test establishes a hosting agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 3`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 0`
  * `UpdateProfileRequest.longitude := 0`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response.


##### Acceptance Criteria


###### Step 1:
The test successfully establishes a hosting agreement for its identity.

###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *VerifyIdentityResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *Response*:

  * `Message.id == 3`
  * `Response.status == ERROR_UNAUTHORIZED`









#### PS04009 - Cancel Hosting Agreement - Redirection

##### Prerequisites/Inputs
###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test cancels hosting agreement for its hosted identity and sets up a redirect to a new profile server. It then verifies that this redirect has been installed.

###### Step 1:
The test establishes a hosting agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *CancelHostingAgreementRequest*:

  * `Message.id := 3`
  * `CancelHostingAgreementRequest.redirectToNewProfileServer := true`
  * `CancelHostingAgreementRequest.newProfileServerNetworkId := SHA256("test")`

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 4`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId` is set to SHA256 of test's identity public key
  * `GetIdentityInformationRequest.includeProfileImage = false`
  * `GetIdentityInformationRequest.includeThumbnailImage = false`
  * `GetIdentityInformationRequest.includeApplicationServices = false`


##### Acceptance Criteria


###### Step 1:
The test successfully establishes a hosting agreement for its identity.

###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *CancelHostingAgreementResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`
  
Server replies with *GetIdentityInformationResponse*:

  * `Message.id == 4`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == false`
  * `GetIdentityInformationResponse.isTargetProfileServerKnown == true`
  * `GetIdentityInformationResponse.targetProfileServerNetworkId == SHA256("test")`






#### PS04010 - Cancel Hosting Agreement - Invalid New Profile Server Id

##### Prerequisites/Inputs
###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test cancels hosting agreement for its hosted identity and sets up a redirect to a new profile server, but provides invalid new profile server network identifier.

###### Step 1:
The test establishes a hosting agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *CancelHostingAgreementRequest*:

  * `Message.id := 3`
  * `CancelHostingAgreementRequest.redirectToNewProfileServer := true`
  * `CancelHostingAgreementRequest.newProfileServerNetworkId := "test"`

and reads the response.


##### Acceptance Criteria


###### Step 1:
The test successfully establishes a hosting agreement for its identity.

###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *Response*:

  * `Message.id == 3`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "newProfileServerNetworkId"`








#### PS04011 - Parallel Check-Ins

##### Prerequisites/Inputs
###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test checks-in its identity and then it checks it in again in a second parallel connection. This should disconnect the first connection.

###### Step 1:
The test establishes a hosting agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. 

###### Step 3:
With the first connection left open, the test establishes a new TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. 

###### Step 4:

Using the first connection the test attempts to send *PingRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `PingRequest.payload = "test"`

and reads the response. 



##### Acceptance Criteria


###### Step 1:
The test successfully establishes a hosting agreement for its identity.

###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 3:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

###### Step 4:

The first connection should be disconnected and it should not be possible to send the request.













#### PS04012 - Update Profile - Unauthorized

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test asks to update its profile without performing a check-in process first. 

###### Step 1:
The test establishes a hosting agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`

and reads the response.

Then it sends *UpdateProfileRequest*:

  * `Message.id := 2`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 0`
  * `UpdateProfileRequest.longitude := 0`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. 

  
##### Acceptance Criteria


###### Step 1:
The test successfully establishes a hosting agreement for its identity.

###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_UNAUTHORIZED`












#### PS04013 - Application Service Add, Remove, Query

##### Prerequisites/Inputs
###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test checks-in its identity and then it adds/deletes/queries its application services. Some of the requests are valid and some are invalid.


###### Step 1:
The test establishes a hosting agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key; `$PublicKey := StartConversationRequest.publicKey`
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 3`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 0`
  * `UpdateProfileRequest.longitude := 0`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *ApplicationServiceAddRequest*:

  * `Message.id := 4`
  * `ApplicationServiceAddRequest.serviceNames := ["a","b","c","d","a"]`

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 5`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := true`

and reads the response. Then it sends *ApplicationServiceAddRequest*:

  * `Message.id := 6`
  * `ApplicationServiceAddRequest.serviceNames := ["c","d","a","e"]`

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 7`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := true`

and reads the response. Then it sends *ApplicationServiceRemoveRequest*:

  * `Message.id := 8`
  * `ApplicationServiceRemoveRequest.serviceName := "a"`

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 9`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := true`

and reads the response. Then it sends *ApplicationServiceRemoveRequest*:

  * `Message.id := 10`
  * `ApplicationServiceRemoveRequest.serviceName := "a"`

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 11`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := true`

and reads the response. Then it sends *ApplicationServiceAddRequest*:

  * `Message.id := 12`
  * `ApplicationServiceAddRequest.serviceNames := ["d","1234567890-1234567890-1234567890-1234567890","a","e"]`

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 13`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := true`

and reads the response. Then it sends *ApplicationServiceAddRequest*:

  * `Message.id := 14`
  * `ApplicationServiceAddRequest.serviceNames := ["a1","a2","a3","a4","a5","a6","a7","a8","a9","a10"]`

and reads the response. Then it sends *ApplicationServiceAddRequest*:

  * `Message.id := 15`
  * `ApplicationServiceAddRequest.serviceNames := ["b1","b2","b3","b4","b5","b6","b7","b8","b9","b10"]`

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 16`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := true`

and reads the response. Then it sends *ApplicationServiceAddRequest*:

  * `Message.id := 17`
  * `ApplicationServiceAddRequest.serviceNames := ["c1","c2","c3","c4","c5","c6","c7","c8","c9","c10","d1","d2","d3","d4","d5","d6","d7","d8","d9","d10","e1","e2","e3","e4","e5","e6","e7","e8","e9","e10"]`

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 18`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := true`

and reads the response.


                                      

##### Acceptance Criteria


###### Step 1:
The test successfully establishes a hosting agreement for its identity.

###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Server replies with *UpdateProfileResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceAddResponse*:

  * `Message.id == 4`
  * `Response.status == STATUS_OK`

Server replies with *GetIdentityInformationResponse*:

  * `Message.id == 5`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == true`
  * `GetIdentityInformationResponse.version == [1,0,0]`
  * `GetIdentityInformationResponse.isOnline == true`
  * `GetIdentityInformationResponse.identityPublicKey == $PublicKey`
  * `GetIdentityInformationResponse.applicationServices == ("a","b","c","d")`

Server replies with *ApplicationServiceAddResponse*:

  * `Message.id == 6`
  * `Response.status == STATUS_OK`

Server replies with *GetIdentityInformationResponse*:

  * `Message.id == 7`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == true`
  * `GetIdentityInformationResponse.version == [1,0,0]`
  * `GetIdentityInformationResponse.isOnline == true`
  * `GetIdentityInformationResponse.identityPublicKey == $PublicKey`
  * `GetIdentityInformationResponse.applicationServices == ("a","b","c","d","e")`

Server replies with *ApplicationServiceRemoveResponse*:

  * `Message.id == 8`
  * `Response.status == STATUS_OK`

Server replies with *GetIdentityInformationResponse*:

  * `Message.id == 9`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == true`
  * `GetIdentityInformationResponse.version == [1,0,0]`
  * `GetIdentityInformationResponse.isOnline == true`
  * `GetIdentityInformationResponse.identityPublicKey == $PublicKey`
  * `GetIdentityInformationResponse.applicationServices == ("b","c","d","e")`

Server replies with *Response*:

  * `Message.id == 10`
  * `Response.status == ERROR_NOT_FOUND`

Server replies with *GetIdentityInformationResponse*:

  * `Message.id == 11`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == true`
  * `GetIdentityInformationResponse.version == [1,0,0]`
  * `GetIdentityInformationResponse.isOnline == true`
  * `GetIdentityInformationResponse.identityPublicKey == $PublicKey`
  * `GetIdentityInformationResponse.applicationServices == ("b","c","d","e")`

Server replies with *Response*:

  * `Message.id == 12`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "serviceNames[1]"`

Server replies with *GetIdentityInformationResponse*:

  * `Message.id == 13`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == true`
  * `GetIdentityInformationResponse.version == [1,0,0]`
  * `GetIdentityInformationResponse.isOnline == true`
  * `GetIdentityInformationResponse.identityPublicKey == $PublicKey`
  * `GetIdentityInformationResponse.applicationServices == ("b","c","d","e")`

Server replies with *ApplicationServiceAddResponse*:

  * `Message.id == 14`
  * `Response.status == STATUS_OK`

Server replies with *ApplicationServiceAddResponse*:

  * `Message.id == 15`
  * `Response.status == STATUS_OK`

Server replies with *GetIdentityInformationResponse*:

  * `Message.id == 16`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == true`
  * `GetIdentityInformationResponse.version == [1,0,0]`
  * `GetIdentityInformationResponse.isOnline == true`
  * `GetIdentityInformationResponse.identityPublicKey == $PublicKey`
  * `GetIdentityInformationResponse.applicationServices == ("b","c","d","e","a1","a2","a3","a4","a5","a6","a7","a8","a9","a10","b1","b2","b3","b4","b5","b6","b7","b8","b9","b10")`

Server replies with *Response*:

  * `Message.id == 17`
  * `Response.status == ERROR_QUOTA_EXCEEDED`

Server replies with *GetIdentityInformationResponse*:

  * `Message.id == 18`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == true`
  * `GetIdentityInformationResponse.version == [1,0,0]`
  * `GetIdentityInformationResponse.isOnline == true`
  * `GetIdentityInformationResponse.identityPublicKey == $PublicKey`
  * `GetIdentityInformationResponse.applicationServices == ("b","c","d","e","a1","a2","a3","a4","a5","a6","a7","a8","a9","a10","b1","b2","b3","b4","b5","b6","b7","b8","b9","b10")`










#### PS04014 - Check-In - Invalid Signature 2

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test establishes a hosting agreement with the profile server. Then it performs the check-in process but it uses invalid signature.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract` is uninitialized
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key, but only the first 32 bytes of the signature are used to make the signature invalid.
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_SIGNATURE`








#### PS04015 - Check-In - Invalid Challenge 2

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's clNonCustomer port
  * Server's clCustomer port

##### Description 

The test establishes a hosting agreement with the profile server. Then it performs the check-in process but it uses invalid challenge.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *RegisterHostingRequest*:

  * `Message.id := 2`
  * `RegisterHostingRequest.contract` is uninitialized
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the profile server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the profile server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge` is set to first 16 bytes of $Challenge
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Server replies with *RegisterHostingResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Server replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Server replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "challenge"`



