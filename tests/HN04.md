### HN04xxx - Node Combined Client Customer and Non-Customer Port Functionality Tests

#### HN04001 - Check-In - Different Customer and Non-Customer Ports

##### Prerequisites/Inputs

###### Prerequisites:
  * Node's database is empty.
  * Node's clNonCustomer port != clCustomer port

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port
  * Node's clCustomer port

##### Description 

The test establishes a home node agreement with the node. Then it performs the check-in process.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *HomeNodeRequestRequest*:

  * `Message.id := 2`
  * `HomeNodeRequestRequest.contract` is uninitialized
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Node replies with *HomeNodeRequestResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Node replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`







#### HN04002 - Check-In - Same Customer and Non-Customer Ports

##### Prerequisites/Inputs

###### Prerequisites:
  * Node's database is empty.
  * Node's clNonCustomer port == clCustomer port

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer/clCustomer port

##### Description 

The test establishes a home node agreement with the node and continues with the check-in process on the same port.

###### Step 1:
The test establishes a TLS connection to the clCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
  
and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *HomeNodeRequestRequest*:

  * `Message.id := 2`
  * `HomeNodeRequestRequest.contract` is uninitialized
  
and reads the response. The test it sends *CheckInRequest*:

  * `Message.id := 3`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Node replies with *HomeNodeRequestResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Node replies with *CheckInResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`








#### HN04003 - Check-In - Invalid Signature

##### Prerequisites/Inputs

###### Prerequisites:
  * Node's database is empty.

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port
  * Node's clCustomer port

##### Description 

The test establishes a home node agreement with the node. Then it performs the check-in process but it uses invalid signature.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *HomeNodeRequestRequest*:

  * `Message.id := 2`
  * `HomeNodeRequestRequest.contract` is uninitialized
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key, but the first byte of the signature is XORed with 0x12 to make the signature invalid.
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Node replies with *HomeNodeRequestResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Node replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_SIGNATURE`








#### HN04004 - Check-In - Invalid Challenge

##### Prerequisites/Inputs

###### Prerequisites:
  * Node's database is empty.

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port
  * Node's clCustomer port

##### Description 

The test establishes a home node agreement with the node. Then it performs the check-in process but it uses invalid challenge.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *HomeNodeRequestRequest*:

  * `Message.id := 2`
  * `HomeNodeRequestRequest.contract` is uninitialized
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`, but the first byte of the challenge is XORed with 0x12 to make the challenge invalid
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Node replies with *HomeNodeRequestResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Node replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "challenge"`












#### HN04005 - Cancel Home Node Agreement, Register Again and Check-In

##### Prerequisites/Inputs
###### Prerequisites:
  * Node's database is empty.

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port
  * Node's clCustomer port

##### Description 

The test cancels home node agreement for its hosted identity. It then attempts to check-in the identity, which should fail because it is no longer hosted on the node. Then it establishes a new home node agreement and then it checks-in.

###### Step 1:
The test establishes a home node agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *CancelHomeNodeAgreementRequest*:

  * `Message.id := 3`
  * `CancelHomeNodeAgreementRequest.redirectToNewHomeNode := false`
  * `CancelHomeNodeAgreementRequest.newHomeNodeNetworkId` is uninitialized

and reads the response.


###### Step 3:
The test closes the connection and establishes a new TLS connection to the clCustomer port and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response and closes the connection. 

###### Step 4:

The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity's 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge3 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *HomeNodeRequestRequest*:

  * `Message.id := 2`
  * `HomeNodeRequestRequest.contract` is uninitialized

and reads the response.



###### Step 5:
The test closes the connection and establishes a new TLS connection to the clCustomer port and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge4 := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. 

  
##### Acceptance Criteria


###### Step 1:
The test successfully establishes a home node agreement for its identity.

###### Step 2:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Node replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Node replies with *CancelHomeNodeAgreementResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`
  
  
###### Step 3:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Node replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_NOT_FOUND`

###### Step 4:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge3
  * `StartConversationResponse.clientChallenge == $ClientChallenge3`

Node replies with *HomeNodeRequestResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`
  
###### Step 5:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge4
  * `StartConversationResponse.clientChallenge == $ClientChallenge4`

Node replies with *CheckInRequest*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`









#### HN04006 - Home Node Agreement, Update Profile, Get Identity Information 

##### Prerequisites/Inputs

###### Prerequisites:
  * Node's database is empty.
  * "images/HN04006.jpg" file exists and contains JPEG image with size less than 20 kb

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port
  * Node's clCustomer port

##### Description 

The test establishes a home node agreement with the node. Then it checks-in and initializes its profile. Then it queries its profile. Then it updates it again and queries it once more.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key; `$PublicKey := StartConversationRequest.publicKey`
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *HomeNodeRequestRequest*:

  * `Message.id := 2`
  * `HomeNodeRequestRequest.contract` is uninitialized
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey := $PublicKey`
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 3`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 4`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId` is set to SHA256 of test's identity public key
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := false`


and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 5`
  * `UpdateProfileRequest.setVersion := false`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := true`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := true`
  * `UpdateProfileRequest.version` is unintialized
  * `UpdateProfileRequest.name := "Test Identity Renamed"`
  * `UpdateProfileRequest.image` is initialized with data loaded from "images/HN04006.jpg" file. `$ImageData := UpdateProfileRequest.image`
  * `UpdateProfileRequest.latitude := -1`
  * `UpdateProfileRequest.longitude := -2`
  * `UpdateProfileRequest.extraData := "a=b"` 

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 6`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId` is set to SHA256 of test's identity public key
  * `GetIdentityInformationRequest.includeProfileImage := true`
  * `GetIdentityInformationRequest.includeThumbnailImage := true`
  * `GetIdentityInformationRequest.includeApplicationServices := false`


  
##### Acceptance Criteria


###### Step 1:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Node replies with *HomeNodeRequestResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Node replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Node replies with *UpdateProfileResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Node replies with *GetIdentityInformationResponse*:

  * `Message.id == 4`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == true`
  * `GetIdentityInformationResponse.version == [1,0,0]`
  * `GetIdentityInformationResponse.isOnline == true`
  * `GetIdentityInformationResponse.identityPublicKey == $PublicKey`
  * `GetIdentityInformationResponse.name == "Test Identity"`
  * `GetIdentityInformationResponse.extraData == ""`
  * `GetIdentityInformationResponse.latitude == 1`
  * `GetIdentityInformationResponse.longitude == 2`

Node replies with *UpdateProfileResponse*:

  * `Message.id == 5`
  * `Response.status == STATUS_OK`

Node replies with *GetIdentityInformationResponse*:

  * `Message.id == 6`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == true`
  * `GetIdentityInformationResponse.version == [1,0,0]`
  * `GetIdentityInformationResponse.isOnline == true`
  * `GetIdentityInformationResponse.identityPublicKey == $PublicKey`
  * `GetIdentityInformationResponse.name == "Test Identity Renamed"`
  * `GetIdentityInformationResponse.extraData == "a=b"`
  * `GetIdentityInformationResponse.latitude == -1`
  * `GetIdentityInformationResponse.longitude == -2`
  * `GetIdentityInformationResponse.profileImage == $ImageData`
  * `GetIdentityInformationResponse.thumbnailImage` is non empty
















#### HN04007 - Update Profile - Invalid Initialization and Invalid Values

##### Prerequisites/Inputs

###### Prerequisites:
  * Node's database is empty.
  * "images/HN04007-too-big.jpg" file exists and contains JPEG image with size greater than 20 kb
  * "images/HN04007-not-image.jpg" file exists and contains a single byte 0x41

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port
  * Node's clCustomer port

##### Description 

The test establishes a home node agreement with the node. Then it checks-in and attempts to repeatedly update its profile, but always fails to fill in all required fields for the profile initialization. Then it tries to update the profile with invalid values. Then it initializes the profile correctly and it attempts to send empty update request.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key; `$PublicKey := StartConversationRequest.publicKey`
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *HomeNodeRequestRequest*:

  * `Message.id := 2`
  * `HomeNodeRequestRequest.contract` is uninitialized
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey := $PublicKey`
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 3`
  * `UpdateProfileRequest.setVersion := false`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version` is unintialized
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 4`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := false`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name` is unintialized
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 5`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := false`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude` is unintialized
  * `UpdateProfileRequest.longitude` is unintialized
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 6`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [0,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 7`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [255,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 8`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := ""`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 9`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name` is set to string containing 100x 'a'
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 10`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name` is set to string containing 50x 'ɐ' (UTF8 code 0xc990), which consumes 2 bytes per character
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 11`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := true`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is initialized with image data loaded from "images/HN04007-too-big.jpg" file
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 12`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := true`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is initialized with image data loaded from "images/HN04007-not-image.jpg" file
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 13`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := true`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is uninitialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is set to string containing 300x 'a'

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 14`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := true`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is uninitialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is set to string containing 150x 'ɐ' (UTF8 code 0xc990), which consumes 2 bytes per character

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 15`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is uninitialized
  * `UpdateProfileRequest.latitude := 1`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is uninitialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 16`
  * `UpdateProfileRequest.setVersion := false`
  * `UpdateProfileRequest.setName := false`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := false`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version` is uninitialized
  * `UpdateProfileRequest.name` is uninitialized
  * `UpdateProfileRequest.image` is uninitialized
  * `UpdateProfileRequest.latitude` is unintialized
  * `UpdateProfileRequest.longitude` is unintialized
  * `UpdateProfileRequest.extraData` is uninitialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 17`
  * `UpdateProfileRequest.setVersion := false`
  * `UpdateProfileRequest.setName := false`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version` is uninitialized
  * `UpdateProfileRequest.name` is uninitialized
  * `UpdateProfileRequest.image` is uninitialized
  * `UpdateProfileRequest.latitude := -90,000,001`
  * `UpdateProfileRequest.longitude := 2`
  * `UpdateProfileRequest.extraData` is uninitialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 18`
  * `UpdateProfileRequest.setVersion := false`
  * `UpdateProfileRequest.setName := false`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version` is uninitialized
  * `UpdateProfileRequest.name` is uninitialized
  * `UpdateProfileRequest.image` is uninitialized
  * `UpdateProfileRequest.latitude := 0`
  * `UpdateProfileRequest.longitude := 180,000,001`
  * `UpdateProfileRequest.extraData` is uninitialized

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 19`
  * `UpdateProfileRequest.setVersion := false`
  * `UpdateProfileRequest.setName := false`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version` is uninitialized
  * `UpdateProfileRequest.name` is uninitialized
  * `UpdateProfileRequest.image` is uninitialized
  * `UpdateProfileRequest.latitude := -90,000,001`
  * `UpdateProfileRequest.longitude := 180,000,001`
  * `UpdateProfileRequest.extraData` is uninitialized

and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Node replies with *HomeNodeRequestResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Node replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Node replies with *Response*:

  * `Message.id == 3`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "setVersion"`

Node replies with *Response*:

  * `Message.id == 4`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "setName"`

Node replies with *Response*:

  * `Message.id == 5`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "setLocation"`

Node replies with *Response*:

  * `Message.id == 6`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "version"`

Node replies with *Response*:

  * `Message.id == 7`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "version"`

Node replies with *Response*:

  * `Message.id == 8`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "name"`

Node replies with *Response*:

  * `Message.id == 9`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "name"`

Node replies with *Response*:

  * `Message.id == 10`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "name"`

Node replies with *Response*:

  * `Message.id == 11`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "image"`

Node replies with *Response*:

  * `Message.id == 12`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "image"`

Node replies with *Response*:

  * `Message.id == 13`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "extraData"`

Node replies with *Response*:

  * `Message.id == 14`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "extraData"`

Node replies with *UpdateProfileResponse*:

  * `Message.id == 15`
  * `Response.status == STATUS_OK`

Node replies with *Response*:

  * `Message.id == 16`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "set*"`

Node replies with *Response*:

  * `Message.id == 17`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "latitude"`

Node replies with *Response*:

  * `Message.id == 18`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "longitude"`

Node replies with *Response*:

  * `Message.id == 19`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "latitude"`









#### HN04008 - Verify Identity, Update Profile - Unauthorized

##### Prerequisites/Inputs
###### Prerequisites:
  * Node's database is empty.
  * Node's clNonCustomer port == clCustomer port

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer/clCustomer port

##### Description 

The test verifies its identity on clNonCustomer/clCustomer port. Then it attempts to update its profile, which requires Authenticated status.


###### Step 1:
The test establishes a home node agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key

and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 3`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 0`
  * `UpdateProfileRequest.longitude := 0`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response.


##### Acceptance Criteria


###### Step 1:
The test successfully establishes a home node agreement for its identity.

###### Step 2:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Node replies with *VerifyIdentityResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Node replies with *Response*:

  * `Message.id == 3`
  * `Response.status == ERROR_UNAUTHORIZED`









#### HN04009 - Cancel Home Node Agreement - Redirection

##### Prerequisites/Inputs
###### Prerequisites:
  * Node's database is empty.

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port
  * Node's clCustomer port

##### Description 

The test cancels home node agreement for its hosted identity and sets up a redirect to a new home node. It then verifies that this redirect has been installed.

###### Step 1:
The test establishes a home node agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *CancelHomeNodeAgreementRequest*:

  * `Message.id := 3`
  * `CancelHomeNodeAgreementRequest.redirectToNewHomeNode := true`
  * `CancelHomeNodeAgreementRequest.newHomeNodeNetworkId := SHA256("test")`

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 4`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId` is set to SHA256 of test's identity public key
  * `GetIdentityInformationRequest.includeProfileImage = false`
  * `GetIdentityInformationRequest.includeThumbnailImage = false`
  * `GetIdentityInformationRequest.includeApplicationServices = false`


##### Acceptance Criteria


###### Step 1:
The test successfully establishes a home node agreement for its identity.

###### Step 2:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Node replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Node replies with *CancelHomeNodeAgreementResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`
  
Node replies with *GetIdentityInformationResponse*:

  * `Message.id == 4`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == false`
  * `GetIdentityInformationResponse.isTargetHomeNodeKnown == true`
  * `GetIdentityInformationResponse.targetHomeNodeNetworkId == SHA256("test")`






#### HN04010 - Cancel Home Node Agreement - Invalid New Home Node Id

##### Prerequisites/Inputs
###### Prerequisites:
  * Node's database is empty.

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port
  * Node's clCustomer port

##### Description 

The test cancels home node agreement for its hosted identity and sets up a redirect to a new home node, but provides invalid new home node network identifier.

###### Step 1:
The test establishes a home node agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *CancelHomeNodeAgreementRequest*:

  * `Message.id := 3`
  * `CancelHomeNodeAgreementRequest.redirectToNewHomeNode := true`
  * `CancelHomeNodeAgreementRequest.newHomeNodeNetworkId := "test"`

and reads the response.


##### Acceptance Criteria


###### Step 1:
The test successfully establishes a home node agreement for its identity.

###### Step 2:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Node replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Node replies with *Response*:

  * `Message.id == 3`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "newHomeNodeNetworkId"`








#### HN04011 - Parallel Check-Ins

##### Prerequisites/Inputs
###### Prerequisites:
  * Node's database is empty.

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port
  * Node's clCustomer port

##### Description 

The test checks-in its identity and then it checks it in again in a second parallel connection. This should disconnect the first connection.

###### Step 1:
The test establishes a home node agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. 

###### Step 3:
With the first connection left open, the test establishes a new TLS connection to the clCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. 

###### Step 4:

Using the first connection the test attempts to send *PingRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `PingRequest.payload = "test"`

and reads the response. 



##### Acceptance Criteria


###### Step 1:
The test successfully establishes a home node agreement for its identity.

###### Step 2:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Node replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 3:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Node replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

###### Step 4:

The first connection should be disconnected and it should not be possible to send the request.













#### HN04012 - Update Profile - Unauthorized

##### Prerequisites/Inputs

###### Prerequisites:
  * Node's database is empty.

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port
  * Node's clCustomer port

##### Description 

The test asks to update its profile without performing a check-in process first. 

###### Step 1:
The test establishes a home node agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`

and reads the response.

Then it sends *UpdateProfileRequest*:

  * `Message.id := 2`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 0`
  * `UpdateProfileRequest.longitude := 0`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. 

  
##### Acceptance Criteria


###### Step 1:
The test successfully establishes a home node agreement for its identity.

###### Step 2:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Node replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_UNAUTHORIZED`












#### HN04013 - Application Service Add, Remove, Query

##### Prerequisites/Inputs
###### Prerequisites:
  * Node's database is empty.

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port
  * Node's clCustomer port

##### Description 

The test checks-in its identity and then it adds/deletes/queries its application services. Some of the requests are valid and some are invalid.


###### Step 1:
The test establishes a home node agreement using clNonCustomer port and then it closes the connection.

###### Step 2:
The test establishes a TLS connection to the clCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key; `$PublicKey := StartConversationRequest.publicKey`
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response. Then it sends *UpdateProfileRequest*:

  * `Message.id := 3`
  * `UpdateProfileRequest.setVersion := true`
  * `UpdateProfileRequest.setName := true`
  * `UpdateProfileRequest.setImage := false`
  * `UpdateProfileRequest.setLocation := true`
  * `UpdateProfileRequest.setExtraData := false`
  * `UpdateProfileRequest.version := [1,0,0]`
  * `UpdateProfileRequest.name := "Test Identity"`
  * `UpdateProfileRequest.image` is unintialized
  * `UpdateProfileRequest.latitude := 0`
  * `UpdateProfileRequest.longitude := 0`
  * `UpdateProfileRequest.extraData` is unintialized

and reads the response. Then it sends *ApplicationServiceAddRequest*:

  * `Message.id := 4`
  * `ApplicationServiceAddRequest.serviceNames := ["a","b","c","d","a"]`

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 5`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := true`

and reads the response. Then it sends *ApplicationServiceAddRequest*:

  * `Message.id := 6`
  * `ApplicationServiceAddRequest.serviceNames := ["c","d","a","e"]`

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 7`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := true`

and reads the response. Then it sends *ApplicationServiceRemoveRequest*:

  * `Message.id := 8`
  * `ApplicationServiceRemoveRequest.serviceName := "a"`

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 9`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := true`

and reads the response. Then it sends *ApplicationServiceRemoveRequest*:

  * `Message.id := 10`
  * `ApplicationServiceRemoveRequest.serviceName := "a"`

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 11`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := true`

and reads the response. Then it sends *ApplicationServiceAddRequest*:

  * `Message.id := 12`
  * `ApplicationServiceAddRequest.serviceNames := ["d","1234567890-1234567890-1234567890-1234567890","a","e"]`

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 13`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := true`

and reads the response. Then it sends *ApplicationServiceAddRequest*:

  * `Message.id := 14`
  * `ApplicationServiceAddRequest.serviceNames := ["a1","a2","a3","a4","a5","a6","a7","a8","a9","a10"]`

and reads the response. Then it sends *ApplicationServiceAddRequest*:

  * `Message.id := 15`
  * `ApplicationServiceAddRequest.serviceNames := ["b1","b2","b3","b4","b5","b6","b7","b8","b9","b10"]`

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 16`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := true`

and reads the response. Then it sends *ApplicationServiceAddRequest*:

  * `Message.id := 17`
  * `ApplicationServiceAddRequest.serviceNames := ["c1","c2","c3","c4","c5","c6","c7","c8","c9","c10","d1","d2","d3","d4","d5","d6","d7","d8","d9","d10","e1","e2","e3","e4","e5","e6","e7","e8","e9","e10"]`

and reads the response. Then it sends *GetIdentityInformationRequest*:

  * `Message.id := 18`
  * `SingleRequest.version := [1,0,0]`
  * `GetIdentityInformationRequest.identityNetworkId:= SHA256($PublicKey)`
  * `GetIdentityInformationRequest.includeProfileImage := false`
  * `GetIdentityInformationRequest.includeThumbnailImage := false`
  * `GetIdentityInformationRequest.includeApplicationServices := true`

and reads the response.


                                      

##### Acceptance Criteria


###### Step 1:
The test successfully establishes a home node agreement for its identity.

###### Step 2:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Node replies with *CheckInResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`

Node replies with *UpdateProfileResponse*:

  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Node replies with *ApplicationServiceAddResponse*:

  * `Message.id == 4`
  * `Response.status == STATUS_OK`

Node replies with *GetIdentityInformationResponse*:

  * `Message.id == 5`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == true`
  * `GetIdentityInformationResponse.version == [1,0,0]`
  * `GetIdentityInformationResponse.isOnline == true`
  * `GetIdentityInformationResponse.identityPublicKey == $PublicKey`
  * `GetIdentityInformationResponse.applicationServices == ("a","b","c","d")`

Node replies with *ApplicationServiceAddResponse*:

  * `Message.id == 6`
  * `Response.status == STATUS_OK`

Node replies with *GetIdentityInformationResponse*:

  * `Message.id == 7`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == true`
  * `GetIdentityInformationResponse.version == [1,0,0]`
  * `GetIdentityInformationResponse.isOnline == true`
  * `GetIdentityInformationResponse.identityPublicKey == $PublicKey`
  * `GetIdentityInformationResponse.applicationServices == ("a","b","c","d","e")`

Node replies with *ApplicationServiceRemoveResponse*:

  * `Message.id == 8`
  * `Response.status == STATUS_OK`

Node replies with *GetIdentityInformationResponse*:

  * `Message.id == 9`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == true`
  * `GetIdentityInformationResponse.version == [1,0,0]`
  * `GetIdentityInformationResponse.isOnline == true`
  * `GetIdentityInformationResponse.identityPublicKey == $PublicKey`
  * `GetIdentityInformationResponse.applicationServices == ("b","c","d","e")`

Node replies with *Response*:

  * `Message.id == 10`
  * `Response.status == ERROR_NOT_FOUND`

Node replies with *GetIdentityInformationResponse*:

  * `Message.id == 11`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == true`
  * `GetIdentityInformationResponse.version == [1,0,0]`
  * `GetIdentityInformationResponse.isOnline == true`
  * `GetIdentityInformationResponse.identityPublicKey == $PublicKey`
  * `GetIdentityInformationResponse.applicationServices == ("b","c","d","e")`

Node replies with *Response*:

  * `Message.id == 12`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "serviceNames[1]"`

Node replies with *GetIdentityInformationResponse*:

  * `Message.id == 13`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == true`
  * `GetIdentityInformationResponse.version == [1,0,0]`
  * `GetIdentityInformationResponse.isOnline == true`
  * `GetIdentityInformationResponse.identityPublicKey == $PublicKey`
  * `GetIdentityInformationResponse.applicationServices == ("b","c","d","e")`

Node replies with *ApplicationServiceAddResponse*:

  * `Message.id == 14`
  * `Response.status == STATUS_OK`

Node replies with *ApplicationServiceAddResponse*:

  * `Message.id == 15`
  * `Response.status == STATUS_OK`

Node replies with *GetIdentityInformationResponse*:

  * `Message.id == 16`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == true`
  * `GetIdentityInformationResponse.version == [1,0,0]`
  * `GetIdentityInformationResponse.isOnline == true`
  * `GetIdentityInformationResponse.identityPublicKey == $PublicKey`
  * `GetIdentityInformationResponse.applicationServices == ("b","c","d","e","a1","a2","a3","a4","a5","a6","a7","a8","a9","a10","b1","b2","b3","b4","b5","b6","b7","b8","b9","b10")`

Node replies with *Response*:

  * `Message.id == 17`
  * `Response.status == ERROR_QUOTA_EXCEEDED`

Node replies with *GetIdentityInformationResponse*:

  * `Message.id == 18`
  * `Response.status == STATUS_OK`
  * `GetIdentityInformationResponse.isHosted == true`
  * `GetIdentityInformationResponse.version == [1,0,0]`
  * `GetIdentityInformationResponse.isOnline == true`
  * `GetIdentityInformationResponse.identityPublicKey == $PublicKey`
  * `GetIdentityInformationResponse.applicationServices == ("b","c","d","e","a1","a2","a3","a4","a5","a6","a7","a8","a9","a10","b1","b2","b3","b4","b5","b6","b7","b8","b9","b10")`










#### HN04014 - Check-In - Invalid Signature 2

##### Prerequisites/Inputs

###### Prerequisites:
  * Node's database is empty.

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port
  * Node's clCustomer port

##### Description 

The test establishes a home node agreement with the node. Then it performs the check-in process but it uses invalid signature.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *HomeNodeRequestRequest*:

  * `Message.id := 2`
  * `HomeNodeRequestRequest.contract` is uninitialized
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key, but only the first 32 bytes of the signature are used to make the signature invalid.
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Node replies with *HomeNodeRequestResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Node replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_SIGNATURE`








#### HN04015 - Check-In - Invalid Challenge 2

##### Prerequisites/Inputs

###### Prerequisites:
  * Node's database is empty.

###### Inputs:
  * Node's IP address
  * Node's clNonCustomer port
  * Node's clCustomer port

##### Description 

The test establishes a home node agreement with the node. Then it performs the check-in process but it uses invalid challenge.

###### Step 1:
The test establishes a TLS connection to the clNonCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge1 := StartConversationRequest.clientChallenge`
  
and reads the response. Then it sends *HomeNodeRequestRequest*:

  * `Message.id := 2`
  * `HomeNodeRequestRequest.contract` is uninitialized
  
and reads the response.
  
###### Step 2:
The test then closes the connection and establishes a TLS connection to the clCustomer port of the node and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test's identity 32 byte long public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge2 := StartConversationRequest.clientChallenge`

and reads the response from the node in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *CheckInRequest*:

  * `Message.id := 2`
  * `CheckInRequest.challenge` is set to first 16 bytes of $Challenge
  * `ConversationRequest.signature` is set to a signature of `CheckInRequest` part of the message using the test's identity private key
  
and reads the response.

  
##### Acceptance Criteria


###### Step 1:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge1
  * `StartConversationResponse.clientChallenge == $ClientChallenge1`

Node replies with *HomeNodeRequestResponse*:

  * `Message.id == 2`
  * `Response.status == STATUS_OK`


###### Step 2:
Node replies with *StartConversationResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge2
  * `StartConversationResponse.clientChallenge == $ClientChallenge2`

Node replies with *Response*:

  * `Message.id == 2`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "challenge"`



