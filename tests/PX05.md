### PX05xxx - Neighborhood Related Functionality Tests

#### PX05001 - Neighborhood Related Calls - Unauthorized

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's neighbor port
  * Port for simulated Location Based Network server


##### Description 

The test sends *StartNeighborhoodInitializationRequest*, *FinishNeighborhoodInitializationRequest*, *NeighborhoodSharedActivityUpdateRequest*,
*StopNeighborhoodUpdatesRequest* to the proximity server without verifying its identity first.


###### Step 1:

The test connects to the neighbor port of the proximity server and sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 1`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it sends *FinishNeighborhoodInitializationRequest*:

  * `Message.id := 2`

and reads the response. Then it sends *NeighborhoodSharedActivityUpdateRequest*:

  * `Message.id := 3`
  * `NeighborhoodSharedActivityUpdateRequest.items = []`

and reads the response. Then it sends *StopNeighborhoodUpdatesRequest*:

  * `Message.id := 4`

and reads the response.


##### Acceptance Criteria

###### Step 1:

Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_UNAUTHORIZED`

Server replies with *Response*:
  
  * `Message.id == 2`
  * `Response.status == ERROR_UNAUTHORIZED`

Server replies with *Response*:
  
  * `Message.id == 3`
  * `Response.status == ERROR_UNAUTHORIZED`

Server replies with *Response*:
  
  * `Message.id == 4`
  * `Response.status == ERROR_UNAUTHORIZED`








#### PX05002 - Neighborhood Initialization Process - No Activities

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server


##### Description 

The test starts the neighborhood initialization process with the proximity server, which does not manage any activities.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port and connects 
to proximity server's neighbor port and verifies its identity. 


###### Step 2:

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it waits for *FinishNeighborhoodInitializationRequest* message:

  * `$Id := Message.Id`

and replies with *FinishNeighborhoodInitializationResponse*:

  * `Message.id := $Id`
  * `Response.status == STATUS_OK`



##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
Then the test successfully verifies its identity.


###### Step 2:

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends *FinishNeighborhoodInitializationRequest*.
  









#### PX05003 - Neighborhood Initialization Process - Small Set

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server


##### Description 

The test starts the neighborhood initialization process with a proximity server, which manages a small number of activities.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test creates a primary identity with public key `$PubKey` and connects to the proximity server's client port and creates following new activities:

  * $activityInfo1 is `version := [1,0,0], id := 1, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type A", lat/lon := (31.23, 121.47),  precision := 100,  startTime := current UTC timestamp - 1 hour,  expirationTime := current UTC timestamp + 1 hour,   extraData = ""`
  * $activityInfo2 is `version := [1,0,0], id := 2, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type A", lat/lon := (18.96, 72.82),   precision := 0,    startTime := current UTC timestamp - 2 hours, expirationTime := current UTC timestamp + 4 hours,  extraData = "t=running,Cycling,ice hockey,water polo"`
  * $activityInfo3 is `version := [1,0,0], id := 3, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Act. Type A",     lat/lon := (24.86, 67.01),   precision := 1000, startTime := current UTC timestamp - 3 hours, expirationTime := current UTC timestamp + 22 hours, extraData = "l=Karachi,PK;a=iop://185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969;t=traveling,cycling,running"`
  * $activityInfo4 is `version := [1,0,0], id := 4, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Act. Type B",     lat/lon := (-34.61, -58.37), precision := 123,  startTime := current UTC timestamp - 1 hour,  expirationTime := current UTC timestamp + 20 hours, extraData = ""`
  * $activityInfo5 is `version := [1,0,0], id := 5, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type B", lat/lon := (31.231, 121.47), precision := 500,  startTime := current UTC timestamp + 1 hour,  expirationTime := current UTC timestamp + 3 hours,  extraData = "running"`
  * $activityInfo6 is `version := [1,0,0], id := 6, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type C", lat/lon := (18.961, 72.82),  precision := 500,  startTime := current UTC timestamp + 2 hours, expirationTime := current UTC timestamp + 3 hours,  extraData = "MTg1ZjhkYjMyMjcxZmUyNWY1NjFhNmZjOTM4YjJlMjY0MzA2ZWMzMDRlZGE1MTgwMDdkMTc2NDgyNjM4MTk2OQ"`
  * $activityInfo7 is `version := [1,0,0], id := 7, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type C", lat/lon := (18.961, 72.82),  precision := 500,  startTime := current UTC timestamp + 3 hours, expirationTime := current UTC timestamp + 4 hours,  extraData = "t=running;l=Mumbai,IN"`


###### Step 2:

The test connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it waits for *NeighborhoodSharedActivityUpdateRequest* message:

  * `$Id1 := Message.Id`

and replies with *NeighborhoodSharedActivityUpdateResponse*:

  * `Message.id := $Id1`
  * `Response.status == STATUS_OK`

Then it waits for *FinishNeighborhoodInitializationRequest* message:

  * `$Id2 := Message.Id`

and replies with *FinishNeighborhoodInitializationResponse*:

  * `Message.id := $Id2`
  * `Response.status == STATUS_OK`



##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
Then the test successfully creates new activities.


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends *NeighborhoodSharedActivityUpdateRequest*:

  * `NeighborhoodSharedActivityUpdateRequest.items == 
    (
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
    )`

Server sends *FinishNeighborhoodInitializationRequest*.
  

















#### PX05004 - Neighborhood Initialization Process - Large Set

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server


##### Description 

The test starts the neighborhood initialization process with a proximity server, which manages a large number of activities.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test creates a primary identity which it uses to simulate another proximity server and then 
it creates 3500 test activities.


###### Step 2:

The test connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives information about all the test identities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message.



##### Acceptance Criteria


###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
Then the test successfully creates test activities.


###### Step 2:

The test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about all test activities.

Server sends *FinishNeighborhoodInitializationRequest*.


  







#### PX05005 - Neighborhood Updates

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "prox.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server
  * Base port for simulated proximity server


##### Description 

The test simulates a proximity server instance and establishes a neighborhood relationship with the target proximity server 
by invoking the neighborhood initialization process. The test sets up activities on the target server and manipulates them 
in order to receive neighborhood updates from it. Then the test requests the proximity server to stop sending updates 
and verifies that no more updates are sent. Finally, the test invokes the neighborhood initialization process again 
but does not complete it and verifies that no updates are coming.


###### Step 1:

The test creates two identities, one represents a simulated proximity server and the other one is used for creating 
and manipulating activities on the tested proximity server.

The test obtains a list of service ports from the proximity server's primary port.

The test creates 50 test activities on the tested proximity server.

The test then creates a server, on which it simulates part of the proximity server behavior.
The simulated proximity server uses the base port ($BasePort) as its primary port and $BasePort+1 as its neighbor port.


###### Step 2:

The test connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.neighborPort := $BasePort + 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives information about all the test identities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message.


###### Step 3:

The test creates 15 more activities. Then it waits 20 seconds.


###### Step 4:

The test selects 15 existing activities and deletes them from the proximity server. 
Then it waits 20 seconds.


###### Step 5:

The test selects 25 existing activities and changes them in a way it invokes the neighborhood propagation on the proximity server. 
Then it waits 20 seconds.


###### Step 6:

The test connects to proximity server's neighbor port and verifies its identity. 

The test sends *StopNeighborhoodUpdatesRequest*:

  * `Message.id := 3`

and reads the response.


###### Step 7:

The test creates 5 more activities. 

The test selects 5 existing activities and deletes them from the proximity server.

The test selects 5 existing activities and changes them in a way it invokes the neighborhood propagation on the proximity server.

Then it waits 20 seconds.


###### Step 8:

The test connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.neighborPort := $BasePort + 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. 


###### Step 9:

The test creates 5 more activities. 


###### Step 10:

The test waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives information about all the test activities.


###### Step 11:

The test creates 5 more activities. 


###### Step 12:

The test terminates the neighborhood initialization process by closing the connection.


###### Step 13:

The test creates 5 more activities. 

Then it waits 20 seconds.




##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
Then the test successfully creates the test activities.


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about all test identities.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 3:

The test successfully creates new test activities. 

The simulated proximity server receives neighborhood updates in form of *NeighborhoodSharedActivityUpdateRequest* 
for all the newly created activities on the target proximity server.


###### Step 4:

The test successfully deletes  selected activities.

The simulated proximity server receives neighborhood updates in form of *NeighborhoodSharedActivityUpdateRequest* 
for all the deleted activities on the target proximity server.


###### Step 5:

The test successfully changes selected activities.

The simulated proximity server receives neighborhood updates in form of *NeighborhoodSharedActivityUpdateRequest* 
for all the updated activities on the target proximity server.


###### Step 6:

Server replies with *StopNeighborhoodUpdatesResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


###### Step 7:

The test successfully creates new test activities. 

The test successfully deletes selected activities.

The test successfully changes selected activities.

The simulated proximity server does not receive any updates.


###### Step 8:

The the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


###### Step 9:

The test successfully creates new test activities.


###### Step 10:

Server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about all test activities.


###### Step 11:

The test successfully creates new test activities. 


###### Step 12:

Nothing to check.

###### Step 13:

The test successfully creates new test activities. 

The simulated proximity server does not receive any updates.







#### PX05006 - Neighborhood Initialization Process - Rejected

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * max_follower_servers_count set to 1 in the configuration file

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server


##### Description 

The test simulates a proximity server instance and establishes a neighborhood relationship with the target proximity server 
by invoking the neighborhood initialization process. It then simulates another proximity server instance and tries to establish 
a neighborhood relationship with the target proximity server, but this should fail as the target server only accepts 1 neighbor.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test creates a primary identity which it uses to simulate another proximity server and then 
it creates 10 test activities.


###### Step 2:

The test connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives information about all the test activities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message. Then it closes the connection.


###### Step 3:

With another identity, the test connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 2`
  * `StartNeighborhoodInitializationRequest.neighborPort := 2`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. 



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
Then the test successfully creates test activities. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about all test identities.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 3:

Then the test successfully verifies its identity.

Server replies with *Response*:
  
  * `Message.id == 3`
  * `Response.status == ERROR_REJECTED`










#### PX05007 - Neighborhood Initialization Process - Already Exists

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server


##### Description 

The test simulates a proximity server instance and establishes a neighborhood relationship with the target proximity server 
by invoking the neighborhood initialization process. The test then tries to start the neighborhood initialization process 
again, which should fail.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test creates a primary identity which it uses to simulate another proximity server and then 
it creates 10 test activities.


###### Step 2:

The test connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives information about all the test activities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message. Then it closes the connection.


###### Step 3:

The test connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 2`
  * `StartNeighborhoodInitializationRequest.neighborPort := 2`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. 



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
Then the test successfully creates new activities.


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about all test identities.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 3:

Then the test successfully verifies its identity.

Server replies with *Response*:
  
  * `Message.id == 3`
  * `Response.status == ERROR_ALREADY_EXISTS`









#### PX05008 - Neighborhood Initialization Process - Busy

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * neighborhood_initialization_parallelism set to 1 in the configuration file

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server


##### Description 

The test simulates a proximity server instance and establishes a neighborhood relationship with the target proximity server 
by invoking the neighborhood initialization process, but not completing it. It then simulates another proximity server instance 
and tries to establish a neighborhood relationship with the target proximity server, but this should fail as the target 
server only allows 1 unfinished neighborhood initialization process at the time. The test then finishes the first initialization 
process and then retries the second one, which should succeed.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test creates a primary identity which it uses to simulate another proximity server and then 
it creates 10 test activities.


###### Step 2:

Using the first identity, the test connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. 


###### Step 3:

Using the second identity, the test connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 2`
  * `StartNeighborhoodInitializationRequest.neighborPort := 2`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. 


###### Step 4:

Using the first identity, the test waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives information about all the test activities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message. Then it closes the connection.


###### Step 5:

Using the second identity, the test connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 2`
  * `StartNeighborhoodInitializationRequest.neighborPort := 2`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives information about all the test activities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message. Then it closes the connection.


##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
Then the test successfully creates new activities. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


###### Step 3:

Then the test successfully verifies its identity.

Server replies with *Response*:
  
  * `Message.id == 3`
  * `Response.status == ERROR_BUSY`


###### Step 4:

Server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about all test activities.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 5:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about all test activities.

Server sends *FinishNeighborhoodInitializationRequest*.













#### PX05009 - Neighborhood Initialization Process - Invalid Values

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server


##### Description 

The test attempts to initiate neighborhood initialization processes with invalid values.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 0`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 4`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 0`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 5`
  * `StartNeighborhoodInitializationRequest.primaryPort := 100000`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 6`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 100000`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 7`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress := [1,2,3]`
 
and reads the response. Then it sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 8`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress := []`
 
and reads the response. Then it sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 9`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress := [1,2,3,4,5]`
 
and reads the response. Then it sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 10`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress := [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]`
 
and reads the response. 



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 

Then the test successfully verifies its identity.

Server replies with *Response*:
  
  * `Message.id == 3`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "primaryPort"`


Server replies with *Response*:
  
  * `Message.id == 4`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "neighborPort"`


Server replies with *Response*:
  
  * `Message.id == 5`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "primaryPort"`


Server replies with *Response*:
  
  * `Message.id == 6`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "neighborPort"`

Server replies with *Response*:
  
  * `Message.id == 7`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "ipAddress"`

Server replies with *Response*:
  
  * `Message.id == 8`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "ipAddress"`

Server replies with *Response*:
  
  * `Message.id == 9`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "ipAddress"`

Server replies with *Response*:
  
  * `Message.id == 10`
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "ipAddress"`







#### PX05010 - Neighborhood Initialization Process - Interrupted

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * neighborhood_initialization_parallelism set to 1 in the configuration file

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server


##### Description 

The test simulates a proximity server instance and establishes a neighborhood relationship with the target proximity server 
by invoking the neighborhood initialization process, but it fails to complete it and disconnects in the middle of the session.
Then it tries again and this time the process should complete. The setting of neighborhood_initialization_parallelism to 1 
should not affect the result and the server should not block the second attempt since the client disconnected and thus terminated
the first attempt.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test creates a primary identity which it uses to simulate another proximity server and then 
it creates 3500 test activities.


###### Step 2:

The test then connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it waits for the first *NeighborhoodSharedActivityUpdateRequest* message, 
to which it replies *NeighborhoodSharedActivityUpdateResponse* message, and then it waits for the second 
*NeighborhoodSharedActivityUpdateRequest* message and disconnects.


###### Step 3:

The test then connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives information about all the test activities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message. Then it closes the connection.



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
Then the test successfully creates new activities.


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends two *NeighborhoodSharedActivityUpdateRequest* messages with information about some of the test activities.


###### Step 3:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about all test activities.

Server sends *FinishNeighborhoodInitializationRequest*.











#### PX05011 - Neighborhood Initialization Process - Updates Before Initialization Completes

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "prox.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server
  * Base port for simulated proximity server


##### Description 

The test simulates a proximity server instance and establishes a neighborhood relationship with the target proximity server 
by invoking the neighborhood initialization process. Before it completes the process, it creates new activities. 
This should result in update messages being sent after the initialization is finished.


###### Step 1:

The test creates two identities, one represents a simulated proximity server and the other one is used for creating 
and manipulating activities on the tested proximity server.

The test obtains a list of service ports from the proximity server's primary port.

The test creates a primary identity which it uses to simulate another proximity server and then 
it creates 10 test activities.

The test then creates a server, on which it simulates part of the proximity server behavior.
The simulated proximity server uses the base port ($BasePort) as its primary port and $BasePort+1 as its neighbor port.

###### Step 2:

The test then connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.neighborPort := $BasePort + 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. 


###### Step 3:

The test creates 5 more activities. 


###### Step 4:

The test waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives information about all the test activities.


###### Step 5:

The test creates 5 more activities. 


###### Step 6:

The test waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message. 


###### Step 7:

The test creates 5 more activities. 

Then it waits 20 seconds.


##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
Then the test successfully creates new activities.


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


###### Step 3:

The test successfully creates new activities. 


###### Step 4:

The server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about managed activities.


###### Step 5:

The test successfully creates new activities. 


###### Step 6:

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 7:

The test successfully creates new activities. 

The simulated proximity server received neighborhood updates in form of *NeighborhoodSharedActivityUpdateRequest* 
for all the new activities created on the target proximity server. And together with the activities received 
during the neighborhood initialization process, the test received information about all the test activities.













#### PX05012 - Neighborhood Initialization Process - Different Neighbor Port

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "prox.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server
  * Base port for simulated proximity server


##### Description 

The test simulates a proximity server instance and establishes a neighborhood relationship with the target proximity server 
by invoking the neighborhood initialization process. However, it claims different (invalid) neighbor port being used 
during the initialization process. This will cause problem to the target proximity server when it attempts 
to deliver the neighborhood updates to the simulated server and it will have to fallback to the primary port 
to get information about the real neighbor port in use.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test creates a primary identity which it uses to simulate another proximity server and then 
it creates 10 test activities.

The test then creates a server, on which it simulates part of the proximity server behavior.
The simulated proximity server uses the base port ($BasePort) as its primary port and $BasePort+1 as its neighbor port.

###### Step 2:

The test then connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives information about all the test activities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message.


###### Step 3:

The test creates 5 more activities. 

Then it waits up to 12 minutes while waiting for updates from the proximity server.


##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
Then the test successfully creates new activities. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


Server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about managed activities.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 3:

Then the test successfully creates new activities. 

The simulated proximity server received neighborhood updates in form of *NeighborhoodSharedActivityUpdateRequest* 
for all the new activities created on the target proximity server. 














#### PX05013 - Neighborhood Initialization Process - Bad Role Neighbor Port

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "prox.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server
  * Base port for simulated proximity server


##### Description 

The test does exactly the same as PX05012 except that the claimed neighbor port in use is actually its client port.
which it runs on port $BasePort + 2, and therefore the proximity server will get ERROR_BAD_ROLE statuses on its neighborhood related requests.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test creates a primary identity which it uses to simulate another proximity server and then 
it creates 10 test activities.

The test then creates a server, on which it simulates part of the proximity server behavior.
The simulated proximity server uses the base port ($BasePort) as its primary port, $BasePort+1 as its neighbor port,
and $BasePort+2 as its client port.

###### Step 2:

The test then connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.neighborPort := $BasePort + 2`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives information about all the test activities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message.


###### Step 3:

The test creates 5 more activities. 

Then it waits up to 12 minutes while waiting for updates from the proximity server.


##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
Then the test successfully creates new activities. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


Server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about managed activities.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 3:

Then the test successfully creates new activities. 

The simulated proximity server received neighborhood updates in form of *NeighborhoodSharedActivityUpdateRequest* 
for all the new activities created on the target proximity server. 














#### PX05014 - Neighborhood Initialization Process - Timeout

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * neighborhood_initialization_parallelism set to 1 in the configuration file

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server


##### Description 

The test simulates a proximity server instance and establishes a neighborhood relationship with the target proximity server 
by invoking the neighborhood initialization process. However, in the middle of the process it stops replying to update 
requests, which should cause the session to time out and be terminated. Then the test attempts again and completes 
the process successfullly.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test creates a primary identity which it uses to simulate another proximity server and then 
it creates 10 test activities.


###### Step 2:

The test then connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives information about all the test activities.

Then it waits for *FinishNeighborhoodInitializationRequest* and then waits 450 seconds. Then it 
replies with corresponding *FinishNeighborhoodInitializationResponse* message and closes the connection.


###### Step 3:

The test then connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives information about all the test activities.

Then it waits for *FinishNeighborhoodInitializationRequest* and and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message and closes the connection.


##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
Then the test successfully creates new activities. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


Server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about managed activities.


###### Step 3:

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


Server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about managed activities.

Server sends *FinishNeighborhoodInitializationRequest*.












#### PX05015 - Neighborhood Initialization Process - Parallel Processing

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server


##### Description 

The test attempts to initiate three parallel neighborhood initialization processes with three different identities.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test creates a primary identity which it uses to simulate another proximity server and then 
it creates 10 test activities.


###### Step 2:

With the first identity, the test connects to proximity server's neighbor port and verifies its identity. 

Then it sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. 


###### Step 3:

With the second identity, the test then connects to proximity server's neighbor port and verifies its identity. 

Then it sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. 

Then it waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives information about all the test activities.


###### Step 4:

With the third identity, the test then connects to proximity server's neighbor port and verifies its identity. 

Then it sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. 


###### Step 5:

With the first identity, it waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives information about all the test activities.

Then it waits for *FinishNeighborhoodInitializationRequest* and and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message and closes the connection.


###### Step 6:

With the third identity, it waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives information about all the test activities.

Then it waits for *FinishNeighborhoodInitializationRequest* and and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message and closes the connection.


###### Step 7:

With the second identity, it waits for *FinishNeighborhoodInitializationRequest* and and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message and closes the connection.



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
Then the test successfully creates new activities. 


###### Step 2:

Then the test successfully verifies its first identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


###### Step 3:

Then the test successfully verifies its second identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about managed activities.


###### Step 4:

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


###### Step 5:

Server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about managed activities.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 6:

Server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about managed activities.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 7:

Server sends *FinishNeighborhoodInitializationRequest*.










#### PX05016 - Neighborhood Updates - Rejected

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "prox.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server
  * Base port for simulated proximity server


##### Description 

The test simulates a proximity server instance and establishes a neighborhood relationship with the target proximity server 
by invoking the neighborhood initialization process. The test sets up identities on the target server and manipulates them 
in order to receive neighborhood updates from it. At one point, the test rejects the update and then sets up more identities 
to verify that no more update will arrive.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test creates a primary identity which it uses to simulate another proximity server and then 
it creates 10 test activities.

The test then creates a server, on which it simulates part of the proximity server behavior.
The simulated proximity server uses the base port ($BasePort) as its primary port and $BasePort+1 as its neighbor port.


###### Step 2:

The test connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.neighborPort := $BasePort + 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives information about all the test activities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message.


###### Step 3:

The test creates 5 more activities. Then it waits 20 seconds.


###### Step 4:

The test creates 1 more activity and waits 20 seconds for the related update to come, to which it replies with ERROR_REJECTED.


###### Step 5:

The test creates 5 more activities. Then it waits 20 seconds.



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
Then the test successfully creates new activities. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about all test activities.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 3:

Then the test successfully creates new activities. 

The simulated proximity server receives neighborhood updates in form of *NeighborhoodSharedActivityUpdateRequest* 
for all the newly hosted profiles on the target proximity server.


###### Step 4:

Then the test successfully creates new activity. 


###### Step 5:

Then the test successfully creates new activities. 

The simulated proximity server does not receive any updates.









#### PX05017 - Neighborhood Requests - No Initialization

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server


##### Description 

The test sends *FinishNeighborhoodInitializationRequest*, *NeighborhoodSharedActivityUpdateRequest*, and *StopNeighborhoodUpdatesRequest* 
to the proximity server without starting the network initialization process.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test connects to proximity server's neighbor port and verifies its identity. 

The test sends *FinishNeighborhoodInitializationRequest*:

  * `Message.id := 3`

and reads the response. The test sends *NeighborhoodSharedActivityUpdateRequest*:

  * `Message.id := 4`
  * `NeighborhoodSharedActivityUpdateRequest.items := []`

and reads the response. The test sends *StopNeighborhoodUpdatesRequest*:

  * `Message.id := 5`

and reads the response.




##### Acceptance Criteria

###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 

Then the test successfully verifies its identity.

Server replies with *Response*:
  
  * `Message.id == 3`
  * `Response.status == ERROR_REJECTED`

Server replies with *Response*:
  
  * `Message.id == 4`
  * `Response.status == ERROR_REJECTED`

Server replies with *Response*:
  
  * `Message.id == 5`
  * `Response.status == ERROR_NOT_FOUND`










#### PX05018 - New Neighbor - Empty Database

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "prox.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server
  * Base port for simulated proximity server


##### Description 

The test simulates a proximity server instance and a location based network server. The location server informs the real 
target proximity server that a new neighbor (the simulated proximity server) was added to its neighborhood. The target 
proximity server should contact the simulated proximity server and invoke the neighborhood initialization process.
The simulated proximity server will immediately finish the process as it simulates empty database.


###### Step 1:

The test creates a server, on which it simulates part of the proximity server behavior. The simulated proximity server uses 
the base port ($BasePort) as its primary port and $BasePort+1 as its neighbor port.

The test then simulates the location server and let's the target proximity server to perform the LOC initialization 
with the simulated location server. 


###### Step 2:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test then sends *FinishNeighborhoodInitializationRequest* to the target proximity server over the simulated proximity 
server's connection and waits for *FinishNeighborhoodInitializationResponse*.



##### Acceptance Criteria



###### Step 1:

The test successfully starts simulated proximity server and simulated LOC server. 
The target proximity server successfully connects to the simulated LOC server and initializes the LOC session.


###### Step 2:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *FinishNeighborhoodInitializationResponse*.











#### PX05019 - New Neighbor - Small Set

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "prox.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server
  * Base port for simulated proximity server


##### Description 

The test simulates a proximity server instance and a location based network server. The location server informs the real 
target proximity server that a new neighbor (the simulated proximity server) was added to its neighborhood. The target 
proximity server should contact the simulated proximity server and invoke the neighborhood initialization process.
The simulated proximity server will send a small number of activities to the target server. The test then verifies 
that the target proximity server includes the shared activities in its search queries.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test creates following activities:

  * $activityInfo1 is `version := [1,0,0], id := 1, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type A", lat/lon := (31.23, 121.47),  precision := 100,  startTime := current UTC timestamp - 1 hour,  expirationTime := current UTC timestamp + 1 hour,   extraData = ""`
  * $activityInfo2 is `version := [1,0,0], id := 2, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type A", lat/lon := (18.96, 72.82),   precision := 0,    startTime := current UTC timestamp - 2 hours, expirationTime := current UTC timestamp + 4 hours,  extraData = "t=running,Cycling,ice hockey,water polo"`
  * $activityInfo3 is `version := [1,0,0], id := 3, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Act. Type A",     lat/lon := (24.86, 67.01),   precision := 1000, startTime := current UTC timestamp - 3 hours, expirationTime := current UTC timestamp + 22 hours, extraData = "l=Karachi,PK;a=iop://185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969;t=traveling,cycling,running"`
  * $activityInfo4 is `version := [1,0,0], id := 4, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Act. Type B",     lat/lon := (-34.61, -58.37), precision := 123,  startTime := current UTC timestamp - 1 hour,  expirationTime := current UTC timestamp + 20 hours, extraData = ""`
  * $activityInfo5 is `version := [1,0,0], id := 5, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type B", lat/lon := (31.231, 121.47), precision := 500,  startTime := current UTC timestamp + 1 hour,  expirationTime := current UTC timestamp + 3 hours,  extraData = "running"`
  * $activityInfo6 is `version := [1,0,0], id := 6, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type C", lat/lon := (18.961, 72.82),  precision := 500,  startTime := current UTC timestamp + 2 hours, expirationTime := current UTC timestamp + 3 hours,  extraData = "MTg1ZjhkYjMyMjcxZmUyNWY1NjFhNmZjOTM4YjJlMjY0MzA2ZWMzMDRlZGE1MTgwMDdkMTc2NDgyNjM4MTk2OQ"`
  * $activityInfo7 is `version := [1,0,0], id := 7, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type C", lat/lon := (18.961, 72.82),  precision := 500,  startTime := current UTC timestamp + 3 hours, expirationTime := current UTC timestamp + 4 hours,  extraData = "t=running;l=Mumbai,IN"`


The test creates a server, on which it simulates part of the proximity server behavior. The simulated proximity server uses 
the base port ($BasePort) as its primary port and $BasePort+1 as its neighbor port.

The test then simulates the location server and let's the target proximity server to perform the LOC initialization 
with the simulated location server. 


###### Step 2:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

  * `NeighborhoodSharedActivityUpdateRequest.items := 
    [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
    ]`

to the target proximity server over the simulated proximity server's connection and waits for *NeighborhoodSharedActivityUpdateResponse*.

The test then sends *FinishNeighborhoodInitializationRequest* to the target proximity server over the simulated proximity
server's connection and waits for *FinishNeighborhoodInitializationResponse*.


###### Step 3:

The test connects to client port of the target proximity server and starts conversation, 
then it sends *ActivitySearchRequest* to find all test activities:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ActivitySearchRequest.includePrimaryOnly := false`
  * `ActivitySearchRequest.maxResponseRecordCount := 100`
  * `ActivitySearchRequest.maxTotalRecordCount := 100`
  * `ActivitySearchRequest.ownerNetworkId := []`
  * `ActivitySearchRequest.type := ""`
  * `ActivitySearchRequest.startNotAfter := 0`
  * `ActivitySearchRequest.expirationNotBefore := 0`
  * `ActivitySearchRequest.latitude := NO_LOCATION`
  * `ActivitySearchRequest.longitude := NO_LOCATION`
  * `ActivitySearchRequest.radius := 0`
  * `ActivitySearchRequest.extraData := ""`

and reads the response.




##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
The test successfully starts simulated proximity server and simulated LOC server. 
The target proximity server successfully connects to the simulated LOC server and initializes the LOC session.


###### Step 2:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *NeighborhoodSharedActivityUpdateResponse*.

The target proximity server sends the corresponding *FinishNeighborhoodInitializationResponse*.


###### Step 3:

The proximity server sends *ActivitySearchResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ActivitySearchResponse.totalRecordCount == 7`
  * `ActivitySearchResponse.maxResponseRecordCount == 100`
  * `ActivitySearchResponse.activities.Count == 7`
  * `ActivitySearchResponse.coveredServers == (ID of target proximity server, $SimPxId := ID of simulated proximity server)`
  * `ActivitySearchResponse.activities == 
    (
      {isPrimary == false; primaryServer.networkId == $SimPxId signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1},
      {isPrimary == false; primaryServer.networkId == $SimPxId signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2},
      {isPrimary == false; primaryServer.networkId == $SimPxId signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3},
      {isPrimary == false; primaryServer.networkId == $SimPxId signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4},
      {isPrimary == false; primaryServer.networkId == $SimPxId signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5},
      {isPrimary == false; primaryServer.networkId == $SimPxId signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6},
      {isPrimary == false; primaryServer.networkId == $SimPxId signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7},
    )`









#### PX05020 - New Neighbor - Large Set

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "prox.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server
  * Base port for simulated proximity server


##### Description 

The test simulates a proximity server instance and a location based network server. The location server informs the real 
target proximity server that a new neighbor (the simulated proximity server) was added to its neighborhood. The target 
proximity server should contact the simulated proximity server and invoke the neighborhood initialization process.
The simulated proximity server will send a large number of activities to the target server. The test then verifies 
that the target proximity server includes the shared activities in its search queries.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test generates positive integers R1, R2, and R3:

  * `20,000 < R2 < 150,000`
  * `5,000 < R1 < 0.8 * R2`
  * `1.50 * R2 < R3 < 500,000`

The test generates 20 GPS locations, first 15 locations are generated as follows:

  * Location 1 is within R2 range of (0.0, 0.0),
  * location 2 is within R2 range of (89.9, 0.0),
  * location 3 is within R2 range of (-89.9, 0.0),
  * location 4 is within R2 range of (40.0, 0.0),
  * location 5 is within R2 range of (0.0, 179.9),
  * location 6 is within R2 range of (89.9, 179.9),
  * location 7 is within R2 range of (-89.9, 179.9),
  * location 8 is within R2 range of (40.0, 179.9),
  * location 9 is within R2 range of (0.0, -179.9),
  * location 10 is within R2 range of (89.9, -179.9),
  * location 11 is within R2 range of (-89.9, -179.9),
  * location 12 is within R2 range of (40.0, -179.9),
  * location 13 is within R2 range of (0.0, 50.0),
  * location 14 is within R2 range of (89.9, 50.0),
  * location 15 is within R2 range of (-89.9, 50.0).

the remaining 5 locations are random GPS locations.

For each of 20 locations, the test generates 10 activities that are all located randomly within 
R1 range of the location, 10 activities within R2 range and 10 activities within R3 range.


The test creates a server, on which it simulates part of the proximity server behavior. The simulated proximity server uses 
the base port ($BasePort) as its primary port and $BasePort+1 as its neighbor port.

The test then simulates the location server and let's the target proximity server to perform the LOC initialization 
with the simulated location server. 


###### Step 2:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends a series of *NeighborhoodSharedActivityUpdateRequest* messages to share all the generated activities
with the target proximity server and waits for corresponding *NeighborhoodSharedActivityUpdateResponse*.

The test then sends *FinishNeighborhoodInitializationRequest* to the target proximity server over the simulated proximity 
server's connection and waits for *FinishNeighborhoodInitializationResponse* messages.


###### Step 3:

The test connects to client port of the target proximity server. 

The test performs search queries using *ActivitySearchRequest*. For each of the 20 locations, it searches for activities
located within R1, R2 and R3 and a random number (new for each query) within the range of 1,000,000 to 10,000,000.
The tests verifies that the search results match the expected results.



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
The test successfully starts simulated proximity server and simulated LOC server. 
The target proximity server successfully connects to the simulated LOC server and initializes the LOC session.


###### Step 2:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *NeighborhoodSharedActivityUpdateResponse*.

The target proximity server sends the corresponding *FinishNeighborhoodInitializationResponse*.


###### Step 3:

The proximity server's results for each search query match locally computed expected results. 








#### PX05021 - New Neighbor - Too Many Activities

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "prox.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server
  * Base port for simulated proximity server


##### Description 

The test simulates a proximity server instance and a location based network server. The location server informs the real 
target proximity server that a new neighbor (the simulated proximity server) was added to its neighborhood. The target 
proximity server should contact the simulated proximity server and invoke the neighborhood initialization process.

The simulated proximity server sends more than a maximum number (50,000) of activities to the target server, 
so the initialization process should fail. The test then verifies that the target proximity server does not include any 
of the shared activities in its search queries.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test generates 50,500 activities.

The test creates a server, on which it simulates part of the proximity server behavior. The simulated proximity server uses 
the base port ($BasePort) as its primary port and $BasePort+1 as its neighbor port.

The test then simulates the location server and let's the target proximity server to perform the LOC initialization 
with the simulated location server. 


###### Step 2:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends a series of *NeighborhoodSharedActivityUpdateRequest* messages to share all the generated activities
with the target proximity server and waits for corresponding *NeighborhoodSharedActivityUpdateResponse* messages.


###### Step 3:

The test connects to client port of the target proximity server, 

The test performs a search queries using *ActivitySearchRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ActivitySearchRequest.includePrimaryOnly := false`
  * `ActivitySearchRequest.maxResponseRecordCount := 100`
  * `ActivitySearchRequest.maxTotalRecordCount := 100`
  * `ActivitySearchRequest.ownerNetworkId := []`
  * `ActivitySearchRequest.type := ""`
  * `ActivitySearchRequest.startNotAfter := 0`
  * `ActivitySearchRequest.expirationNotBefore := 0`
  * `ActivitySearchRequest.latitude := NO_LOCATION`
  * `ActivitySearchRequest.longitude := NO_LOCATION`
  * `ActivitySearchRequest.radius := 0`
  * `ActivitySearchRequest.extraData := ""`

and reads the response.



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
The test successfully starts simulated proximity server and simulated LOC server. 
The target proximity server successfully connects to the simulated LOC server and initializes the LOC session.


###### Step 2:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *NeighborhoodSharedActivityUpdateResponse*.

The target proximity server sends *Response*:
  
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "$x.add"`, where $x is the index of the 50,001st update item within its update batch.


###### Step 3:

The target proximity server replies *ActivitySearchResponse*:

  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ActivitySearchResponse.totalRecordCount == 0`
  * `ActivitySearchResponse.maxResponseRecordCount == 100`
  * `ActivitySearchResponse.activities.Count == 0`











#### PX05022 - New Neighbor - Too Many Activities - Update

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "prox.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server
  * Base port for simulated proximity server


##### Description 

The test simulates a proximity server instance and a location based network server. The location server informs the real 
target proximity server that a new neighbor (the simulated proximity server) was added to its neighborhood. The target 
proximity server should contact the simulated proximity server and invoke the neighborhood initialization process.

The simulated proximity server sends close to a maximum number (50,000) of activities to the target server 
and then once the initialization process finishes, it sends a neighborhood update that will exceed the limit. 
The test then verifies that the target proximity server does not include any of the activities that would exceed the limit 
in its search queries. Then the test sends more update messages to test the behavior of the proximity server 
when the number of shared profiles is close to the limit.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test generates 50,050 identities. Activities number 49,991 to 50,050 will have type set to "last".

The test creates a server, on which it simulates part of the proximity server behavior. The simulated proximity server uses 
the base port ($BasePort) as its primary port and $BasePort+1 as its neighbor port.

The test then simulates the location server and let's the target proximity server to perform the LOC initialization 
with the simulated location server. 


###### Step 2:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends a series of *NeighborhoodSharedActivityUpdateRequest* messages to share the first 49,990 of the generated 
activities with the target proximity server and waits for corresponding *NeighborhoodSharedActivityUpdateResponse* messages.

The test then sends *FinishNeighborhoodInitializationRequest* to the target proximity server over the simulated proximity 
server's connection and waits for *FinishNeighborhoodInitializationResponse* messages.


###### Step 3:

The test connects to the neighbor port of the target proximity server, verifies its identity, and sends 
*NeighborhoodSharedActivityUpdateRequest* message to add the remaining 60 activities and reads the response.


###### Step 4:

The test connects to client port of the target proximity server and starts conversation sends *ActivitySearchRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `ActivitySearchRequest.includePrimaryOnly := false`
  * `ActivitySearchRequest.maxResponseRecordCount := 100`
  * `ActivitySearchRequest.maxTotalRecordCount := 100`
  * `ActivitySearchRequest.ownerNetworkId := []`
  * `ActivitySearchRequest.type := "last"`
  * `ActivitySearchRequest.startNotAfter := 0`
  * `ActivitySearchRequest.expirationNotBefore := 0`
  * `ActivitySearchRequest.latitude := NO_LOCATION`
  * `ActivitySearchRequest.longitude := NO_LOCATION`
  * `ActivitySearchRequest.radius := 0`
  * `ActivitySearchRequest.extraData := ""`

and reads the response.



###### Step 5:

The test selects 140 activities and connects to the neighbor port of the target proximity server, verifies its identity,
and sends *NeighborhoodSharedActivityUpdateRequest* message to delete the selected activities and reads the response.

Then the test generates 160 new activities (with type set to "last") and sends *NeighborhoodSharedActivityUpdateRequest* 
message to add them to the target proximity server.


###### Step 6:

The test connects to client port of the proximity server and sends *ActivitySearchRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ActivitySearchRequest.includePrimaryOnly := false`
  * `ActivitySearchRequest.maxResponseRecordCount := 100`
  * `ActivitySearchRequest.maxTotalRecordCount := 100`
  * `ActivitySearchRequest.ownerNetworkId := []`
  * `ActivitySearchRequest.type := "last"`
  * `ActivitySearchRequest.startNotAfter := 0`
  * `ActivitySearchRequest.expirationNotBefore := 0`
  * `ActivitySearchRequest.latitude := NO_LOCATION`
  * `ActivitySearchRequest.longitude := NO_LOCATION`
  * `ActivitySearchRequest.radius := 0`
  * `ActivitySearchRequest.extraData := ""`

and reads the response.


###### Step 7:

The test selects 40 existing activities, which are to be deleted, and 40 activities, which are to be changed,
and generates 40 new activities (with type set to "last"), which are to be added.

The test connects to the neighbor port of the target proximity server, verifies its identity,
and sends *NeighborhoodSharedActivityUpdateRequest* message to announce all changes, putting the deleted 
activities first and reads the response.


###### Step 8:

The test connects to client port of the proximity server and sends *ActivitySearchRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `ActivitySearchRequest.includePrimaryOnly := false`
  * `ActivitySearchRequest.maxResponseRecordCount := 100`
  * `ActivitySearchRequest.maxTotalRecordCount := 100`
  * `ActivitySearchRequest.ownerNetworkId := []`
  * `ActivitySearchRequest.type := "last"`
  * `ActivitySearchRequest.startNotAfter := 0`
  * `ActivitySearchRequest.expirationNotBefore := 0`
  * `ActivitySearchRequest.latitude := NO_LOCATION`
  * `ActivitySearchRequest.longitude := NO_LOCATION`
  * `ActivitySearchRequest.radius := 0`
  * `ActivitySearchRequest.extraData := ""`

and reads the response.



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
The test successfully starts simulated proximity server and simulated LOC server. 
The target proximity server successfully connects to the simulated LOC server and initializes the LOC session.


###### Step 2:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *NeighborhoodSharedActivityUpdateResponse*.

The target proximity server sends the corresponding *FinishNeighborhoodInitializationResponse*.


###### Step 3:

The test successfullly verifies its identity.

The target proximity server replies *Response*:
  
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "10.add"`


###### Step 4:

The target proximity server replies with *ActivitySearchResponse* that contains only identities numbers 49,991 to 50,000.


###### Step 5:

The test successfullly verifies its identity.

The target proximity server replies *Response*:
  
  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "140.add"`


###### Step 6:

The target proximity server replies with *ActivitySearchResponse* that does not contain the activities exceeding the limits.


###### Step 7:

The test successfullly verifies its identity.

The target proximity server replies with the corresponding *NeighborhoodSharedActivityUpdateResponse*:

  * `Response.status == STATUS_OK`


###### Step 8:

The target proximity server replies with *ActivitySearchResponse* that contains all activities retrieved in Step 6 plus 
the newly created activities.
















#### PX05023 - New Neighbor - Invalid Requests

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "prox.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server
  * Base port for simulated proximity server


##### Description 

The test simulates a proximity server instance and a location based network server. The location server informs the real 
target proximity server that a new neighbor (the simulated proximity server) was added to its neighborhood. The target 
proximity server should contact the simulated proximity server and invoke the neighborhood initialization process.

The simulated proximity server sends update requests, with one invalid update item to test error handling on the target 
proximity server. The initialization process should fail and the simulated proximity server tries again with another type 
of invalid update item.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test creates following activities:

  * $activityInfo1 is `version := [1,0,0], id := 1, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type A", lat/lon := (31.23, 121.47),  precision := 100,  startTime := current UTC timestamp - 1 hour,  expirationTime := current UTC timestamp + 1 hour,   extraData = ""`
  * $activityInfo2 is `version := [1,0,0], id := 2, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type A", lat/lon := (18.96, 72.82),   precision := 0,    startTime := current UTC timestamp - 2 hours, expirationTime := current UTC timestamp + 4 hours,  extraData = "t=running,Cycling,ice hockey,water polo"`
  * $activityInfo3 is `version := [1,0,0], id := 3, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Act. Type A",     lat/lon := (24.86, 67.01),   precision := 1000, startTime := current UTC timestamp - 3 hours, expirationTime := current UTC timestamp + 22 hours, extraData = "l=Karachi,PK;a=iop://185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969;t=traveling,cycling,running"`
  * $activityInfo4 is `version := [1,0,0], id := 4, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Act. Type B",     lat/lon := (-34.61, -58.37), precision := 123,  startTime := current UTC timestamp - 1 hour,  expirationTime := current UTC timestamp + 20 hours, extraData = ""`
  * $activityInfo5 is `version := [1,0,0], id := 5, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type B", lat/lon := (31.231, 121.47), precision := 500,  startTime := current UTC timestamp + 1 hour,  expirationTime := current UTC timestamp + 3 hours,  extraData = "running"`
  * $activityInfo6 is `version := [1,0,0], id := 6, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type C", lat/lon := (18.961, 72.82),  precision := 500,  startTime := current UTC timestamp + 2 hours, expirationTime := current UTC timestamp + 3 hours,  extraData = "MTg1ZjhkYjMyMjcxZmUyNWY1NjFhNmZjOTM4YjJlMjY0MzA2ZWMzMDRlZGE1MTgwMDdkMTc2NDgyNjM4MTk2OQ"`
  * $activityInfo7 is `version := [1,0,0], id := 7, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type C", lat/lon := (18.961, 72.82),  precision := 500,  startTime := current UTC timestamp + 3 hours, expirationTime := current UTC timestamp + 4 hours,  extraData = "t=running;l=Mumbai,IN"`


The test creates a server, on which it simulates part of the proximity server behavior. The simulated proximity server uses 
the base port ($BasePort) as its primary port and $BasePort+1 as its neighbor port.

The test then simulates the location server and let's the target proximity server to perform the LOC initialization 
with the simulated location server. 


###### Step 2:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for version := [1,0]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 3:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for version := [0,0,0]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 4:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for version := [1,0,0,0]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.



###### Step 5:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 6:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for id := 0}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 7:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for ownerPublicKey := [1]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 8:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for ownerPublicKey := array of 200 bytes 0x12}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.



###### Step 9:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for profileServerContact.networkId := [1]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 10:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for profileServerContact.networkId := array of 40 bytes 0x12}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.



###### Step 11:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for profileServerContact.ipAddress := [1]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 12:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for profileServerContact.ipAddress := array of 40 bytes 0x12}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.



###### Step 13:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for profileServerContact.primaryPort := 0}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 14:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for profileServerContact.primaryPort := 70000}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.



###### Step 15:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for type := string of 100 'a' characters}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 16:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for type := string of 50 'ɐ' characters (UTF8 code 0xc990), which consume 2 bytes per character}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.



###### Step 17:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for latitude := 987654321}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 18:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for latitude := -987654321}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 19:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for longitude := 987654321}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 20:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for longitude := -987654321}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 21:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for precision := 10000}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.



###### Step 22:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for startTime := 987654321987654321}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 23:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for expirationTime := 987654321987654321}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 24:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for startTime := current UTC timestamp + 1 hour, expirationTime := current UTC timestamp}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.




###### Step 25:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for startTime := current UTC timestamp + 2 hours, expirationTime := current UTC timestamp + 25 hours}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 26:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for extraData := string of 3000 'a' characters}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 27:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for extraData := string of 1500 'ɐ' characters (UTF8 code 0xc990), which consume 2 bytes per character}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 28:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.activity matches $activityInfo3, signedActivity.signature := []}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 29:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.activity matches $activityInfo3, signedActivity.signature := [1]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 30:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.activity matches $activityInfo3, signedActivity.signature is a signature of signedActivity.activity with first byte XORed with 0x12}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.



###### Step 31:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.activity matches $activityInfo3, signedActivity.signature := array of 200 bytes 0x12}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 32:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.


###### Step 33:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = delete, delete {id := $activityInfo3.id, ownerNetworkId := $activityInfo3.ownerNetworkId}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then it disconnects.

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is no longer in its neighborhood.





##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
The test successfully starts simulated proximity server and simulated LOC server. 
The target proximity server successfully connects to the simulated LOC server and initializes the LOC session.


###### Step 2:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.version"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 3:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.version"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 4:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.version"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 5:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.id"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 6:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.id"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 7:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.signature"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 8:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.ownerPublicKey"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.

###### Step 9:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.profileServerContact.networkId"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 10:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.profileServerContact.networkId"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 11:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.profileServerContact.ipAddress"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 12:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.profileServerContact.ipAddress"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.



###### Step 13:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.profileServerContact.primaryPort"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 14:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.profileServerContact.primaryPort"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 15:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.type"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 16:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.type"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 17:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.latitude"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 18:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.latitude"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 19:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.longitude"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 20:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.longitude"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 21:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.precision"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 22:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.startTime" OR Response.details == "2.add.signedActivity.activity.expirationTime"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 23:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.expirationTime"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 24:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.expirationTime"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 25:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.expirationTime"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 26:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.extraData"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 27:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.extraData"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 28:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.signature"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 29:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.signature"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 30:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.signature"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 31:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.signature"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 32:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.actionType"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.


###### Step 33:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.actionType"`

Simulated LOC server successfully sends notification message about removing the simulated proximity server from the target proximity server's neighborhood.









#### PX05024 - Neighborhood Update - Invalid Requests

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "prox.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server
  * Base port for simulated proximity server


##### Description 

The test simulates a proximity server instance and a location based network server. The location server informs the real 
target proximity server that a new neighbor (the simulated proximity server) was added to its neighborhood. The target 
proximity server should contact the simulated proximity server and invoke the neighborhood initialization process.

The simulated proximity server successfully performs the neighborhood initialization process with the target proximity server 
and then it sends a series of update requests, each with one invalid update item to test error handling on the target 
proximity server. 


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test creates following activities:

  * $activityInfo1 is `version := [1,0,0], id := 1, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type A", lat/lon := (31.23, 121.47),  precision := 100,  startTime := current UTC timestamp - 1 hour,  expirationTime := current UTC timestamp + 1 hour,   extraData = ""`
  * $activityInfo2 is `version := [1,0,0], id := 2, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type A", lat/lon := (18.96, 72.82),   precision := 0,    startTime := current UTC timestamp - 2 hours, expirationTime := current UTC timestamp + 4 hours,  extraData = "t=running,Cycling,ice hockey,water polo"`
  * $activityInfo3 is `version := [1,0,0], id := 3, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Act. Type A",     lat/lon := (24.86, 67.01),   precision := 1000, startTime := current UTC timestamp - 3 hours, expirationTime := current UTC timestamp + 22 hours, extraData = "l=Karachi,PK;a=iop://185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969;t=traveling,cycling,running"`
  * $activityInfo4 is `version := [1,0,0], id := 4, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Act. Type B",     lat/lon := (-34.61, -58.37), precision := 123,  startTime := current UTC timestamp - 1 hour,  expirationTime := current UTC timestamp + 20 hours, extraData = ""`
  * $activityInfo5 is `version := [1,0,0], id := 5, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type B", lat/lon := (31.231, 121.47), precision := 500,  startTime := current UTC timestamp + 1 hour,  expirationTime := current UTC timestamp + 3 hours,  extraData = "running"`
  * $activityInfo6 is `version := [1,0,0], id := 6, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type C", lat/lon := (18.961, 72.82),  precision := 500,  startTime := current UTC timestamp + 2 hours, expirationTime := current UTC timestamp + 3 hours,  extraData = "MTg1ZjhkYjMyMjcxZmUyNWY1NjFhNmZjOTM4YjJlMjY0MzA2ZWMzMDRlZGE1MTgwMDdkMTc2NDgyNjM4MTk2OQ"`
  * $activityInfo7 is `version := [1,0,0], id := 7, ownerPublicKey := $PubKey, profileServerContact := { networkId := SHA256("test"), ipAddress := 127.0.0.1, primaryPort := 16987 },  type := "Activity Type C", lat/lon := (18.961, 72.82),  precision := 500,  startTime := current UTC timestamp + 3 hours, expirationTime := current UTC timestamp + 4 hours,  extraData = "t=running;l=Mumbai,IN"`


The test creates a server, on which it simulates part of the proximity server behavior. The simulated proximity server uses 
the base port ($BasePort) as its primary port and $BasePort+1 as its neighbor port.

The test then simulates the location server and let's the target proximity server to perform the LOC initialization 
with the simulated location server. 


###### Step 2:

Then test's location server sends a notification message to the proximity server with the information that the simulated 
proximity server is a new neighbor in its neighborhood.

The simulated proximity server then waits for *StartNeighborhoodInitializationRequest* message, to which it replies 
with corresponding *StartNeighborhoodInitializationResponse*.

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo6}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7}},
   ]`

and reads the response. Then the test sends *FinishNeighborhoodInitializationRequest* and reads the response.


###### Step 3:

The test connects to neighbor port of the target proximity server, verifies its identity, and sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for version := [1,0]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response. 


###### Step 4:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for version := [0,0,0]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response. 


###### Step 5:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for version := [1,0,0,0]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response. 


###### Step 6:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo1}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response. 


###### Step 7:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 8:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for id := 0}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response. 



###### Step 9:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for ownerPublicKey := [1]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response. 


###### Step 10:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for ownerPublicKey := array of 200 bytes 0x12}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 11:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for profileServerContact.networkId := [1]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.



###### Step 12:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for profileServerContact.networkId := array of 40 bytes 0x12}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.



###### Step 13:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for profileServerContact.ipAddress := [1]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.



###### Step 14:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for profileServerContact.ipAddress := array of 40 bytes 0x12}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 15:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for profileServerContact.primaryPort := 0}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 16:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for profileServerContact.primaryPort := 70000}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 17:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for type := string of 100 'a' characters}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 18:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for type := string of 50 'ɐ' characters (UTF8 code 0xc990), which consume 2 bytes per character}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 19:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for latitude := 987654321}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 20:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for latitude := -987654321}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 21:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for longitude := 987654321}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 22:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for longitude := -987654321}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.



###### Step 23:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for precision := 10000}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response. 


###### Step 24:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for startTime := 987654321987654321}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response. 


###### Step 25:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for expirationTime := 987654321987654321}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 26:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for startTime := current UTC timestamp + 1 hour, expirationTime := current UTC timestamp}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response. 


###### Step 27:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for startTime := current UTC timestamp + 2 hours, expirationTime := current UTC timestamp + 25 hours}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 28:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for extraData := string of 3000 'a' characters}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response. 


###### Step 29:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for extraData := string of 1500 'ɐ' characters (UTF8 code 0xc990), which consume 2 bytes per character}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response. 


###### Step 30:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.activity matches $activityInfo3, signedActivity.signature := []}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response. 


###### Step 31:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.activity matches $activityInfo3, signedActivity.signature := [1]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response. 


###### Step 32:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.activity matches $activityInfo3, signedActivity.signature is a signature of signedActivity.activity with first byte XORed with 0x12}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 33:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.activity matches $activityInfo3, signedActivity.signature := array of 200 bytes 0x12}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response. 


###### Step 34:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for version := [1,0]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response. 


###### Step 35:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for version := [0,0,0]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 36:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for version := [1,0,0,0]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.



###### Step 37:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.



###### Step 38:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.



###### Step 39:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for id := 0}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 40:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for ownerPublicKey := [1]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 41:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for ownerPublicKey := array of 200 bytes 0x12}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 42:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for profileServerContact.networkId := [1]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 43:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for profileServerContact.networkId := array of 40 bytes 0x12}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 44:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for profileServerContact.ipAddress := [1]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 45:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for profileServerContact.ipAddress := array of 40 bytes 0x12}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 46:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for profileServerContact.primaryPort := 0}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 47:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for profileServerContact.primaryPort := 70000}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response. 


###### Step 48:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for type := string of 100 'a' characters}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response. 


###### Step 49:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for type := string of 50 'ɐ' characters (UTF8 code 0xc990), which consume 2 bytes per character}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 50:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for type := "new"}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 51:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for latitude := 987654321}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response. 


###### Step 52:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for latitude := -987654321}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 53:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for longitude := 987654321}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 54:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for longitude := -987654321}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 55:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for precision := 10000}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 56:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for startTime := 987654321987654321}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 57:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for expirationTime := 987654321987654321}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 58:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for startTime := current UTC timestamp + 1 hour, expirationTime := current UTC timestamp}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 59:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for startTime := current UTC timestamp + 2 hours, expirationTime := current UTC timestamp + 25 hours}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 60:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for extraData := string of 3000 'a' characters}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 61:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for extraData := string of 1500 'ɐ' characters (UTF8 code 0xc990), which consume 2 bytes per character}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 62:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.activity matches $activityInfo3, signedActivity.signature := []}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 63:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.activity matches $activityInfo3, signedActivity.signature := [1]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 64:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.activity matches $activityInfo3, signedActivity.signature is a signature of signedActivity.activity with first byte XORed with 0x12}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 65:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.activity matches $activityInfo3, signedActivity.signature := array of 200 bytes 0x12}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 66:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = delete, delete {id := 0, ownerPublicKey := $activityInfo3.ownerPublicKey}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 67:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = delete, delete {id := $activityInfo3.id, ownerNetworkId := SHA256($activityInfo3.ownerPublicKey)}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 68:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = delete, delete {id := $activityInfo2.id, ownerNetworkId := SHA256($activityInfo2.ownerPublicKey)}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 69:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = delete, delete {id := $activityInfo2.id, ownerNetworkId := []}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 70:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = delete, delete {id := $activityInfo2.id, ownerNetworkId := [1,2,3]}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 71:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = delete, delete {id := $activityInfo2.id, ownerNetworkId set to array of 40 bytes 0x12}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 72:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo3, except for type := ""}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response.


###### Step 73:

The test sends *NeighborhoodSharedActivityUpdateRequest*:

 * `NeighborhoodSharedActivityUpdateRequest.items := 
   [
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo2, except for extraData := "a=b" }},
      {ActionType = change, change {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo7, except for type := ""}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo4}},
      {ActionType = add, add {signedActivity.signature is a valid signature of signedActivity.activity, which matches $activityInfo5}},
   ]`

and reads the response. 



##### Acceptance Criteria

###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
The test successfully starts simulated proximity server and simulated LOC server. 
The target proximity server successfully connects to the simulated LOC server and initializes the LOC session.


###### Step 2:

Simulated LOC server successfully sends notification message to the proximity server.

The target proximity server sends *StartNeighborhoodInitializationRequest*.

The target proximity server sends the corresponding *NeighborhoodSharedActivityUpdateResponse*:

  * `Response.status == STATUS_OK`

The target proximity server sends *FinishNeighborhoodInitializationRequest*:

  * `Response.status == STATUS_OK`


###### Step 3:

The target proximity server sends *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.version"`


###### Step 4:

The target proximity server sends *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.version"`


###### Step 5:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.version"`


###### Step 6:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.id"`


###### Step 7:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "2.add.signedActivity.activity.id"`


###### Step 8:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.id"`


###### Step 9:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.signature"`


###### Step 10:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.ownerPublicKey"`


###### Step 11:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.profileServerContact.networkId"`


###### Step 12:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.profileServerContact.networkId"`


###### Step 13:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.profileServerContact.ipAddress"`


###### Step 14:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.profileServerContact.ipAddress"`


###### Step 15:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.profileServerContact.primaryPort"`


###### Step 16:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.profileServerContact.primaryPort"`


###### Step 17:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.type"`


###### Step 18:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.type"`


###### Step 19:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.latitude"`


###### Step 20:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.latitude"`


###### Step 21:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.longitude"`


###### Step 22:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.longitude"`


###### Step 23:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.precision"`


###### Step 24:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.startTime" OR Response.details == "1.add.signedActivity.activity.expirationTime"`


###### Step 25:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.expirationTime"`


###### Step 26:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.expirationTime"`


###### Step 27:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.expirationTime"`

              
###### Step 28:

The target proximity server sends *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.extraData"`


###### Step 29:

The target proximity server sends *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.extraData"`


###### Step 30:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.signature"`


###### Step 31:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.signature"`


###### Step 32:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.signature"`


###### Step 33:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.signature"`


###### Step 34:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.version"`


###### Step 35:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.version"`


###### Step 36:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.version"`


###### Step 37:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.id"`


###### Step 38:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.id"`


###### Step 39:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.id"`


###### Step 40:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.signature"`


###### Step 41:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.ownerPublicKey"`


###### Step 42:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.profileServerContact.networkId"`


###### Step 43:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.profileServerContact.networkId"`


###### Step 44:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.profileServerContact.ipAddress"`


###### Step 45:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.profileServerContact.ipAddress"`


###### Step 46:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.profileServerContact.primaryPort"`


###### Step 47:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.profileServerContact.primaryPort"`


###### Step 48:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.type"`


###### Step 49:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.type"`


###### Step 50:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.type"`


###### Step 51:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.latitude"`


###### Step 52:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.latitude"`


###### Step 53:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.longitude"`


###### Step 54:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.longitude"`


###### Step 55:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.precision"`


###### Step 56:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.startTime" OR Response.details == "1.change.signedActivity.activity.expirationTime"`


###### Step 57:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.expirationTime"`


###### Step 58:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.expirationTime"`


###### Step 59:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.expirationTime"`


###### Step 60:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.extraData"`


###### Step 61:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.extraData"`


###### Step 62:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.signature"`


###### Step 63:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.signature"`


###### Step 64:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.signature"`


###### Step 65:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.signature"`


###### Step 66:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.delete.id"`


###### Step 67:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.delete.id"`


###### Step 68:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.delete.id"`


###### Step 69:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.delete.ownerNetworkId"`


###### Step 70:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.delete.ownerNetworkId"`


###### Step 71:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.delete.ownerNetworkId"`


###### Step 72:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.add.signedActivity.activity.type"`


###### Step 73:

The target proximity server sends the corresponding *Response*:

  * `Response.status == ERROR_INVALID_VALUE`
  * `Response.details == "1.change.signedActivity.activity.type"`










#### PX05025 - Neighborhood Initialization Process - Fails and Updates Before Retring

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "prox.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server
  * Base port for simulated proximity server


##### Description 

The test simulates a proximity server instance and establishes a neighborhood relationship with the target proximity server 
by invoking the neighborhood initialization process. Before it completes the process, it creates new identities. 
The initialization process then fails to complete and the test tries it again. Then the test creates more identities. 
The test's simulated proximity server must receive all profiles from the target server.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test creates a primary identity which it uses to simulate another proximity server and then 
it creates 10 test identities, establishes hosting agreements with the proximity server for them, 
and initializes their profiles.

The test then creates a server, on which it simulates part of the proximity server behavior.
The simulated proximity server uses the base port ($BasePort) as its primary port and $BasePort+1 as its neighbor port.


###### Step 2:

The test then connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.neighborPort := $BasePort + 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. 


###### Step 3:

The test creates 5 more identities, establishes hosting agreements with the proximity server for them 
and initializes their profiles. 


###### Step 4:

The test waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives *FinishNeighborhoodInitializationRequest*.

###### Step 5:

The test creates 5 more identities, establishes hosting agreements with the proximity server for them 
and initializes their profiles. 


###### Step 6:

The test disconnects and waits 20 seconds.


###### Step 7:

The test creates 5 more identities, establishes hosting agreements with the proximity server for them 
and initializes their profiles. 

Test waits 20 seconds and checks that no updates have been received on its simulated proximity server.


###### Step 8:

The test then connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.neighborPort := $BasePort + 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. 

The test waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives *FinishNeighborhoodInitializationResponse*, to which the test replies with corresponding 
*FinishNeighborhoodInitializationResponse* message.


###### Step 9:

The test creates 5 more identities, establishes hosting agreements with the proximity server for them 
and initializes their profiles. 

Then it waits 20 seconds.


###### Step 10:

The test waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages.



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
Then the test successfully establishes hosting agreements for its test identities.
Then the test successfully initializes all test profiles. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`


###### Step 3:

The test successfully establishes hosting agreements for the new test identities.
Then the test successfully initializes all new profiles. 


###### Step 4:

The server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about hosted profiles.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 5:

The test successfully establishes hosting agreements for the new test identities.
Then the test successfully initializes all new profiles. 


###### Step 6:

Nothing to check.


###### Step 7:

The test successfully establishes hosting agreements for the new test identities.
Then the test successfully initializes all new profiles. 


###### Step 8:

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

The server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about hosted profiles.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 9:

The test successfully establishes hosting agreements for the new test identities.
Then the test successfully initializes all new profiles. 


###### Step 10:

The simulated proximity server received neighborhood updates in form of *NeighborhoodSharedActivityUpdateRequest* 
and together with the initialization process it received information about all the test identities.









#### PX05026 - Neighborhood Initialization Process - Already Exists 2

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "prox.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server
  * Base port for simulated proximity server


##### Description 

The test simulates a proximity server instance and establishes a neighborhood relationship with the target proximity server 
by invoking the neighborhood initialization process. Before it completes the process, it creates new identities 
and creates a second connection to the target proximity server and invokes a second neighborhood initialization process. 

The initialization process then fails to complete and the test tries it again. Then the test creates more identities. 
The test's simulated proximity server must receive all profiles from the target server.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test creates a primary identity which it uses to simulate another proximity server and then 
it creates 10 test identities, establishes hosting agreements with the proximity server for them, 
and initializes their profiles.

The test then creates a server, on which it simulates part of the proximity server behavior.
The simulated proximity server uses the base port ($BasePort) as its primary port and $BasePort+1 as its neighbor port.


###### Step 2:

The test then connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.neighborPort := $BasePort + 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. 

The test waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives *FinishNeighborhoodInitializationRequest*.


###### Step 3:

The test creates 5 more identities, establishes hosting agreements with the proximity server for them 
and initializes their profiles. 


###### Step 4:

With its second client but the same identity, the test connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.neighborPort := $BasePort + 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response and closes the connection.


###### Step 5:

Using the first client the test sends *FinishNeighborhoodInitializationResponse* message.

The test disconnects and waits 20 seconds.


###### Step 6:

Using the first client the test waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages.

The test checks the identities received by its first client.



##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
Then the test successfully establishes hosting agreements for its test identities.
Then the test successfully initializes all test profiles. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

The server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about hosted profiles.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 3:

The test successfully establishes hosting agreements for the new test identities.
Then the test successfully initializes all new profiles. 


###### Step 4:

Then the test successfully verifies its identity.

The target proximity server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

The target proximity server replies with *Response*:
  
  * `Message.id == 4`
  * `Response.status == ERROR_ALREADY_EXISTS`


###### Step 5:

Nothing to check.


###### Step 6:

The target proximity server sends *NeighborhoodSharedActivityUpdateRequest* with updates containing information about the newly created profiles.

The simulated proximity server received neighborhood updates in form of *NeighborhoodSharedActivityUpdateRequest* 
and together with the initialization process it received information about all the test identities.








#### PX05027 - Neighborhood Updates 2

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.
  * "prox.pfx" file exists and contains a self-signed TLS certificate, not protected by password

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server
  * Base port for simulated proximity server


##### Description 

The test simulates a proximity server instance and establishes a neighborhood relationship with the target proximity server 
by invoking the neighborhood initialization process. The test sets up new identities on the target server in order to 
receive neighborhood updates from it and it updates and deletes on of the identities quickly. At the same time it 
artifically slows down the processing of messages of the simulated proximity server in order to hit into a race condition 
of neighborhood updates. Then the test verifies that the server processed the updates correctly.


###### Step 1:

The test obtains a list of service ports from the proximity server's primary port.

The test creates a primary identity which it uses to simulate another proximity server and then 
it creates 5 test identities, establishes hosting agreements with the proximity server for them, 
and initializes their profiles.

The test then creates a server, on which it simulates part of the proximity server behavior.
The simulated proximity server uses the base port ($BasePort) as its primary port and $BasePort+1 as its neighbor port.
It is also set to wait 500 milliseconds before it processes every network message it receives.


###### Step 2:

The test connects to proximity server's neighbor port and verifies its identity. 

The test sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 3`
  * `StartNeighborhoodInitializationRequest.primaryPort := $BasePort`
  * `StartNeighborhoodInitializationRequest.neighborPort := $BasePort + 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it waits for a series of *NeighborhoodSharedActivityUpdateRequest* messages, 
to which it replies with corresponding *NeighborhoodSharedActivityUpdateResponse* messages, up until 
the test receives information about all the test identities.

Then it waits for *FinishNeighborhoodInitializationRequest* message and replies with corresponding 
*FinishNeighborhoodInitializationResponse* message.


###### Step 3:

The test creates 10 more identities, establishes hosting agreements with the proximity server for them 
and initializes their profiles. Then it selects one of the 15 identities it created and changes its profile name.
Subsequently it cancels the hosting agreement of this identity. 
Then it waits 20 seconds.




##### Acceptance Criteria



###### Step 1:

The test successfully obtains list of ports on which the proximity server provides its services. 
Then the test successfully establishes hosting agreements for its test identities.
Then the test successfully initializes all test profiles. 


###### Step 2:

Then the test successfully verifies its identity.

Server replies with *StartNeighborhoodInitializationResponse*:
  
  * `Message.id == 3`
  * `Response.status == STATUS_OK`

Server sends a series of *NeighborhoodSharedActivityUpdateRequest* messages with information about all test identities.

Server sends *FinishNeighborhoodInitializationRequest*.


###### Step 3:

The test successfully establishes hosting agreements for the new test identities.
The test successfully initializes all new profiles. 

The simulated proximity server receives neighborhood updates in form of *NeighborhoodSharedActivityUpdateRequest* 
for all the newly hosted profiles on the target proximity server.

The test successfully changes the name of the profile of the selected identity and then it successfully 
cancels its hosting agreement on the target proximity server.

The simulated proximity server receives a consistent set of updates so that the databases of both servers are in sync.





