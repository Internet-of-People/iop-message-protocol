### PX01xxx - Primary Port Functionality Tests

#### PX01001 - Primary Port Ping

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server

##### Description 

The test sends a ping request to the proximity server and expects to receive a ping response.


###### Step 1:

The test simulates a location based network server.

The test connects to the primary port of the proximity server and sends *PingRequest*:

  * `Message.id := 1234`
  * `SingleRequest.version := [1,0,0]`
  * `PingRequest.payload := "Hello"`

and reads the response.

##### Acceptance Criteria

###### Step 1:

Server replies with *PingResponse*:
  
  * `Message.id == 1234`
  * `Response.status == STATUS_OK`
  * `PingResponse.payload == "Hello"`
  * `PingResponse.clock` does not differ more than 10 minutes from the test's machine clock.




#### PX01002 - Primary Port Ping - Invalid Version Format

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server

##### Description 

The test sends a ping request with invalid protocol version. The version must be 3 bytes long, but the client sends 2 bytes only.


###### Step 1:

The test simulates a location based network server.

The test connects to the primary port of the proximity server and sends *PingRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0]`
  * `PingRequest.payload := "Hello"`

and reads the response. Then it sends *PingRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `PingRequest.payload := "Hello"`

and reads the response.



##### Acceptance Criteria

###### Step 1:

Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_PROTOCOL_VIOLATION`

and then the proximity server closes the connection, so that sending the second *PingRequest* or receiving a response to it fails.










#### PX01003 - Primary Port Ping - Invalid Version Value

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server

##### Description 

The test sends a ping request with invalid protocol version 0.0.0.


###### Step 1:

The test simulates a location based network server.

The test connects to the primary port of the proximity server and sends *PingRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [0,0,0]`
  * `PingRequest.payload := "Hello"`

and reads the response. Then it sends *PingRequest*:

  * `Message.id := 2`
  * `SingleRequest.version := [1,0,0]`
  * `PingRequest.payload := "Hello"`

and reads the response.



##### Acceptance Criteria

###### Step 1:
Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_PROTOCOL_VIOLATION`

and then the proximity server closes the connection, so that sending the second *PingRequest* or receiving a response to it fails.








#### PX01004 - List Roles

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server

##### Description 

The test requests list of proximity server's roles.


###### Step 1:

The test simulates a location based network server.

The test connects to the primary port of the proximity server and sends *ListRolesRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`

and reads the response.

##### Acceptance Criteria

###### Step 1:

Server replies with *ListRolesResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * *ListRolesResponse.roles* contains 3 items, one for each role with following properties:
    * *PRIMARY* - `isTcp == true`, `isTls == false`
    * *NEIGHBOR* - `isTcp == true`, `isTls == true`
    * *CLIENT* - `isTcp == true`, `isTls == true`
  * Intersection of the set of port numbers of *primary* role and the set of port numbers of *neighbor* and *client* roles must be empty (i.e. no port is used for both TLS and non-TLS service).





#### PX01005 - Verify Identity - Bad Role

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server

##### Description 

The test sends verify identity request to the primary port, but *VerifyIdentityRequest* requires client or neighbor port to be used.


###### Step 1:

The test simulates a location based network server.

The test connects to the primary port of the proximity server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
 
and reads the response from the proximity server in form of *StartConversationResponse*:

  * `$Challenge := StartConversationResponse.challenge`

Then it sends *VerifyIdentityRequest*:

  * `Message.id := 2`
  * `VerifyIdentityRequest.challenge := $Challenge`
  * `ConversationRequest.signature` is set to a signature of `VerifyIdentityRequest` part of the message using the test's identity private key
  
and reads the response.


##### Acceptance Criteria

###### Step 1:

Server replies with *StartConversationResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *Response*:
  
  * `Message.id == 2`
  * `Response.status == ERROR_BAD_ROLE`




#### PX01006 - Get Activity Information - Bad Role

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server

##### Description 

The test sends *GetActivityInformationRequest* to the primary port, but it requires client port to be used.


###### Step 1:

The test simulates a location based network server.

The test connects to the primary port of the proximity server and sends *GetActivityInformationRequest*:

  * `Message.id := 1`
  * `SingleRequest.version := [1,0,0]`
  * `GetActivityInformationRequest.id := 1` 
  * `GetActivityInformationRequest.ownerNetworkId := SHA256("test")`
 
and reads the response.


##### Acceptance Criteria

###### Step 1:

Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_BAD_ROLE`




#### PX01007 - Activity Search - Bad Role

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server

##### Description 

The test sends *ActivitySearchRequest* to the primary port, but it requires client port to be used.


###### Step 1:

The test simulates a location based network server.

The test connects to the primary port of the proximity server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
 
and reads the response. Then it sends *ActivitySearchRequest*:

  * `Message.id := 2`
  * `ActivitySearchRequest.includePrimaryOnly := false`
  * `ActivitySearchRequest.maxResponseRecordCount := 100`
  * `ActivitySearchRequest.maxTotalRecordCount := 1000`
  * `ActivitySearchRequest.ownerNetworkId := []`
  * `ActivitySearchRequest.type := ""`
  * `ActivitySearchRequest.startNotAfter := 0`
  * `ActivitySearchRequest.expirationNotBefore := 0`
  * `ActivitySearchRequest.latitude := NO_LOCATION`
  * `ActivitySearchRequest.longitude := NO_LOCATION`
  * `ActivitySearchRequest.longitude := NO_LOCATION`
  * `ActivitySearchRequest.radius := 0`
  * `ActivitySearchRequest.extraData := ""`
 
and reads the response.


##### Acceptance Criteria

###### Step 1:

Server replies with *StartConversationResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *Response*:
  
  * `Message.id == 2`
  * `Response.status == ERROR_BAD_ROLE`




#### PX01008 - Activity Search Part - Bad Role

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server

##### Description 

The test sends *ActivitySearchPartRequest* to the primary port, but it requires client port to be used.


###### Step 1:

The test simulates a location based network server.

The test connects to the primary port of the proximity server and sends *StartConversationRequest*:

  * `Message.id := 1`
  * `StartConversationRequest.supportedVersions := [[1,0,0]]`
  * `StartConversationRequest.publicKey` set to the test identity public key
  * `StartConversationRequest.clientChallenge` set to 32 byte random challenge; `$ClientChallenge := StartConversationRequest.clientChallenge`
 
and reads the response. Then it sends *ActivitySearchPartRequest*:

  * `Message.id := 2`
  * `ActivitySearchPartRequest.recordIndex := 0`
  * `ActivitySearchPartRequest.recordCount := 10`
 
and reads the response.


##### Acceptance Criteria

###### Step 1:

Server replies with *StartConversationResponse*:
  
  * `Message.id == 1`
  * `Response.status == STATUS_OK`
  * `ConversationResponse.signature` is a valid signature of $ClientChallenge
  * `StartConversationResponse.clientChallenge == $ClientChallenge`

Server replies with *Response*:
  
  * `Message.id == 2`
  * `Response.status == ERROR_BAD_ROLE`





#### PX01009 - Neighborhood Related Calls - Bad Role

##### Prerequisites/Inputs

###### Prerequisites:
  * Server's database is empty.

###### Inputs:
  * Server's IP address
  * Server's primary port
  * Port for simulated Location Based Network server

##### Description 

The test sends *StartNeighborhoodInitializationRequest*, *FinishNeighborhoodInitializationRequest*, *NeighborhoodSharedActivityUpdateRequest*,
*StopNeighborhoodUpdatesRequest* to the primary port, but these requests require neighbor port to be used.


###### Step 1:

The test simulates a location based network server.

The test connects to the primary port of the proximity  server and sends *StartNeighborhoodInitializationRequest*:

  * `Message.id := 1`
  * `StartNeighborhoodInitializationRequest.primaryPort := 1`
  * `StartNeighborhoodInitializationRequest.neighborPort := 1`
  * `StartNeighborhoodInitializationRequest.ipAddress` set to server's IP address
 
and reads the response. Then it sends *FinishNeighborhoodInitializationRequest*:

  * `Message.id := 2`

and reads the response. Then it sends *NeighborhoodSharedActivityUpdateRequest*:

  * `Message.id := 3`
  * `NeighborhoodSharedActivityUpdateRequest.items = []`

and reads the response. Then it sends *StopNeighborhoodUpdatesRequest*:

  * `Message.id := 4`

and reads the response.


##### Acceptance Criteria

###### Step 1:

Server replies with *Response*:
  
  * `Message.id == 1`
  * `Response.status == ERROR_BAD_ROLE`

Server replies with *Response*:
  
  * `Message.id == 2`
  * `Response.status == ERROR_BAD_ROLE`

Server replies with *Response*:
  
  * `Message.id == 3`
  * `Response.status == ERROR_BAD_ROLE`

Server replies with *Response*:
  
  * `Message.id == 4`
  * `Response.status == ERROR_BAD_ROLE`
