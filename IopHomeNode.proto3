//
// Definition of IoP Home Node protocol.
// We strictly use only features that are binary compatible in ProtoBuf v2 and v3.
// We use no v2 or v3 specific features.
//
// An integral part of the protocol are the protocol tests:
// https://github.com/Internet-of-People/message-protocol/blob/master/TESTS.md
// The tests must comply with this protocol file, but may add some additional requirements
// or constraints on the behavior of a compatible software.
//
//
//
// * Roles *
// ~~~~~~~~~
//
// Each node has several roles. Each message belongs to one or more roles.
// If a request is sent to a port that does not handle the specific role, 
// ERROR_BAD_ROLE is returned.
//
// Existing roles and their short names are:
//
//   * Primary and Unrelated Nodes Interface = "primary"
//   * Neighbors Interface = "ndNeighbor"
//   * Colleagues Interface = "ndColleague"
//   * Customer Clients Interface = "clCustomer"
//   * Non Customer Clients Interface = "clNonCustomer"
//   * Application Service Interface = "clAppService"
//
//
// We mark each request with a list of roles that can serve that request.
// If all roles can serve the request, we use "any" marker.
//
//
//
//
// * Reused Types *
// ~~~~~~~~~~~~~~~~
//
// Protobuf does not allow us to specify some types completely, this is why we 
// define some of the types we reuse a lot here.
//
//  * VersionType - Protocol or structure version specification encoded in 3 bytes - see http://semver.org/. 
//                  First byte is MAJOR, second byte is MINOR, third byte is PATCH. Note that version 0.0.0 
//                  is always considered invalid and should produce protocol violation error.
//
//  * TimestampType - 64-bit signed timestamp that is similar to Unix timestamp, except that it counts 
//                    milliseconds since the epoch start instead of seconds and is 64-bit instead of 32-bit.
//
//  * TokenAmountType - IoP token amounts are represented by 64-bit unsigned integers similarly how bitcoins
//                      are represented in the Bitcoin protocol. Each IoP token is divisible to 100,000,000 
//                      smallest units and all amounts in the protocol are in these smallest units. Thus 
//                      a numberical value of 100,000,000 within a TokenAmountType field represents 1 full 
//                      IoP token.
//
//  * WildcardType - UTF-8 string with optional '*' wildcard character prefix or suffix, which represents any substring.
//                   Matching is case insensitive. The format of this string is thus one of the following formats:
//
//                    * "data*" - starts with "data"
//                    * "*data" - ends with "data"
//                    * "*data*" - contains "data"
//                    * "data" - is exactly "data"
//
//                   Any additional '*' characters are interpreted as parts of the value.
//
//  * RegexType - Case-sensitive UTF-8 regular expression string supporting following rules:
//
//                 * "\xnn" - Matches a single byte character by using hexadecimal representation (nn consists 
//                            of exactly two digits).
//                 * "\unnnn" - Matches a Unicode character by using hexadecimal representation (exactly four digits, 
//                              as represented by nnnn).
//                 * "\.", "\*", "\-", "\+", "\[", "\]", "\\", "\?", "\^", "\|", "\(", "\)", "\{", "\}" - Escapes special character.
//                 * "[characterGroup]" - Matches any single character in characterGroup.
//                 * "[^characterGroup]" - Matches any single character that is not in characterGroup.
//                 * "[first-last]" - Matches any single character in the range from first to last. 
//                 * "." - Matches any single character.
//                 * "\w" - Matches any word character.
//                 * "\W" - Matches any non-word character.
//                 * "\s" - Matches any white-space character.
//                 * "\S" - Matches any non-white-space character.
//                 * "\d" - Matches any decimal digit.
//                 * "\D" - Matches any character other than a decimal digit.
//                 * "^" - The match must start at the beginning of the string. 
//                 * "$" - The match must occur at the end of the string.
//                 * "*" - Matches the previous element zero or more times.
//                 * "+" - Matches the previous element one or more times.
//                 * "?" - Matches the previous element zero or one time.
//                 * "{n}" - Matches the previous element exactly n times.
//                 * "{n,}" - Matches the previous element at least n times.
//                 * "{n,m}" - Matches the previous element at least n times, but no more than m times. 
//                 * "|" - Matches any one element separated by the vertical bar '|' character.
//                 * "(subexpression)" - Captures the matched subexpression.
//
//               No other rules or special characters are allowed to appear in the regular expression of this type.
//
// * LocationType - Represents GPS location latitude or longitude. It is a signed integer that stores decimal(9,6)
//                  type, which means that a floating point value of the latitude or longitude is multiplied
//                  by 1,000,000 and converted to the integer (cutting of any digits right of the decimal point without 
//                  rounding). To get the floating point value back, simply divide the integer value by 1,000,000.
//                  For latitudes, valid values are in range [-90,000,000;90,000,000], for longitudes the range is 
//                  [-179,999,999;180,000,000]. A special constant NO_LOCATION = (int)0xFFFFFFFF is reserved for no location.
//
//
//
// * Conversations *
// ~~~~~~~~~~~~~~~~~
//
// Each message in the protocol can either be a separated message called "Single Message" or it can be a part 
// of a longer conversation. Response to a Single Message is a "Single Response". These request and response 
// exist without any context. All the information needed to process the request has to be included in the message.
//
// Conversations are different. They establish a context and conversation messages can thus rely on the 
// information provided earlier in the conversation. These are the possible conversation statuses:
//
//   * NoConversation - No conversation has been started.
//
//   * ConversationStarted - There is an established conversation with the client, but no authentication 
//                           has been done.
//
//   * Verified - There is an established conversation with the non-customer client and the verification process 
//                has already been completed. Note that, unlike Authenticated status, there can be multiple 
//                parallel connections in this status for a single identity.
//
//   * Authenticated - There is an established conversation with the customer client and the authentication process 
//                     has already been completed. Note that only one connection per identity can be in this
//                     status. If the identity establishes a second connection and performs a check-in process 
//                     the first connection has to be disconnected.
//
//
// For each conversation messages we define in which state must the conversation be. If the conversation 
// message is sent in a different state, it is an error. Note that if the required status is Verified
// and the current status is Authenticated, the requirement is satisfied.
//
//   * ERROR_BAD_CONVERSATION_STATUS - If the required state is NoConversation or ConversationStarted, 
//                                     but the current state is different.
//
//   * ERROR_UNAUTHORIZED - If the required status is Authenticated, but the current status is different; 
//                          OR the required status is Verified and the current status is neither Verified 
//                          nor Authenticated.
// 
//


syntax = "proto3";


package iop.homenode;

// Return codes to requests that inform requestor about whether the operation completed successfully or which error occurred.
enum Status {
  // General codes that can be returned to any message.
  STATUS_OK = 0;                                   // The operation completed successfully.

  ERROR_PROTOCOL_VIOLATION = 1;                    // The incoming request does not follow the protocol.
  ERROR_UNSUPPORTED = 2;                           // The peer does not support the request. This is returned when a peer sends a message with an unsupported protocol version.
  ERROR_BANNED = 3;                                // The peer will not process the request bacause the requestor is on the blacklist. Information about the blacklist entry expiration is provided in 'Response.timestamp'.
  ERROR_BUSY = 4;                                  // The peer will not process the request because it is too busy. The requestor can try later.

  ERROR_UNAUTHORIZED = 5;                          // Within conversation, some server roles require authorization of the peer before certain requests are allowed.
                                                   // For example, the clCustomer role requires clients to authorize themselves before certain requests can be sent.
                                                   // This means that such requests require authorization and this error code is returned if a peer sends a request without prior authorization.

  ERROR_BAD_ROLE = 6;                              // If a request is sent to a port that does not handle the specific role, this error is returned.
  ERROR_BAD_CONVERSATION_STATUS = 7;               // The conversation status is different from what the message requires.
  ERROR_INTERNAL = 8;                              // Internal error occurred while processing the message.


  // Return codes specific to a request.
  ERROR_QUOTA_EXCEEDED = 51;                       // The peer reached or exceeded prescribed limits.
  ERROR_INVALID_SIGNATURE = 52;                    // The signature provided be the peer does not correspond to the peer's key or the message being signed.
  ERROR_NOT_FOUND = 53;                            // A referenced object was not found.
  ERROR_INVALID_VALUE = 54;                        // One of the values provided is invalid.
  ERROR_ALREADY_EXISTS = 55;                       // An object with the same identifier already exists.
  ERROR_NOT_AVAILABLE = 56;                        // A request object is not available.
  ERROR_REJECTED = 57;                             // A third party rejected the requested action.
  ERROR_UNINITIALIZED = 58;                        // The requested object can not be obtained, queried or used as it is not initialized.
}


// This is complete message as it goes over the wire. It includes the 32-bit header with message length.
//
// There is a 1 byte prefix because of Google Protobuf protocol, so the actual binary data for a message
// with body size 4660 bytes would be:
//
//
//   0D 34 12 00 00
//
// where 0x0D means type 'fixed32' (which value is 5) + index of 'header', which is 1 << 3,
// this is followed be the 4 byte sequence 34 12 00 00, which is little endian of 0x00001234, which is 4660 decimal.
// Thus the total number of bytes sent over the wire for this message would be 4665 bytes.
//
message MessageWithHeader {
  fixed32 header = 1;                              // Message length (without the size of the header) as a little-endian 32-bit unsigned integer.
  Message body = 2;                                // Message itself.
}



// Format of a single message.
message Message {
  uint32 id = 1;                                   // Requestor defined message ID that the requestee has to return in the response. 
                                                   // Requestor is responsible for using different ID for every unprocessed message.
                                                   // If at any point there exist two open requests (i.e. without a response) with the same ID, it is a violation of the protocol and the behavior is undefined.

  oneof MessageType {                              // Message can be either:
    Request request = 2;                           //  * a new request,
    Response response = 3;                         //  * or response to a previous request.
  }
}


// Every conversation starts with a request of a requestor.
// This can be either a single request, for which it is expected to receive a single response,
// or this can be part of a longer conversation between the peers.
message Request {
  oneof ConversationType {                         // Either a request lives on its own without any session or context, or it is a part of a conversation.
    SingleRequest singleRequest = 1;               // Single requests are requests that are supposed to be sent without further context.
    ConversationRequest conversationRequest = 2;   // Conversation requests form a session with a context that has to be maintained by peers in order to correctly interpret the messages.
  }  
}


// To every request there is a response.
message Response {
  Status status = 1;                               // Return code.
  sint64 timestamp = 2;                            // TimestampType. If status is ERROR_BANNED, this field specifies when the blacklist entry expires.
  string details = 3;                              // In case of an error, this field may contain additional details.

  oneof ConversationType {                         // See 'Request.ConversationType'.
    SingleResponse singleResponse = 8;             // Responses to single requests are sent as single responses,
    ConversationResponse conversationResponse = 9; // responses to conversation requests are sent as conversation responses.
  }
}


// Single requests live on their own without any session or context. 
// It is always possible to process a single request without any additional informaiton.
message SingleRequest {
  bytes version = 1;                               // VersionType. Protocol version specification.
  oneof RequestType {                              // There are many different standalone requests that can be sent by the requestor.
    PingRequest ping = 2;
    ListRolesRequest listRoles = 3;
    ListHomeNodePlansRequest listHomeNodePlans = 4;
    GetIdentityInformationRequest getIdentityInformation = 5;
    ApplicationServiceSendMessageRequest applicationServiceSendMessage = 6;
    ApplicationServiceReceiveMessageNotificationRequest applicationServiceReceiveMessageNotification = 7;
    ProfileStatsRequest profileStats = 8;
    GetIdentityRelationshipsInformationRequest getIdentityRelationshipsInformation = 9;
  }
}



// Single response is a reaction to single request. 
message SingleResponse {
  bytes version = 1;                               // VersionType. See 'SingleRequest.version'. The version of response can be different than the version in request, 
                                                   // if the requestee does not support the version by the requestor.
                                                   // If the requestor is able to process the message using the version of protocol, the version value is the same as in the request.

  oneof ResponseType {                             // See 'SingleRequest.RequestType'. Each request has its corresponding response.
    PingResponse ping = 2;
    ListRolesResponse listRoles = 3;
    ListHomeNodePlansResponse listHomeNodePlans = 4;
    GetIdentityInformationResponse getIdentityInformation = 5;
    ApplicationServiceSendMessageResponse applicationServiceSendMessage = 6;
    ApplicationServiceReceiveMessageNotificationResponse applicationServiceReceiveMessageNotification = 7;
    ProfileStatsResponse profileStats = 8;
    GetIdentityRelationshipsInformationResponse getIdentityRelationshipsInformation = 9;
  }
}



// Conversation requests live in a session with a context that is important for the interpretation of the requests.
// Unlike single requests, the order of messages is very important as each message may change the session context.
message ConversationRequest {
  bytes signature = 1;                             // Optional (request specific) signature that signs the Protobuf binary form of the included request body or its part.

  oneof RequestType {                              // There are many different requests that can be sent in the conversation.
    // Request body.
    StartConversationRequest start = 2;
    HomeNodeRequestRequest homeNodeRequest = 3;
    CheckInRequest checkIn = 4;
    VerifyIdentityRequest verifyIdentity = 5;
    UpdateProfileRequest updateProfile = 6;
    CancelHomeNodeAgreementRequest cancelHomeNodeAgreement = 7;
    ApplicationServiceAddRequest applicationServiceAdd = 8;
    ApplicationServiceRemoveRequest applicationServiceRemove = 9;
    CallIdentityApplicationServiceRequest callIdentityApplicationService = 10;
    IncomingCallNotificationRequest incomingCallNotification = 11;
    ProfileSearchRequest profileSearch = 12;
    ProfileSearchPartRequest profileSearchPart = 13;
    AddRelatedIdentityRequest addRelatedIdentity = 14;
    RemoveRelatedIdentityRequest removeRelatedIdentity = 15;
  }
}


// Conversation response is a reaction to a conversation request.
message ConversationResponse {
  bytes signature = 1;                             // Optional (response specific) signature that signs the Protobuf binary form of the included response body or its part.

  oneof ResponseType {                             // There are many different requests that can be sent in the conversation.
    // Response body.
    StartConversationResponse start = 2;
    HomeNodeRequestResponse homeNodeRequest = 3;
    CheckInResponse checkIn = 4;
    VerifyIdentityResponse verifyIdentity = 5;
    UpdateProfileResponse updateProfile = 6;
    CancelHomeNodeAgreementResponse cancelHomeNodeAgreement = 7;
    ApplicationServiceAddResponse applicationServiceAdd = 8;
    ApplicationServiceRemoveResponse applicationServiceRemove = 9;
    CallIdentityApplicationServiceResponse callIdentityApplicationService = 10;
    IncomingCallNotificationResponse incomingCallNotification = 11;
    ProfileSearchResponse profileSearch = 12;
    ProfileSearchPartResponse profileSearchPart = 13;
    AddRelatedIdentityResponse addRelatedIdentity = 14;
    RemoveRelatedIdentityResponse removeRelatedIdentity = 15;
  }
}





//
// An administrative message to test whether the peer is there and responds to requests.
//
// Each identity client is required to send a message not more than 60 seconds after the connection 
// was established, or after the last message has been send over the connection. For node clients,
// this limit is 300 seconds. Clients should use PingRequest if they have nothing else to send
// and want to keep the connection open.
//
//
// Roles: any
//
message PingRequest {
  bytes payload = 1;                               // At most 64 bytes of arbitrary data that will be sent back by the peer.
}

// A response to PingRequest to reassure the connection works fine.
message PingResponse {
  bytes payload = 1;                               // See 'PingRequest.payload'.
  sint64 clock = 2;                                // 64-bit signed Unix UTC time on the requestee's machine.
}



//
// Request server to provide a mapping between ports and roles.
//
// Roles: primary
//
message ListRolesRequest {
}

// A response to ListRolesRequest with a list of all open ports and associated roles.
message ListRolesResponse {
  repeated ServerRole roles = 1;                   // List of server roles.
}


// Known server roles.
enum ServerRoleType {
  PRIMARY = 0;                                     // Primary and Unrelated Nodes Interface server role.
  ND_NEIGHBOR = 1;                                 // Neighbors Interface server role.
  ND_COLLEAGUE = 2;                                // Colleagues Interface server role.
  CL_NON_CUSTOMER = 3;                             // Customer Clients Interface server role.
  CL_CUSTOMER = 4;                                 // Non Customer Clients Interface server role.
  CL_APP_SERVICE = 5;                              // Application Service Interface server role.
}


// Description of a single server role.
message ServerRole {
  ServerRoleType role = 1;                         // Server role type.
  uint32 port = 2;                                 // On which port is this server role provided.
  bool isTcp = 3;                                  // true if the port is TCP port, false means UDP.
  bool isTls = 4;                                  // true if the port is TLS encrypted, false otherwise.
}









//
// Home Node Request and Check-in - Identity registration and first login full sequence
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// A) Provided that the node's clNonCustomer port is different from clCustomer port, the sequence is as follows:
//   1) Identity connects to the node on its primary port and gets information about its roles to ports mapping.
//   2) Identity connects to the clNonCustomer port and sends a home node request.
//   3) Identity connects to the clCustomer port and performs a check-in.
//
// B) If clNonCustomer port is equal to clCustomer port, the sequence is as follows:
//   1) Identity connects to the node on its primary port and gets information about its roles to ports mapping.
//   2) Identity connects to the clNonCustomer+clCustomer port and sends a home node request.
//   3) Identity performs a check-in over the connection from 2).
//
//
//
// Sequence diagram A.1) - this is called "Port Discovery Process":
//
// [ Identity ]                                                         [ Node:primary ] 
//      |                                                                     |
//      |                                                                     | status = NoConversation
//      |                                                                     |
//      |  ListRolesRequest                                                   |
//      *-------------------------------------------------------------------> *
//      |                                                                     |
//      |                                                                     |
//      |                                                                     |
//      |                                                  ListRolesResponse  |
//      * <-------------------------------------------------------------------*
//      |                                                                     |
//      |                                                                     |
//
//
// Now the identity knows the list of node's roles and on which ports they are served.
//
//
//
// Sequence diagram A.2):
//
// [ Identity ]                                                         [ Node:clNonCustomer ] 
//      |                                                                     |
//      |                                                                     | status = NoConversation
//      |                                                                     |
//      |  StartConversationRequest                                           |
//      *-------------------------------------------------------------------> *
//      |                                                                     |
//      |                                                                     | status := ConversationStarted
//      |                                                                     |
//      |                                          StartConversationResponse  |
//      * <-------------------------------------------------------------------*
//      |                                                                     |
//      |                                                                     |
//      |                                                                     |
//      |  HomeNodeRequestRequest                                             |
//      *-------------------------------------------------------------------> *
//      |                                                                     |
//      |                                                                     |
//      |                                                                     |
//      |                                            HomeNodeRequestResponse  |
//      * <-------------------------------------------------------------------*
//      |                                                                     |
//      |                                                                     |
//
// Now the identity is registered and the node is its home node, it can proceed with the check-in process.
//
//
//
// Sequence diagram A.3) - this is called "Check-in Process":
//
// [ Identity ]                                                         [ Node:clCustomer ] 
//      |                                                                     |
//      |                                                                     | status = NoConversation
//      |                                                                     |
//      |  StartConversationRequest                                           |
//      *-------------------------------------------------------------------> *
//      |  <clientChallenge>                                                  |
//      |                                                                     | status := ConversationStarted
//      |                                                                     |
//      |                                                                     |
//      |                                          StartConversationResponse  |
//      *<--------------------------------------------------------------------*
//      |                                <challenge, signed clientChallenge>  |
//      |                                                                     |
//      |                                                                     |
//      |  CheckInRequest                                                     |
//      *-------------------------------------------------------------------> *
//      |  <signed challenge>                                                 |
//      |                                                                     | status := Authenticated
//      |                                                                     |
//      |                                                    CheckInResponse  |
//      * <-------------------------------------------------------------------*
//      |                                                                     |
//      |                                                                     |
//
//
//
// Sequence diagram B.1) is same as A.1)
// Sequence diagram B.2) + B.3):
//
// [ Identity ]                                                         [ Node:clNonCustomer+clCustomer ] 
//      |                                                                     |
//      |                                                                     | status = NoConversation
//      |                                                                     |
//      |  StartConversationRequest                                           |
//      *-------------------------------------------------------------------> *
//      |  <clientChallenge>                                                  |
//      |                                                                     | status := ConversationStarted
//      |                                                                     |
//      |                                          StartConversationResponse  |
//      * <-------------------------------------------------------------------*
//      |                                <challenge, signed clientChallenge>  |
//      |                                                                     |
//      |                                                                     |
//      |  HomeNodeRequestRequest                                             |
//      *-------------------------------------------------------------------> *
//      |                                                                     |
//      |                                                                     |
//      |                                                                     |
//      |                                            HomeNodeRequestResponse  |
//      * <-------------------------------------------------------------------*
//      |                                                                     |
//      |                                                                     |
//      |                                                                     |
//      |  CheckInRequest                                                     |
//      *-------------------------------------------------------------------> *
//      |  <signed challenge>                                                 |
//      |                                                                     | status := Authenticated
//      |                                                                     |
//      |                                                    CheckInResponse  |
//      * <-------------------------------------------------------------------*
//      |                                                                     |
//      |                                                                     |
//
//
// 
//
// Identity Verification Process
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Similarly to how a node's customer checks-in in order to get to the Authenticated conversation 
// status, a remote identity (not hosted by the node) can verify its public key by signing
// a challenge provided by the node in order to get to the Verified conversation status.
//
//
// Sequence diagram for so called "Identity Verification Process":
//
// [ Identity ]                                                         [ Node:clNonCustomer ] 
//      |                                                                     |
//      |                                                                     | status = NoConversation
//      |                                                                     |
//      |  StartConversationRequest                                           |
//      *-------------------------------------------------------------------> *
//      |  <clientChallenge>                                                  |
//      |                                                                     | status := ConversationStarted
//      |                                                                     |
//      |                                                                     |
//      |                                          StartConversationResponse  |
//      * <-------------------------------------------------------------------*
//      |                                <challenge, signed clientChallenge>  |
//      |                                                                     |
//      |                                                                     |
//      |  VerifyIdentityRequest                                              |
//      *-------------------------------------------------------------------> *
//      |  <signed challenge>                                                 |
//      |                                                                     | status := Authenticated
//      |                                                                     |
//      |                                             VerifyIdentityResponse  |
//      * <-------------------------------------------------------------------*
//      |                                                                     |
//      |                                                                     |


//
// A client asks node for its home node plans that match the given criteria.
//
// Roles: clNonCustomer
//
message ListHomeNodePlansRequest {
  string identityType = 1;                         // A specific identity type, for which the client searches the plan.
  // Other criteria TBD.
}


//
// A response to ListHomeNodePlansRequest that contains a list of matching plans.
//
// Specific Error Responses: 
//   * ERROR_QUOTA_EXCEEDED - A node users this error code in case it wants to express that it will not accept any new clients because it has no free slots.
//
message ListHomeNodePlansResponse {
  repeated HomeNodePlan plans = 1;                 // List of matching plans.
}


// Description of a home node hosting plan.
message HomeNodePlan {
  bytes planId = 1;                                // Identifier of the plan is an SHA256 hash of the HomeNodePlan structure in Google Protobuf v3 encoding 
                                                   // with planId initialized to a byte array of 32 zero bytes.
  bytes nodeNetworkId = 2;                         // Identifier of the node that offers the plan.
  string identityType = 3;                         // Type of identity this plan is created for. This can include "*" as a wildcard character
                                                   // at the end of the type to support multiple types to be served with a single plan. 
                                                   // For example, the value "*" would mean that any identity type is supported,
                                                   // and the value "Taxi *" would mean that any identity type that starts with "Taxi *"
                                                   // would match this plan.
  uint64 fee = 4;                                  // TokenAmountType. Price of the plan per billing period.
  uint32 billingPeriodSeconds = 5;                 // Length of the billing period in seconds.
  repeated NameStringValuePair planParameters = 9; // List of additional service parameters that define the plan.
}

// Description of name-value structure with string values.
message NameStringValuePair {
  string name = 1;                                 // Name of the object.
  string value = 2;                                // String value.
}



//
// Every conversation starts with this request, in which the requestor sends a list of protocol versions 
// it supports and its public key that identifies it.
//
// Roles: any
//
// Conversation status: NoConversation
//
message StartConversationRequest {
  repeated bytes supportedVersions = 1;            // List of VersionType items. Ordered by requestor's preference. See 'SingleRequest.version'.
  bytes publicKey = 2;                             // Public key of the requestor.

  bytes clientChallenge = 3;                       // 32 byte challenge data (random bytes generated by the requestor) that is used for authentication purposes.
}


//
// A response to StartConversationRequest in case the requestee found at least one protocol version that 
// both peers are willing to use. 
// 
// The 'clientChallenge' field value in raw format is signed with a signature in 'ConversationResponse.signature'.
// 
//
// After StartConversationResponse is sent, the conversation context includes version and keys of both peers.
//
// Specific Error Responses:
//   * ERROR_UNSUPPORTED - If the requestee does not support any of the requestor's versions, it replies with this error code.
//   * ERROR_INVALID_VALUE
//     * Response.details == "clientChallenge" - 'StartConversationRequest.clientChallenge' is not 32 byte long. 
//
message StartConversationResponse {
  bytes version = 1;                               // VersionType. The version that the requestee selected from the offered set.
  bytes publicKey = 2;                             // Public key of the requestee.

  bytes challenge = 3;                             // 32 byte challenge data (random bytes generated by the requestee) that is used for later authentication purposes.
  bytes clientChallenge = 4;                       // Copy of 'StartConversationRequest.clientChallenge' that is signed by the requestee. 
                                                   // The requestor can then verify the signature in order to check the requestee's claimed identity.
}


//
// A client asks node to become its home node by sending HomeNodeRequestRequest
// with a signed contract. The signature is provided in 'ConversationRequest.signature'.
//
// Roles: clNonCustomer
//
// Conversation status: ConversationStarted
//
message HomeNodeRequestRequest {
  HomeNodePlanContract contract = 1;               // Description of the contract that the client wants to have with the node.
                                                   // The 'contract.plan' has to be the exact copy of a node offer, no field can be changed, otherwise node will refuse it.
                                                   // The 'contract.startTime' field has to be set either to the future, or to a time that is not 
                                                   // more than 1 hour in past from the current node's time.
}


//
// A response to HomeNodeRequestRequest in case the node wants to accept the request.
// The response body is signed with a signature in 'ConversationResponse.signature'.
//
// Specific Error Responses:
//   * ERROR_QUOTA_EXCEEDED - A node uses this error code in case it wants to express that it will not accept any new clients because it has no free slots.
//   * ERROR_NOT_FOUND - 'HomeNodePlanContract.contract.planId' does not correspond to a node's plan, or the plan values are different from what the node offers.
//   * ERROR_INVALID_SIGNATURE - The client's signature of the contract is not valid.
//   * ERROR_ALREADY_EXISTS - The identity is hosted by the node already.
//   * ERROR_INVALID_VALUE
//     * Response.details == "contract.startTime" - 'HomeNodeRequestRequest.contract.startTime' is more than 1 hour in the past. 
//     * Response.details == "contract.identityPublicKey" - 'HomeNodeRequestRequest.contract.identityPublicKey' does not match identity's public key.
//     * Response.details == "contract.identityType" - 'HomeNodeRequestRequest.contract.identityType' does not match the hosting plan.
//
message HomeNodeRequestResponse {
  HomeNodePlanContract contract = 1;               // Description of the contract that the client wants to have with the node and the node accepted it.
                                                   // This has to be exactly the same contract as the node received in 'HomeNodeRequest.contract',
                                                   // otherwise it is a protocol violation.
}


// A description of the contract between a client and a home node.
message HomeNodePlanContract {
  bytes planId = 1;                                // Identifier of the home node hosting plan.
  bytes identityPublicKey = 2;                     // Public key of the client's identity.
  sint64 startTime = 3;                            // TimestampType. Specifies the start time of the contract.
  string identityType = 4;                         // Type of the client's identity. It has to match the 'HomeNodePlan.identityType' filter in the selected plan.
                                                   // For example, if 'HomeNodePlan.identityType' is "Taxi *" then 'identityType' can be "Taxi Driver",
                                                   // but not "Bus Driver". Also 'identityType' can not contain "*" wildcard, so "Taxi *" is not a valid value
                                                   // for 'identityType' here even if 'HomeNodePlan.identityType' is "Taxi *".
}



// 
// A customer client announces it is online and it "logs in".
// The client has to provide a signature in 'ConversationRequest.signature'.
//
// Note that if a customer client that is authenticated already creates a second connection
// and performs the check-in process in it, the first connection has to be disconnected
// as there can not be multiple parallel connections in Authenticated state for a single identity.
//
// Roles: clCustomer
//
// Conversation status: ConversationStarted
//
message CheckInRequest {
  bytes challenge = 1;                             // The exact copy of 'StartConversationResponse.challenge' from the start of the conversation.
}

//
// A response to CheckInRequest. If no error occurs, the conversation status is upgraded to Authenticated.
//
// Specific Error Responses:
//   * ERROR_INVALID_SIGNATURE - The client's signature of the challenge is not valid.
//   * ERROR_NOT_FOUND - The identity is not a client of the node.
//   * ERROR_INVALID_VALUE
//     * Response.details == "challenge" - 'CheckInRequest.challenge' is not the exact copy of 'StartConversationResponse.challenge' from the start of the conversation.
//
message CheckInResponse {
}


// 
// A non-customer client verifies its public key by signing the challenge. This request is similar to CheckInRequest, 
// but it is intended for non-customer clients. The client has to provide a signature in 'ConversationRequest.signature'.
//
// Roles: clNonCustomer
//
// Conversation status: ConversationStarted
//
message VerifyIdentityRequest {
  bytes challenge = 1;                             // The exact copy of 'StartConversationResponse.challenge' from the start of the conversation.
}

//
// A response to VerifyIdentityRequest. If no error occurs, the conversation status is upgraded to Verified.
//
// Specific Error Responses:
//   * ERROR_INVALID_SIGNATURE - The client's signature of the challenge is not valid.
//   * ERROR_INVALID_VALUE
//     * Response.details == "challenge" - 'VerifyIdentityRequest.challenge' is not the exact copy of 'StartConversationResponse.challenge' from the start of the conversation.
//
message VerifyIdentityResponse {
}


//
// A customer client updates its profile hosted at the node.
// The client must make sure that its profile is complete after processing the request.
// After sending HomeNodeRequestRequest, its profile is almost empty - only identity type 
// and public key are known. This means that the first call of this request 
// has to contain all required information to make the profile complete. Namely the first 
// UpdateProfileRequest has to have setVersion, setName, and setLocation set to true.
//
// The customer client is required to initialize its profile just after finishing 
// the HomeNodeRequestRequest. Until the initialization of the profile is made, the identity 
// is not considered as being fully initialized and can not be queried or called by other 
// identities.
// 
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message UpdateProfileRequest {
  bool setVersion = 1;                             // Profile version should be updated. 'version' must contain valid data.
  bool setName = 2;                                // Profile name should be updated. 'name' must contain valid data.
  bool setImage = 3;                               // Profile image should be updated. 'image' must contain valid data.
  bool setLocation = 4;                            // Profile location should be updated. 'latitude' and 'longitude' must contain valid data.
  bool setExtraData = 5;                           // Profile extra data should be updated. 'extraData' must contain valid data.

  bytes version = 8;                               // VersionType. Version of the profile structure.
  string name = 9;                                 // Name of the profile, non-empty string, max 64 bytes long.
  bytes image = 10;                                // Profile image in PNG or JPEG format, non-empty binary data, max 20,480 bytes long.
  sfixed32 latitude = 11;                          // LocationType. GPS location latitude information.
  sfixed32 longitude = 12;                         // LocationType. GPS location longitude information.
  string extraData = 13;                           // Semicolon separated 'key=value' list, max 200 bytes long.
}


//
// A response to UpdateProfileRequest.
//
// Specific Error Responses:
//   * ERROR_NOT_FOUND - The identity is not a client of the node.
//   * ERROR_INVALID_VALUE
//     * Response.details == "setVersion" - 'UpdateProfileRequest.setVersion' is not set during the first request.
//     * Response.details == "setName" - 'UpdateProfileRequest.setName' is not set during the firts request.
//     * Response.details == "setLocation" - 'UpdateProfileRequest.setLocation' is not set during the firts request.
//     * Response.details == "set*" - Nothing was set to be updated.
//     * Response.details == "version" - 'UpdateProfileRequest.version' does not contain a valid version information.
//     * Response.details == "name" - 'UpdateProfileRequest.name' does not contain a valid name.
//     * Response.details == "image" - 'UpdateProfileRequest.image' does not contain a valid PNG or JPEG image.
//     * Response.details == "latitude" - 'UpdateProfileRequest.latitude' does not contain a valid latitude information.
//     * Response.details == "longitude" - 'UpdateProfileRequest.longitude' does not contain a valid longitude information.
//     * Response.details == "extraData" - 'UpdateProfileRequest.extraData' does not contain a valid extra data information.
//
message UpdateProfileResponse {
}



// 
// A customer client cancels the home node agreement and optionally informs 
// the node about its new home node location. The node will keep the information 
// about identity's new location for some time.
//
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message CancelHomeNodeAgreementRequest {
  bool redirectToNewHomeNode = 1;                  // true, if the client wants to inform the home node about its new home node location, false otherwise.
  bytes newHomeNodeNetworkId = 2;                  // If 'redirectToNewHomeNode' is true, an identifier of the new home node.
}

//
// A response to CancelHomeNodeAgreementRequest.
//
// Specific Error Responses:
//   * ERROR_NOT_FOUND - The identity is not a client of the node.
//   * ERROR_INVALID_VALUE
//     * Response.details == "newHomeNodeNetworkId" - 'CancelHomeNodeAgreementRequest.newHomeNodeNetworkId' is not a valid node network identifier.
//
message CancelHomeNodeAgreementResponse {
}



// 
// Adds (checks-in) one or more application services to the list of services that the customer 
// client supports in the current session.
//
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message ApplicationServiceAddRequest {
  repeated string serviceNames = 1;                // List of application service names to add to the list. If a service name is already 
                                                   // in the list, it will remain in the list and no error is reported.
                                                   // Each service name has to be a non-empty string, max 32 bytes long.
                                                   // Each customer client can have up to 50 application services enabled.
}

//
// A response to ApplicationServiceAddRequest.
//
//   * ERROR_QUOTA_EXCEEDED - The given set of application services can not be added because the client would have more than the maximum number of enabled services.
//   * ERROR_INVALID_VALUE
//     * Response.details == "serviceNames[i]" - 'ApplicationServiceAddRequest.serviceNames[i]' is not a valid service name, where 'i' is a zero-based index.
//
message ApplicationServiceAddResponse {
}



// 
// Removes (checks-out) a single application service from the list of services that the customer 
// client supports in the current session.
//
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message ApplicationServiceRemoveRequest {
  string serviceName = 1;                          // Name of the application service to remove. The service must be in the customer client's list.
}

//
// A response to ApplicationServiceRemoveRequest.
//
// Specific Error Responses:
//   * ERROR_NOT_FOUND - 'ApplicationServiceRemoveRequest.serviceName' does not refer to an application service that was previously added using ApplicationServiceAddRequest.
//
message ApplicationServiceRemoveResponse {
}





//
// Application Service Call - Identity A calls Identity B over application service AS1
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Prior to the service call, we assume the B (the callee) to be a customer of the node with a fully 
// initialized profile and that it knows the ports on which the node operates. In this example, 
// we further assume that A (the caller) is not a customer of the node. If A was a customer, 
// it would use the Check-in Process and communication over clCustomer port instead of communicating 
// over clNonCustomer port and doing the Identity Verification Process. We also assume that A already 
// knows which node is B's home node. Finally, we assume that B has enabled AS1 in its session 
// using ApplicationServiceAddRequest.
//
// Then A can call B over AS1 (an application service):
//
// 1) A performs Port Discovery Process to find node's clNonCustomer and clAppService ports.
// 2) A connects to clNonCustomer port and obtains information about B. A is interested 
//    to know whether B is online and whether AS1 is supported.
// 3) A initiates the call via CallIdentityApplicationServiceRequest.
// 4) The node checks that B is online and that AS1 is available and then it issues a callee's token 
//    and sends it to B with an information about the incoming call.
// 5) B decides to accept the call from A.
// 6) The node issues a caller's token and sends it to A together with the information that B accepted the call.
// 7,8) A and B connects to clAppService port and sends the initialization message with the caller's/callee's token
//    to allow the node to recognize the connections. The node does not reply to these messages until B/A is also 
//    connected.
// 9) A and B can send messages to each other.
// 
//
//
//
// Sequence diagram 2) to 6):
//
//    [ A ]                                           [ Node:clNonCustomer ]                                  [ B ]
//      |                                                   |                                                   |  
//      |                                                   |                                                   |  
//      |                                                   |                                                   |  
//      |  GetIdentityInformationRequest                    |                                                   |
//      *-------------------------------------------------> *                                                   |
//      |  <includeApplicationServices = true>              |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                   GetIdentityInformationResponse  |                                                   |
//      * <-------------------------------------------------*                                                   |
//      |                           <list of supported AS>  |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |  CallIdentityApplicationServiceRequest            |                                                   |
//      *-------------------------------------------------> *                                                   |
//      |  <AS1>                                            |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                                                   |  IncomingCallNotificationRequest                  |
//      |                                                   *-------------------------------------------------> *
//      |                                                   |  <callee's token, AS1>                            |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                  IncomingCallNotificationResponse |
//      |                                                   * <-------------------------------------------------*
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |           CallIdentityApplicationServiceResponse  |                                                   |
//      * <-------------------------------------------------*                                                   |
//      |                                 <caller's token>  |                                                   |  
//      |                                                   |                                                   |  
//                                                                                                                   
//
// Now the both clients are expected to connect to clAppService and send an initialization message to the node 
// using their token.
//
//
// Sequence diagram 7) to 9), assuming that B is the first one to send the initialization message 
// on the clAppService port:
//
//    [ A ]                                           [ Node:clAppService ]                                   [ B ]
//      |                                                   |                                                   |  
//      |                                                   |                                                   |  
//      |                                                   |                                                   |  
//      |                                                   |             ApplicationServiceSendMessageRequest  |
//      |                                                   * <-------------------------------------------------*
//      |                                                   |                       <callee's token, init msg>  |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |  ApplicationServiceSendMessageRequest             |                                                   |
//      *-------------------------------------------------> *                                                   |
//      |  <caller's token, init msg>                       |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |            ApplicationServiceSendMessageResponse  |                                                   |
//      * <-------------------------------------------------*                                                   |
//      |                                 <B is connected>  |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                                                   |  ApplicationServiceSendMessageResponse            |
//      |                                                   *-------------------------------------------------> *
//      |                                                   |  <A is connected>                                 |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |  ApplicationServiceSendMessageRequest             |                                                   |
//      *-------------------------------------------------> *                                                   |
//      |  <caller's token, message #A1>                    |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |  
//      |                                                   |  App..ReceiveMessageNotificationRequest           |
//      |                                                   *-------------------------------------------------> *
//      |                                                   |  <message #A1>                                    |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                                                   |          App..ReceiveMessageNotificationResponse  |
//      |                                                   * <-------------------------------------------------*
//      |                                                   |                                         <got it>  |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |            ApplicationServiceSendMessageResponse  |                                                   |
//      * <-------------------------------------------------*                                                   |
//      |                                      <B got #A1>  |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |                                                   |             ApplicationServiceSendMessageRequest  |
//      |                                                   * <-------------------------------------------------*
//      |                                                   |                    <callee's token, message #B1>  |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |  ApplicationServiceSendMessageRequest             |                                                   |
//      *-------------------------------------------------> *                                                   |
//      |  <caller's token, message #A2>                    |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |           App..ReceiveMessageNotificationRequest  |                                                   |
//      * <-------------------------------------------------*                                                   |
//      |                                    <message #B1>  |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |  
//      |                                                   |  App..ReceiveMessageNotificationRequest           |
//      |                                                   *-------------------------------------------------> *
//      |                                                   |  <message #A2>                                    |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |  App..ReceiveMessageNotificationResponse          |                                                   |
//      *-------------------------------------------------> *                                                   |
//      |  <got it>                                         |                                                   |
//      |                                                   |                                                   |
//      |                                                   |                                                   |  
//      |                                                   |          App..ReceiveMessageNotificationResponse  |
//      |                                                   * <-------------------------------------------------*
//      |                                                   |                                         <got it>  |
//      |                                                   |                                                   |
//      |                                                   |                                                   |  
//      |                                                   |  ApplicationServiceSendMessageResponse            |
//      |                                                   *-------------------------------------------------> *
//      |                                                   |  <A got #B1>                                      |
//      |                                                   |                                                   |
//      |                                                   |                                                   |
//      |            ApplicationServiceSendMessageResponse  |                                                   |
//      * <-------------------------------------------------*                                                   |
//      |                                      <B got #A2>  |                                                   |
//      |                                                   |                                                   |



// 
// Obtains a basic information about an identity hosted on the node.
// If the identity is online, the information includes a list of application services 
// that the identity supports in the currently active session.
//
// Roles: clNonCustomer, clCustomer
//
message GetIdentityInformationRequest {
  bytes identityNetworkId = 1;                     // Identity's network identifier.
  bool includeProfileImage = 2;                    // If set to true, the response will include a profile image.
  bool includeThumbnailImage = 3;                  // If set to true, the response will include a thumbnail image.
  bool includeApplicationServices = 4;             // If set to true and the given identity is online, the response will include 
                                                   // a list of application services that the identity supports in the currently active session.
}


//
// A response to GetIdentityInformationRequest.
//
// Specific Error Responses:
//   * ERROR_NOT_FOUND - 'GetIdentityInformationRequest.identityNetworkId' does not identify an identity hosted by the node.
//   * ERROR_UNINITIALIZED - The target identity's profile has not been initialized yet.
//
message GetIdentityInformationResponse {
  bool isHosted = 1;                               // True if the requested identity is a customer of the node.
  bool isTargetHomeNodeKnown = 2;                  // If 'isHosted' is false then this is true if the identity's new home node is known to the node. In all other cases, this is false.
  bytes targetHomeNodeNetworkId = 3;               // If 'isTargetHomeNodeKnown' is true then this field contains the identity's new home node network ID.

  // Following fields are valid only if 'isHosted' is true.
  bool isOnline = 4;                               // True if the requested identity is currently online.
  bytes identityPublicKey = 5;                     // The requested identity's public key.
  string type = 6;                                 // The requested identity's type.
  string name = 7;                                 // The requested identity's name.
  sfixed32 latitude = 8;                           // LocationType. The requested identity's GPS location latitude information.
  sfixed32 longitude = 9;                          // LocationType. The requested identity's GPS location longitude information.
  string extraData = 10;                           // The requested identity's extra data.
  bytes profileImage = 11;                         // If 'GetIdentityInformationRequest.includeProfileImage' was set, this contains the requested identity's profile image.
  bytes thumbnailImage = 12;                       // If 'GetIdentityInformationRequest.includeThumbnailImage' was set, this contains the requested identity's thumbnail image.

  repeated string applicationServices = 13;        // If 'GetIdentityInformationRequest.includeApplicationServices' was set and if 'isOnline' is true, this contains 
                                                   // the list of application services that the requested identity supports in the currently active session.                                                   
}


// 
// Request to establish a bridged connection between a requestor (the caller) and an identity (the callee) hosted on the node 
// via one of its supported application service. The callee has to be online, otherwise the request will fail.
//
// The node informs the callee about the incoming call and issues a token pair (caller's and callee's tokens) to identify the caller 
// and the callee on the Application Service Interface. The callee's token is sent to the callee with the information about the incoming call. 
// If the callee wants to accept the call, the node informs the caller and sends it the caller's token. Both clients are then expected 
// to establish new connections to the node's Application Service Interface and use their tokens to send a message to the other client.
//
// Roles: clNonCustomer, clCustomer
//
// Conversation status: Verified
//
message CallIdentityApplicationServiceRequest {
  bytes identityNetworkId = 1;                     // Network identifier of the identity to call.
  string serviceName = 2;                          // Name of the application service to use.
}


//
// A response to CallIdentityApplicationServiceRequest.
//
// Specific Error Responses:
//   * ERROR_NOT_AVAILABLE - The callee is not online, or it failed to reply to the notification within the required time frame.
//   * ERROR_REJECTED - The callee rejected the call.
//   * ERROR_UNINITIALIZED - The callee's profile has not been initialized yet.
//   * ERROR_INVALID_VALUE
//     * Response.details == "identityNetworkId" - 'CallIdentityApplicationServiceRequest.identityNetworkId' does not identify an identity hosted by the node.
//     * Response.details == "serviceName" - 'CallIdentityApplicationServiceRequest.serviceName' is not an application service supported by the callee in the current session.
//
message CallIdentityApplicationServiceResponse {
  bytes callerToken = 1;                           // Token for the caller to identify the session on the Application Service Interface.
}


// 
// This request is sent by node to its customer client (the callee) when another client (the caller) wants 
// to establish a call over the customer client's application service.
//
// The callee is required to send its response to this request within 10 seconds, otherwise the call channel will not be established.
//
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message IncomingCallNotificationRequest {
  bytes callerPublicKey = 1;                       // Public key of the caller.
  string serviceName = 2;                          // Name of the application service the caller wants to use.
  bytes calleeToken = 3;                           // Token for the callee to identify the session on the Application Service Interface.
}


//
// A response to CallIdentityApplicationServiceRequest. This is sent by the customer client (the callee) to its home node.
//
// Specific Error Responses:
//   * ERROR_REJECTED - The callee rejects the call.
//
message IncomingCallNotificationResponse {
}



// 
// This request is sent by a client to the node in order to deliver a message to the other client over the opened 
// application service call channel.
//
// After the client connects to clAppService port, it sends an initialization message using this request 
// to inform the node about its identity. This initialization message is not delivered to the other party
// and the node responds to this initialization message only after the other party is also connected.
// In the initialization message, the 'message' field is ignored. If the other party fails to join the channel 
// within 30 seconds, the node closes the existing connection to the connected client.
//
// Until the client receives a reply from the node to its initialization message, it is not allowed to send 
// other ApplicationServiceSendMessageRequest. This would be an error and the node would destroy the channel.
//
// If neither of clients connects to clAppService port or sends an inititial message within 30 seconds 
// after the call was initiated, the node destroys the channel.
// 
// Note that the clients are allowed to disconnect from clNonCustomer/clCustomer port once the caller receives 
// CallIdentityApplicationServiceResponse and the callee sends IncomingCallNotificationResponse.
//
// Each client is only allowed to have 20 ApplicationServiceSendMessageRequest messages pending, 
// which means that there was no ApplicationServiceSendMessageResponse sent to the client. If a client attempts 
// to send another message while having 20 pending messages, the node destroys the call channel.
//
//
// Roles: clAppService
//
message ApplicationServiceSendMessageRequest {
  bytes token = 1;                                 // Client's token to identify the session.
  bytes message = 2;                               // Message to send to the other client.
}


//
// A response to ApplicationServiceSendMessageRequest. This is sent by the node to the client to confirm that it sent 
// the message to the other client and the other client confirmed its arrival.
// 
// If the connection to one of the clients is terminated, the node closes the connection to the other client.
//
// Specific Error Responses:
//   * ERROR_NOT_FOUND - 'ApplicationServiceSendMessageRequest.token' is not a valid token. This can have many causes.
//                       The token itself can have invalid format, or no such token was ever issued by the node. 
//                       However, it can also be the case that the token was valid in the past but the call channel 
//                       was closed by the node for any reason and thus the token is no longer valid. 
//
message ApplicationServiceSendMessageResponse {
}



// 
// This request is sent by a home node after it received ApplicationServiceSendMessageRequest from one of the clients.
// This forwards the message to its intended recipient.
//
// Roles: clAppService
//
message ApplicationServiceReceiveMessageNotificationRequest {
  bytes message = 1;                               // Message that was sent to the intended recipient - a copy of 'ApplicationServiceSendMessageRequest.message'.
}


//
// A response to ApplicationServiceReceiveMessageNotificationRequest.
// 
message ApplicationServiceReceiveMessageNotificationResponse {
}


//
// Obtains identity profiles statistics from a node.
//
// Only actively hosted profiles are counted regardless of whether or not the profiles are initialized.
//
// Roles: clNonCustomer, clCustomer
//
message ProfileStatsRequest {
}


//
// A response to ProfileStatsRequest.
// 
message ProfileStatsResponse {
  repeated ProfileStatsItem stats = 1;             // List of profile statistics grouped by identity type.
}


//
// Statistical information on identities of a specific type.
//
message ProfileStatsItem {
  string identityType = 1;                         // Type of identity. 
  uint32 count = 2;                                // Number of profiles hosted on the node of the specific type of identity.
}


//
// Asks a node for a list of all identities that match the search criteria. This search never returns 
// profiles of old customer identities who cancelled their home node agreement, even if the node still 
// holds some information about those identities.
//
// Each search request only produces a limited number of results. The maximal size of the first set of results 
// is provided by 'maxResponseRecordCount' field. The response to this message contains up to 'maxResponseRecordCount' 
// results. If there are more results available, they are saved to the conversation context, which enables the client 
// to obtain more results with subsequent ProfileSearchPartRequest messages.
//
// The node will not save more than 'maxTotalRecordCount' search requests. 
// The node has allow the client to get additional results at least 1 minute from receiving ProfileSearchRequest,
// but it can maintain the result cache for longer than that.
//
// Once the client sends another ProfileSearchRequest, or if it disconnects, the old search results are discarded.
//
// Roles: clNonCustomer, clCustomer
//
// Conversation status: ConversationStarted, Verified, Authenticated
//
message ProfileSearchRequest {
  bool includeHostedOnly = 1;                      // If set to true, the node only returns profiles of its own customers.
                                                   // If set to false, profiles from the node's neighborhood can be included in the result.
  bool includeThumbnailImages = 2;                 // If set to true, the response will include a thumbnail image of each profile.
  uint32 maxResponseRecordCount = 3;               // Maximal number of results to be delivered in the response. If 'includeThumbnailImages'
                                                   // is true, this has to be an integer between 1 and 100. If 'includeThumbnailImages' is false,
                                                   // this has to be an integer between 1 and 1000. The value must not be greater than 'maxTotalRecordCount'.
  uint32 maxTotalRecordCount = 4;                  // Maximal number of total results that the node will look for and save. If 'includeThumbnailImages'
                                                   // is true, this has to be an integer between 1 and 1000. If 'includeThumbnailImages' is false,
                                                   // this has to be an integer between 1 and 10000.

  // Search filters.
  string type = 5;                                 // WildcardType or empty string. If not empty, the node will only return profiles 
                                                   // of identity types that match the wildcard string. If empty, all identity types are allowed.
                                                   // Max 64 bytes long.
  string name = 6;                                 // WildcardType or empty string. If not empty, the node will only return profiles 
                                                   // with names that match the wildcard string. If empty, all profile names are allowed.
                                                   // Max 64 bytes long.
  sfixed32 latitude = 7;                           // LocationType. Encoded target GPS location latitude or NO_LOCATION. If not NO_LOCATION, 
                                                   // it is, in combination with 'longitude' and 'radius' a specification of target area, 
                                                   // where the identity has to be located (according to its profile information) in order to be 
                                                   // included in the search results. If NO_LOCATION, 'longitude' and 'radius' are ignored 
                                                   // and all locations are allowed.
  sfixed32 longitude = 8;                          // LocationType. If 'latitude' is not NO_LOCATION, this is encoded target GPS location longitude.
  uint32 radius = 9;                               // If 'latitude' is not NO_LOCATION, this is target location radius in metres.
  string extraData = 10;                           // RegexType or empty string. If not empty, specifies the regular expression that identity
                                                   // profile's extra data information must match in order to be included in the results. 
                                                   // If empty, no filtering based on extra data information is made.
                                                   // Max 256 bytes long.
}


//
// A response to ProfileSearchRequest.
//
// If 'maxResponseRecordCount' is lower than 'totalRecordCount', the client is allowed to send ProfileSearchPartRequest messages to obtain more results.
//
//
// Specific Error Responses:
//   * ERROR_INVALID_VALUE
//     * Response.details == "maxResponseRecordCount" - 'ProfileSearchRequest.maxResponseRecordCount' is not within the required range.
//     * Response.details == "maxTotalRecordCount" - 'ProfileSearchRequest.maxTotalRecordCount' is not within the required range.
//     * Response.details == "type" - 'ProfileSearchRequest.type' is too long.
//     * Response.details == "name" - 'ProfileSearchRequest.name' is too long.
//     * Response.details == "latitude" - 'ProfileSearchRequest.latitude' is not a valid location latitude.
//     * Response.details == "longitude" - 'ProfileSearchRequest.longitude' is not a valid location longitude.
//     * Response.details == "radius" - 'ProfileSearchRequest.radius' is not a valid radius value.
//     * Response.details == "extraData" - 'ProfileSearchRequest.extraData' is too long or it is not a valid value of RegexType.
//
message ProfileSearchResponse {
  uint32 totalRecordCount = 1;                     // Total number of profiles that matched the search criteria. Up to 'maxResponseRecordCount' of them are in 'profiles' list.
  uint32 maxResponseRecordCount = 2;               // Limit of the number of results provided. This is equal to 'ProfileSearchRequest.maxResponseRecordCount'.

  // Search results.
  repeated IdentityNetworkProfileInformation profiles = 3;  // List of results that contains no more than 'maxResponseRecordCount' items.
}



//
// Information about a single profile record from a profile search query.
//
message IdentityNetworkProfileInformation {
  bool isHosted = 1;                               // True if the requested identity is a customer of the node.
  bytes neighborNodeNetworkId = 2;                 // If 'isHosted' is false, this field contains the network ID of the neighbor node that is a home node of the target profile.

  bool isOnline = 3;                               // If 'isHosted' is true, this is true if the requested identity is currently online.

  bytes identityPublicKey = 4;                     // The identity's public key.
  string type = 5;                                 // The identity's type.
  string name = 6;                                 // The identity's name.
  sfixed32 latitude = 7;                           // LocationType. The identity's GPS location latitude information.
  sfixed32 longitude = 8;                          // LocationType. The identity's GPS location longitude information.
  string extraData = 9;                            // The identity's extra data.

  bytes thumbnailImage = 10;                       // If 'ProfileSearchRequest.includeThumbnailImages' was set, this contains the identity's thumbnail image.
}



//
// Request to get another part from the search query.
//
// This request only makes sense only if the client previously sent ProfileSearchRequest to the node and the search result contained
// more records than the node provided in the ProfileSearchResponse, and the search results have not expired yet.
//
//
// Roles: clNonCustomer, clCustomer
//
// Conversation status: ConversationStarted, Verified, Authenticated
//
message ProfileSearchPartRequest {
  uint32 recordIndex = 1;                           // Zero-based record index of the first result to retrieve. It has to be an integer between 0 and 'ProfileSearchResponse.totalRecordCount' - 1.
  uint32 recordCount = 2;                           // Number of results to obtain. 'recordIndex' + 'recordCount' must not be greater than 'ProfileSearchResponse.totalRecordCount'.
                                                    // If 'ProfileSearchResponse.includeThumbnailImages' was set, this has to be an integer between 1 and 100,
                                                    // otherwise it has to be an integer between 1 and 1000.
}


//
// A response to ProfileSearchPartRequest.
//
// Specific Error Responses:
//   * ERROR_NOT_AVAILABLE - No cached search results are available. Either the client did not send ProfileSearchRequest previously
//                           in this session, or its results have expired already.
//   * ERROR_INVALID_VALUE
//     * Response.details == "recordIndex" - 'ProfileSearchRequest.recordIndex' is not a valid index of the result.
//     * Response.details == "recordCount" - 'ProfileSearchRequest.recordCount' is not a valid number of results to obtain in combination with 'ProfileSearchRequest.recordIndex'.
//
message ProfileSearchPartResponse {
  uint32 recordIndex = 1;                           // Index of the first result. Copy of 'ProfileSearchPartRequest.recordIndex' value.
  uint32 recordCount = 2;                           // Number of results. Copy of 'ProfileSearchPartRequest.recordCount' value.

  // Search results.
  repeated IdentityNetworkProfileInformation profiles = 3;  // List of results that contains 'ProfileSearchPartRequest.recordCount' items.
}


//
// A customer client announces a relation between its identity and another identity using a relationship card.
//
// The 'cardApplication' field is signed with a signature in 'ConversationRequest.signature'. This signature can be used
// to prove that the card recipient wanted to use the card for the given purpose. The signature on the card of the card's issuer 
// then can be used to prove that the issuer issued the card for the recipient. The customer's public key has to be equal 
// to the card's recipient public key.
//
// Each node is allowed to define its own limit of number of relations that a single identity can have.
// However, this limit should not exceed the maximal limit of 2000 relations, which is given by the maximal protocol message size.
//
//
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message AddRelatedIdentityRequest {
  CardApplicationInformation cardApplication = 1;   // Description of the relationship, which must correspond to the given 'card' - i.e. 'cardApplication.cardId' 
                                                    // has to match 'signedCard.card.cardId'.
  SignedRelationshipCard signedCard = 2;            // Signed relationship card. 'signedCard.card.recipientPublicKey' has to be the public key of the customer
                                                    // that sends AddRelatedIdentityRequest to the node.
}



//
// A response to AddRelatedIdentityRequest.
//
//
// Specific Error Responses:
//   * ERROR_QUOTA_EXCEEDED - The caller has reached its limit for a number of related identities on its profile.
//   * ERROR_INVALID_SIGNATURE - The client's signature of the 'AddRelatedIdentityRequest.cardApplication' in 'ConversationRequest.signature' is not valid.
//   * ERROR_ALREADY_EXISTS - A relationship with application identifier equal to 'AddRelatedIdentityRequest.cardApplication.applicationId' already exists.
//   * ERROR_INVALID_VALUE
//     * Response.details == "cardApplication.cardId" - 'AddRelatedIdentityRequest.cardApplication.cardId' does not match 'AddRelatedIdentityRequest.signedCard.card.cardId'.
//     * Response.details == "cardApplication.applicationId" - 'AddRelatedIdentityRequest.cardApplication.applicationId' is not a valid application identifier.
//     * Response.details == "signedCard.issuerSignature" - 'AddRelatedIdentityRequest.signedCard.issuerSignature' is not a valid signature of 'AddRelatedIdentityRequest.signedCard.card' structure
//                                                          using private key of the issuer whose public key is 'AddRelatedIdentityRequest.signedCard.card.issuerPublicKey'.
//     * Response.details == "signedCard.card.cardId" - 'AddRelatedIdentityRequest.signedCard.card.cardId' is not a valid SHA256 hash of 'AddRelatedIdentityRequest.signedCard.card' structure.
//     * Response.details == "signedCard.card.type" - 'AddRelatedIdentityRequest.signedCard.card.type' is not a valid card type.
//     * Response.details == "signedCard.card.recipientPublicKey" - 'AddRelatedIdentityRequest.signedCard.card.recipientPublicKey' is not the public key of the caller.
//     * Response.details == "signedCard.card.validFrom" - 'AddRelatedIdentityRequest.signedCard.card.validFrom' is greater than 'AddRelatedIdentityRequest.signedCard.card.validTo'.
//
message AddRelatedIdentityResponse {
}



//
// A customer client removes the announcement of a relationship between its identity and another identity.
//
//
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message RemoveRelatedIdentityRequest {
  bytes applicationId = 1;                          // Identifier of the card application to remove. 
}



//
// A response to RemoveRelatedIdentityRequest.
//
//
// Specific Error Responses:
//   * ERROR_NOT_FOUND - A relationship with application identifier equal to 'AddRelatedIdentityRequest.cardApplication.applicationId' was not found.
//
message RemoveRelatedIdentityResponse {
}



//
// Description of a relationship card application. It consists of a card identifier, which is a hash of the card data
// and the 'applicationId', which binds the use of the card with some other object, transaction, or action, which is specific 
// for the given use of the card.
//
message CardApplicationInformation {
  bytes cardId = 1;                                 // Identifier of a relationship card. See 'RelationshipCard.cardId'.
  bytes applicationId = 2;                          // Unique identifier of the action that represents using the card. This is used to bind the application of the card 
                                                    // with a specific transaction or action. If no transaction or action identifier exists, the recipient should 
                                                    // generate a new GUID. If the given card is guaranteed to be used only once, this can be equal to 'cardId'.
                                                    // Max 32 bytes long. Must not be empty.
}


// 
// Description of a relationship card signed by its issuer. Only the identifier of the card is signed, but since this is a SHA256 
// hash of all the card's fields (except for the ID itself), the signature of the identifier effectively signs the whole card information.
//
message SignedRelationshipCard {
  RelationshipCard card = 1;                        // Description of the relationship card.
  bytes issuerSignature = 2;                        // Signature of 'card.cardId' value in raw format using private key of the issuer of the card.
                                                    // Max 100 bytes long.
}


//
// Description of a relationship card.
//
message RelationshipCard {
  bytes cardId = 1;                                 // Identifier of a relationship card is an SHA256 hash of the RelationshipCard structure in Google Protobuf v3 encoding 
                                                    // with cardId initialized to a byte array of 32 zero bytes.
  string type = 2;                                  // Type of the relationship card. This is an application defined value. Max 64 bytes long.
  sint64 validFrom = 3;                             // TimestampType. Time from which the card is valid. It must not be greater than 'validTo'.
  sint64 validTo = 4;                               // TimestampType. Time after which the card is not valid.
  bytes issuerPublicKey = 5;                        // Public key of the issuer of the card.
  bytes recipientPublicKey = 6;                     // Public key of the recipient of the card.
}




// 
// Obtains list of identity's relationships that match the given criteria.
//
// Roles: clNonCustomer, clCustomer
//
message GetIdentityRelationshipsInformationRequest {
  bytes identityNetworkId = 1;                     // Identity's network identifier.
  bool includeInvalid = 2;                         // If set to true, the response may include relationships which cards are no longer valid or not yet valid.
  
  string type = 3;                                 // WildcardType or empty string. If not empty, the node will only return relationships which card types 
                                                   // match the wildcard string. If empty, all card types are allowed.
                                                   // Max 64 bytes long.

  bool specificIssuer = 4;                         // If set to true, the response will only include relationships which cards were issued by issuer with 'issuerPublicKey' public key.
  bytes issuerNetworkId = 5;                       // If 'specificIssuer' is true, this is the network identifier of the card issuer whose relationships with the target identity are being queried.
}



//
// A response to GetIdentityRelationshipsInformationRequest.
//
// Specific Error Responses:
//   * ERROR_INVALID_VALUE
//     * Response.details == "type" - 'GetIdentityRelationshipsInformationRequest.type' is too long.
//
message GetIdentityRelationshipsInformationResponse {
  repeated IdentityRelationship relationships = 1; // List of all matching identity relationships together with their relationship cards.
}


//
// Description of a relationship between two identities together with signature proofs.
//
message IdentityRelationship {
  CardApplicationInformation cardApplication = 1;  // Relationship card application.
  bytes cardApplicationSignature = 2;              // Relationship card recipient's signature of 'cardApplication' structure.
  SignedRelationshipCard card = 3;                 // Relationship card signed by its issuer.
}

