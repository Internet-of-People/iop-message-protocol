//
// Definition of IoP Home Node protocol.
// We strictly use only features that are binary compatible in ProtoBuf v2 and v3.
// We use no v2 or v3 specific features.
//
//
//
//
// * Roles *
// ~~~~~~~~~
//
// Each node has several roles. Each message belongs to one or more roles.
// If a request is sent to a port that does not handle the specific role, 
// ERROR_BAD_ROLE is returned.
//
// Existing roles and their short names are:
//
//   * Primary and Unrelated Nodes Interface = "primary"
//   * Neighbors Interface = "ndNeighbor"
//   * Colleagues Interface = "ndColleague"
//   * Customer Clients Interface = "clCustomer"
//   * Non Customer Clients Interface = "clNonCustomer"
//   * Application Service Interface = "clAppService"
//
//
// We mark each request with a list of roles that can serve that request.
// If all roles can serve the request, we use "any" marker.
//
//
//
//
// * Reused Types *
// ~~~~~~~~~~~~~~~~
//
// Protobuf does not allow us to specify some types completely, this is why we 
// define some of the types we reuse a lot here.
//
//  * VersionType - Protocol or structure version specification encoded in 3 bytes - see http://semver.org/. 
//                  First byte is MAJOR, second byte is MINOR, third byte is PATCH.
//
//  * TimestampType - 64-bit signed timestamp that is similar to Unix timestamp, except that it counts 
//                    milliseconds since the epoch start instead of seconds and is 64-bit instead of 32-bit.
//
//  * TokenAmountType - IoP token amounts are represented by 64-bit unsigned integers similarly how bitcoins
//                      are represented in the Bitcoin protocol. Each IoP token is divisible to 100,000,000 
//                      smallest units and all amounts in the protocol are in these smallest units. Thus 
//                      a numberical value of 100,000,000 within a TokenAmountType field represents 1 full 
//                      IoP token.
//
//
//
//
// * Conversations *
// ~~~~~~~~~~~~~~~~~
//
// Each message in the protocol can either be a separated message called "Single Message" or it can be a part 
// of a longer conversation. Response to a Single Message is a "Single Response". These request and response 
// exist without any context. All the information needed to process the request has to be included in the message.
//
// Conversations are different. They establish a context and conversation messages can thus rely on the 
// information provided earlier in the conversation. These are the possible conversation statuses:
//
//   * NoConversation - No conversation has been started.
//
//   * ConversationStarted - There is an established conversation with the client, but no authentication 
//                           has been done.
//
//   * Verified - There is an established conversation with the non-customer client and the verification process 
//                has already been completed. 
//
//   * Authenticated - There is an established conversation with the customer client and the authentication process 
//                     has already been completed.
//
//
// For each conversation messages we define in which state must the conversation be. If the conversation 
// message is sent in a different state, it is an error. Note that if the required status is Verified
// and the current status is Authenticated, the requirement is satisfied.
//
//   * ERROR_BAD_CONVERSATION_STATUS - If the required state is NoConversation or ConversationStarted, 
//                                     but the current state is different.
//
//   * ERROR_UNAUTHORIZED - If the required status is Authenticated, but the current status is different; 
//                          OR the required status is Verified and the current status is neither Verified 
//                          nor Authenticated.
// 
//


syntax = "proto3";


package iop.homenode;

// Return codes to requests that inform requestor about whether the operation completed successfully or which error occurred.
enum Status {
  // General codes that can be returned to any message.
  STATUS_OK = 0;                                   // The operation completed successfully.

  ERROR_PROTOCOL_VIOLATION = 1;                    // The incoming request does not follow the protocol.
  ERROR_UNSUPPORTED = 2;                           // The peer does not support the request. This is returned when a peer sends a message with an unsupported protocol version.
  ERROR_BANNED = 3;                                // The peer will not process the request bacause the requestor is on the blacklist. Information about the blacklist entry expiration is provided in 'Response.timestamp'.
  ERROR_BUSY = 4;                                  // The peer will not process the request because it is too busy. The requestor can try later.

  ERROR_UNAUTHORIZED = 5;                          // Within conversation, some server roles require authorization of the peer before certain requests are allowed.
                                                   // For example, the clCustomer role requires clients to authorize themselves before certain requests can be sent.
                                                   // This means that such requests require authorization and this error code is returned if a peer sends a request without prior authorization.

  ERROR_BAD_ROLE = 6;                              // If a request is sent to a port that does not handle the specific role, this error is returned.
  ERROR_BAD_CONVERSATION_STATUS = 7;               // The conversation status is different from what the message requires.
  ERROR_INTERNAL = 8;                              // Internal error occurred while processing the message.


  // Return codes specific to a request.
  ERROR_QUOTA_EXCEEDED = 51;                       // The peer reached or exceeded prescribed limits.
  ERROR_INVALID_SIGNATURE = 52;                    // The signature provided be the peer does not correspond to the peer's key or the message being signed.
  ERROR_NOT_FOUND = 53;                            // A referenced object was not found.
  ERROR_INVALID_VALUE = 54;                        // One of the values provided is invalid.
  ERROR_ALREADY_EXISTS = 55;                       // An object with the same identifier already exists.
  ERROR_NOT_AVAILABLE = 56;                        // A request object is not available.
  ERROR_REJECTED = 57;                             // A third party rejected the requested action.
}


// This is complete message as it goes over the wire. It includes the 32-bit header with message length.
message MessageWithHeader {
  fixed32 header = 1;                              // Message length (without the size of the header) as a little-endian 32-bit unsigned integer.
  Message body = 2;                                // Message itself.
}



// Format of a single message.
message Message {
  uint32 id = 1;                                   // Requestor defined message ID that the requestee has to return in the response. 
                                                   // Requestor is responsible for using different ID for every unprocessed message.
                                                   // If at any point there exist two open requests (i.e. without a response) with the same ID, it is a violation of the protocol and the behavior is undefined.

  oneof MessageType {                              // Message can be either:
    Request request = 2;                           //  * a new request,
    Response response = 3;                         //  * or response to a previous request.
  }
}


// Every conversation starts with a request of a requestor.
// This can be either a single request, for which it is expected to receive a single response,
// or this can be part of a longer conversation between the peers.
message Request {
  oneof ConversationType {                         // Either a request lives on its own without any session or context, or it is a part of a conversation.
    SingleRequest singleRequest = 1;               // Single requests are requests that are supposed to be sent without further context.
    ConversationRequest conversationRequest = 2;   // Conversation requests form a session with a context that has to be maintained by peers in order to correctly interpret the messages.
  }  
}


// To every request there is a response.
message Response {
  Status status = 1;                               // Return code.
  sint64 timestamp = 2;                            // TimestampType. If status is ERROR_BANNED, this field specifies when the blacklist entry expires.
  string details = 3;                              // In case of an error, this field may contain additional details.

  oneof ConversationType {                         // See 'Request.ConversationType'.
    SingleResponse singleResponse = 8;             // Responses to single requests are sent as single responses,
    ConversationResponse conversationResponse = 9; // responses to conversation requests are sent as conversation responses.
  }
}


// Single requests live on their own without any session or context. 
// It is always possible to process a single request without any additional informaiton.
message SingleRequest {
  bytes version = 1;                               // VersionType. Protocol version specification.
  oneof RequestType {                              // There are many different standalone requests that can be sent by the requestor.
    PingRequest ping = 2;
    ListRolesRequest listRoles = 3;
    ListHomeNodePlansRequest listHomeNodePlans = 4;
    GetIdentityInformationRequest getIdentityInformation = 5;
    ApplicationServiceSendMessageRequest applicationServiceSendMessage = 6;
    ApplicationServiceReceiveMessageNotificationRequest applicationServiceReceiveMessageNotification = 7;
  }
}



// Single response is a reaction to single request. 
message SingleResponse {
  bytes version = 1;                               // VersionType. See 'SingleRequest.version'. The version of response can be different than the version in request, 
                                                   // if the requestee does not support the version by the requestor.
                                                   // If the requestor is able to process the message using the version of protocol, the version value is the same as in the request.

  oneof ResponseType {                             // See 'SingleRequest.RequestType'. Each request has its corresponding response.
    PingResponse ping = 2;
    ListRolesResponse listRoles = 3;
    ListHomeNodePlansResponse listHomeNodePlans = 4;
    GetIdentityInformationResponse getIdentityInformation = 5;
    ApplicationServiceSendMessageResponse applicationServiceSendMessage = 6;
    ApplicationServiceReceiveMessageNotificationResponse applicationServiceReceiveMessageNotification = 7;
  }
}



// Conversation requests live in a session with a context that is important for the interpretation of the requests.
// Unlike single requests, the order of messages is very important as each message may change the session context.
message ConversationRequest {
  bytes signature = 1;                             // Optional (request specific) signature that signs the Protobuf binary form of the included request body.

  oneof RequestType {                              // There are many different requests that can be sent in the conversation.
    // Request body.
    StartConversationRequest start = 2;
    HomeNodeRequestRequest homeNodeRequest = 3;
    CheckInRequest checkIn = 4;
    VerifyIdentityRequest verifyIdentity = 5;
    UpdateProfileRequest updateProfile = 6;
    CancelHomeNodeAgreementRequest cancelHomeNodeAgreement = 7;
    ApplicationServiceAddRequest applicationServiceAdd = 8;
    ApplicationServiceRemoveRequest applicationServiceRemove = 9;
    CallIdentityApplicationServiceRequest callIdentityApplicationService = 10;
    IncomingCallNotificationRequest incomingCallNotification = 11;
  }
}


// Conversation response is a reaction to a conversation request.
message ConversationResponse {
  bytes signature = 1;                             // Optional (response specific) signature that signs the Protobuf binary form of the included response body.

  oneof RequestType {                              // There are many different requests that can be sent in the conversation.
    // Response body.
    StartConversationResponse start = 2;
    HomeNodeRequestResponse homeNodeRequest = 3;
    CheckInResponse checkIn = 4;
    VerifyIdentityResponse verifyIdentity = 5;
    UpdateProfileResponse updateProfile = 6;
    CancelHomeNodeAgreementResponse cancelHomeNodeAgreement = 7;
    ApplicationServiceAddResponse applicationServiceAdd = 8;
    ApplicationServiceRemoveResponse applicationServiceRemove = 9;
    CallIdentityApplicationServiceResponse callIdentityApplicationService = 10;
    IncomingCallNotificationResponse incomingCallNotification = 11;
  }
}





//
// An administrative message to test whether the peer is there and responds to requests.
//
// Roles: any
//
message PingRequest {
  bytes payload = 1;                               // At most 64 bytes of arbitrary data that will be sent back by the peer.
}

// A response to PingRequest to reassure the connection works fine.
message PingResponse {
  bytes payload = 1;                               // See 'PingRequest.payload'.
  sint64 clock = 2;                                // 64-bit signed Unix UTC time on the requestee's machine.
}



//
// Request server to provide a mapping between ports and roles.
//
// Roles: primary
//
message ListRolesRequest {
}

// A response to ListRolesRequest with a list of all open ports and associated roles.
message ListRolesResponse {
  repeated ServerRole role = 1;                    // List of server roles.
}


// Known server roles.
enum ServerRoleType {
  PRIMARY = 0;                                     // Primary and Unrelated Nodes Interface server role.
  ND_NEIGHBOR = 1;                                 // Neighbors Interface server role.
  ND_COLLEAGUE = 2;                                // Colleagues Interface server role.
  CL_NON_CUSTOMER = 3;                             // Customer Clients Interface server role.
  CL_CUSTOMER = 4;                                 // Non Customer Clients Interface server role.
}


// Description of a single server role.
message ServerRole {
  ServerRoleType role = 1;                         // Server role type.
  uint32 port = 2;                                 // On which port is this server role provided.
  bool isTcp = 3;                                  // true if the port is TCP port, false means UDP.
  bool isTls = 4;                                  // true if the port is TLS encrypted, false otherwise.
}


//
// A client asks node for its home node plans that match the given criteria.
//
// Roles: clNonCustomer
//
message ListHomeNodePlansRequest {
  string identityType = 1;                         // A specific identity type, for which the client searches the plan.
  // Other criteria TBD.
}


//
// A response to ListHomeNodePlansRequest that contains a list of matching plans.
//
// Specific Error Responses: 
//   * ERROR_QUOTA_EXCEEDED - A node users this error code in case it wants to express that it will not accept any new clients because it has no free slots.
//
message ListHomeNodePlansResponse {
  repeated HomeNodePlan plans = 1;                 // List of matching plans.
}


// Description of a home node hosting plan.
message HomeNodePlan {
  bytes planId = 1;                                // GUID of the plan. If a node wants to change the plan, it has to change the GUID as well,
                                                   // thus effectively creating a new plan.
  string identityType = 2;                         // Type of identity this plan is created for. This can include "*" as a wildcard character
                                                   // at the end of the type to support multiple types to be served with a single plan. 
                                                   // For example, the value "*" would mean that any identity type is supported,
                                                   // and the value "Taxi *" would mean that any identity type that starts with "Taxi *"
                                                   // would match this plan.
  uint64 fee = 3;                                  // TokenAmountType. Price of the plan per billing period.
  uint32 billingPeriodSeconds = 4;                 // Length of the billing period in seconds.
  repeated NameStringValuePair planParameters = 9; // List of additional service parameters that define the plan.
}

// Description of name-value structure with string values.
message NameStringValuePair {
  string name = 1;                                 // Name of the object.
  string value = 2;                                // String value.
}



//
// Every conversation starts with this request, in which the requestor sends a list of protocol versions 
// it supports and its public key that identifies it.
//
// Roles: any
//
// Conversation status: NoConversation
//
message StartConversationRequest {
  repeated bytes supportedVersions = 1;            // List of VersionType items. Ordered by requestor's preference. See 'SingleRequest.version'.
  bytes publicKey = 2;                             // Public key of the requestor.
}


//
// A response to StartConversationRequest in case the requestee found at least one protocol version that 
// both peers are willing to use. 
// 
//
// After StartConversationResponse is sent, the conversation context includes version and keys of both peers.
//
// Specific Error Responses:
//   * ERROR_UNSUPPORTED - If the requestee does not support any of the requestor's versions, it replies with this error code.
//
message StartConversationResponse {
  bytes version = 1;                               // VersionType. The version that the requestee selected from the offered set.
  bytes publicKey = 2;                             // Public key of the requestee.

  bytes challenge = 3;                             // 32 byte challenge data (random bytes generated by the requestee) that is used for later authentication purposes.
                                                   // This field is required only for clCustomer server role.
}


//
// A client asks node to become its home node by sending HomeNodeRequestRequest
// with a signed contract. The signature is provided in 'ConversationRequest.signature'.
//
// Roles: clNonCustomer
//
// Conversation status: ConversationStarted
//
message HomeNodeRequestRequest {
  HomeNodePlanContract contract = 1;               // Description of the contract that the client wants to have with the node.
                                                   // The 'contract.plan' has to be the exact copy of a node offer, no field can be changed, otherwise node will refuse it.
                                                   // The 'contract.startTime' field has to be set either to the future, or to a time that is not 
                                                   // more than 1 hour in past from the current node's time.
}


//
// A response to HomeNodeRequestRequest in case the node wants to accept the request.
// The contract is signed with a signature in ConversationResponse.signature.
//
// Specific Error Responses:
//   * ERROR_QUOTA_EXCEEDED - A node uses this error code in case it wants to express that it will not accept any new clients because it has no free slots.
//   * ERROR_NOT_FOUND - 'HomeNodePlanContract.contract.plan.planId' does not correspond to a node's plan, or the plan values are different from what the node offers.
//   * ERROR_INVALID_SIGNATURE - The client's signature of the contract is not valid.
//   * ERROR_ALREADY_EXISTS - The identity is hosted by the node already.
//   * ERROR_INVALID_VALUE
//     * Response.details == "contract.startTime" - 'HomeNodeRequestRequest.contract.startTime' is more than 1 hour in the past. 
//     * Response.details == "contract.nodePublicKey" - 'HomeNodeRequestRequest.contract.nodePublicKey' does not match node's public key. 
//     * Response.details == "contract.identityPublicKey" - 'HomeNodeRequestRequest.contract.identityPublicKey' does not match identity's public key.
//
message HomeNodeRequestResponse {
  HomeNodePlanContract contract = 1;               // Description of the contract that the client wants to have with the node and the node accepted it.
                                                   // This has to be exactly the same contract as the node received in 'HomeNodeRequest.contract',
                                                   // otherwise it is a protocol violation.
}


// A description of the contract between a client and a home node.
message HomeNodePlanContract {
  HomeNodePlan plan = 1;                           // Description of the home node hosting plan.
  bytes nodePublicKey = 2;                         // Public key of the node.
  bytes identityPublicKey = 3;                     // Public key of the identity.
  sint64 startTime = 4;                            // TimestampType. Specifies the start time of the contract.
}



// 
// A customer client announces it is online and it "logs in".
// The client has to provide a signature in 'ConversationRequest.signature'.
//
// Roles: clCustomer
//
// Conversation status: ConversationStarted
//
message CheckInRequest {
  bytes challenge = 1;                             // The exact copy of 'StartConversationResponse.challenge' from the start of the conversation.
}

//
// A response to CheckInRequest. If no error occurs, the conversation status is upgraded to Authenticated.
//
// Specific Error Responses:
//   * ERROR_INVALID_SIGNATURE - The client's signature of the challenge is not valid.
//   * ERROR_NOT_FOUND - The identity is not a client of the node.
//   * ERROR_INVALID_VALUE
//     * Response.details == "challenge" - 'CheckInRequest.challenge' is not the exact copy of 'StartConversationResponse.challenge' from the start of the conversation.
//
message CheckInResponse {
}


// 
// A non-customer client verifies its public key by signing the challenge. This request is similar to CheckInRequest, 
// but it is intended for non-customer clients. The client has to provide a signature in 'ConversationRequest.signature'.
//
// Roles: clNonCustomer
//
// Conversation status: ConversationStarted
//
message VerifyIdentityRequest {
  bytes challenge = 1;                             // The exact copy of 'StartConversationResponse.challenge' from the start of the conversation.
}

//
// A response to VerifyIdentityRequest. If no error occurs, the conversation status is upgraded to Verified.
//
// Specific Error Responses:
//   * ERROR_INVALID_SIGNATURE - The client's signature of the challenge is not valid.
//   * ERROR_INVALID_VALUE
//     * Response.details == "challenge" - 'VerifyIdentityRequest.challenge' is not the exact copy of 'StartConversationResponse.challenge' from the start of the conversation.
//
message VerifyIdentityResponse {
}


//
// A customer client updates its profile hosted at the node.
// The client must make sure that its profile is complete after processing the request.
// After sending HomeNodeRequest, its profile is almost empty - only identity type 
// and public key are known. This means that the first call of this request 
// has to contain all required information to make the profile complete. Namely the first 
// UpdateProfileRequest has to have setVersion, setName, and setLocation set to true.
// 
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message UpdateProfileRequest {
  bool setVersion = 1;                             // Profile version should be updated. 'version' must contain valid data.
  bool setName = 2;                                // Profile name should be updated. 'name' must contain valid data.
  bool setImage = 3;                               // Profile image should be updated. 'image' must contain valid data.
  bool setLocation = 4;                            // Profile location should be updated. 'location' must contain valid data.
  bool setExtraData = 5;                           // Profile extra data should be updated. 'extraData' must contain valid data.

  bytes version = 8;                               // VersionType. Version of the profile structure.
  string name = 9;                                 // Name of the profile, non-empty string, max 64 bytes long.
  bytes image = 10;                                // Profile image in PNG or JPEG format, non-empty binary data, max 20,480 bytes long.
  fixed32 location = 11;                           // Encoded GPS location information.
  string extraData = 12;                           // Semicolon separated 'key=value' list, max 200 bytes long.
}


//
// A response to UpdateProfileRequest.
//
// Specific Error Responses:
//   * ERROR_NOT_FOUND - The identity is not a client of the node.
//   * ERROR_INVALID_VALUE
//     * Response.details == "setVersion" - 'UpdateProfileRequest.setVersion' is not set during the first request.
//     * Response.details == "setName" - 'UpdateProfileRequest.setName' is not set during the firts request.
//     * Response.details == "setLocation" - 'UpdateProfileRequest.setLocation' is not set during the firts request.
//     * Response.details == "set*" - Nothing was set to be updated.
//     * Response.details == "version" - 'UpdateProfileRequest.version' does not contain a valid version information.
//     * Response.details == "name" - 'UpdateProfileRequest.name' does not contain a valid name.
//     * Response.details == "image" - 'UpdateProfileRequest.image' does not contain a valid PNG or JPEG image.
//     * Response.details == "location" - 'UpdateProfileRequest.image' does not contain a valid location information.
//     * Response.details == "extraData" - 'UpdateProfileRequest.extraData' does not contain a valid extra data information.
//
message UpdateProfileResponse {
}



// 
// A customer client cancels the home node agreement and optionally informs 
// the node about its new home node location. The node will keep the information 
// about identity's new location for some time.
//
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message CancelHomeNodeAgreementRequest {
  bool redirectToNewHomeNode = 1;                  // true, if the client wants to inform the home node about its new home node location, false otherwise.
  bytes newHomeNodeNetworkId = 2;                  // If 'redirectToNewHomeNode' is true, an identifier of the new home node.
}

//
// A response to CancelHomeNodeAgreementRequest.
//
// Specific Error Responses:
//   * ERROR_NOT_FOUND - The identity is not a client of the node.
//   * ERROR_INVALID_VALUE
//     * Response.details == "newHomeNodeNetworkId" - 'CancelHomeNodeAgreementRequest.newHomeNodeNetworkId' is not a valid node network identifier.
//
message CancelHomeNodeAgreementResponse {
}



// 
// Adds (checks-in) one or more application services to the list of services that the customer 
// client supports in the current session.
//
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message ApplicationServiceAddRequest {
  repeated string serviceNames = 1;                // List of application service names to add to the list. If a service name is already 
                                                   // in the list, it will remain in the list and no error is reported.
                                                   // Each service name has to be a non-empty string, max 32 bytes long.
}

//
// A response to ApplicationServiceAddRequest.
//
//   * ERROR_INVALID_VALUE
//     * Response.details == "serviceNames[i]" - 'ApplicationServiceAddRequest.serviceNames[i]' is not a valid service name, where 'i' is the zero-based index.
//
message ApplicationServiceAddResponse {
}



// 
// Removes (checks-out) a single application service from the list of services that the customer 
// client supports in the current session.
//
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message ApplicationServiceRemoveRequest {
  string serviceName = 1;                          // Name of the application service to remove. The service must be in the customer client's list.
}

//
// A response to ApplicationServiceRemoveRequest.
//
// Specific Error Responses:
//   * ERROR_NOT_FOUND - 'ApplicationServiceRemoveRequest.serviceName' does not refer to an application service that was previously added using ApplicationServiceAddRequest.
//
message ApplicationServiceRemoveResponse {
}


// 
// Obtains a basic information about an identity hosted on the node.
// If the identity is online, the information includes a list of application services 
// that the identity supports in the currently active session.
//
// Roles: clNonCustomer, clCustomer
//
message GetIdentityInformationRequest {
  bytes identityNetworkId = 1;                     // Identity's network identifier.
  bool includeProfileImage = 2;                    // If set to true, the response will include a profile image.
  bool includeThumbnailImage = 3;                  // If set to true, the response will include a thumbnail image.
  bool includeApplicationServices = 4;             // If set to true and the given identity is online, the response will include 
                                                   // a list of application services that the identity supports in the currently active session.
}


//
// A response to GetIdentityInformationRequest.
//
// Specific Error Responses:
//   * ERROR_NOT_FOUND - 'GetIdentityInformationRequest.identityNetworkId' does not identify an identity hosted by the node.
//
message GetIdentityInformationResponse {
  bool isHosted = 1;                               // True if the requested identity is a customer of the node.
  bool isTargetHomeNodeKnown = 2;                  // If 'isHosted' is false then this is true if the identity's new home node is known to the node. In all other cases, this is false.
  bytes targetHomeNodeNetworkId = 3;               // If 'isTargetHomeNodeKnown' is true then this field contains the identity's new home node network ID.

  // Following fields are valid only if 'isHosted' is true.
  bool isOnline = 4;                               // True if the requested identity is currently online.
  bytes identityPublicKey = 5;                     // The requested identity's public key.
  string name = 6;                                 // The requested identity's name.
  string extraData = 7;                            // The requested identity's extra data.
  bytes profileImage = 8;                          // If 'GetIdentityInformationRequest.includeProfileImage' was set, this contains the requested identity's profile image.
  bytes thumbnailImage = 9;                        // If 'GetIdentityInformationRequest.includeThumbnailImage' was set, this contains the requested identity's thumbnail image.

  repeated string applicationServices = 10;        // If 'GetIdentityInformationRequest.includeApplicationServices' was set and if 'isOnline' is true, this contains 
                                                   // the list of application services that the requested identity supports in the currently active session.
}


// 
// Request to establish a bridged connection between a requestor (the caller) and an identity (the callee) hosted on the node 
// via one of its supported application service. The callee has to be online, otherwise the request will fail.
//
// The node informs the callee about the incoming call and issues a token pair (caller's and callee's tokens) to identify the caller 
// and the callee on the Application Service Interface. The callee's token is sent to the callee with the information about the incoming call. 
// If the callee wants to accept the call, the node informs the caller and sends it the caller's token. Both clients are then expected 
// to establish new connections to the node's Application Service Interface and use their tokens to send a message to the other client.
//
// Roles: clNonCustomer, clCustomer
//
// Conversation status: Verified
//
message CallIdentityApplicationServiceRequest {
  bytes identityNetworkId = 1;                     // Network identifier of the identity to call.
  string serviceName = 2;                          // Name of the application service to use.
}


//
// A response to CallIdentityApplicationServiceRequest.
//
// Specific Error Responses:
//   * ERROR_NOT_AVAILABLE - The callee is not online.
//   * ERROR_REJECTED - The callee rejected the call.
//   * ERROR_INVALID_VALUE
//     * Response.details == "identityNetworkId" - 'CallIdentityApplicationServiceRequest.identityNetworkId' does not identify an identity hosted by the node.
//     * Response.details == "serviceName" - 'CallIdentityApplicationServiceRequest.serviceName' is not an application service supported by the callee in the current session.
//
message CallIdentityApplicationServiceResponse {
  bytes callerToken = 1;                           // Token for the caller to identify the session on the Application Service Interface.
}


// 
// This request is sent by node to its customer client (the callee) when another client (the caller) wants 
// to establish a call over the customer client's application service.
//
// Roles: clCustomer
//
// Conversation status: Authenticated
//
message IncomingCallNotificationRequest {
  bytes callerPublicKey = 1;                       // Public key of the caller.
  string serviceName = 2;                          // Name of the application service the caller wants to use.
  bytes calleeToken = 3;                           // Token for the callee to identify the session on the Application Service Interface.
}


//
// A response to CallIdentityApplicationServiceRequest. This is sent by the customer client (the callee) to its home node.
//
// Specific Error Responses:
//   * ERROR_REJECTED - The callee rejects the call.
//
message IncomingCallNotificationResponse {
}



// 
// This request is sent by a client to the node in order to deliver a message to the other client over the opened 
// application service call session.
//
// Roles: clAppService
//
message ApplicationServiceSendMessageRequest {
  bytes token = 1;                                 // Client's token to identify the session.
  bytes message = 2;                               // Message to send to the other client.
}


//
// A response to ApplicationServiceSendMessageRequest. This is sent by the node to the client to confirm that it sent 
// the message to the other client.
// 
// If the connection to one of the clients is terminated, the node closes the connection to the other client.
//
message ApplicationServiceSendMessageResponse {
}



// 
// This request is sent by a home node after it received ApplicationServiceSendMessageRequest from one of the clients.
// This forwards the message to its intended recipient.
//
// Roles: clAppService
//
message ApplicationServiceReceiveMessageNotificationRequest {
  bytes message = 1;                               // Message that was sent to the intended recipient - a copy of 'ApplicationServiceSendMessageRequest.message'.
}


//
// A response to ApplicationServiceReceiveMessageNotificationRequest.
// 
message ApplicationServiceReceiveMessageNotificationResponse {
}

